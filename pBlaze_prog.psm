;#EQU	OP1_0	0xd1	; LSB
;#EQU	OP1_1	0xbc
;#EQU	OP1_2	0x0a
;#EQU	OP1_3	0x00
;#EQU	OP1_4	0x00
;#EQU	OP1_5	0x00
;#EQU	OP1_6	0x00
;#EQU	OP1_7	0x00	; MSB

;#EQU	OP2_0	0x01	; LSB
;#EQU	OP2_1	0x00
;#EQU	OP2_2	0x00 
;#EQU	OP2_3	0x00
;#EQU	OP2_4	0x00
;#EQU	OP2_5	0x00
;#EQU	OP2_6	0x10
;#EQU	OP2_7	0x81	; MSB

#EQU	OP1_0	0x01	; LSB
#EQU	OP1_1	0x00
#EQU	OP1_2	0x56
#EQU	OP1_3	0x34
#EQU	OP1_4	0x00
#EQU	OP1_5	0x00
#EQU	OP1_6	0x00
#EQU	OP1_7	0x53	; MSB

#EQU	OP2_0	0x01    ; LSB
#EQU	OP2_1	0x00 
#EQU	OP2_2	0x78 
#EQU	OP2_3	0x56
#EQU	OP2_4	0x34
#EQU	OP2_5	0x00
#EQU	OP2_6	0x10
#EQU	OP2_7	0x00   ; MSB

; Scratch Pad Memory locations
#EQU x_7,		0		; Do not change the decimal numbers or load into SPM will not work
#EQU x_6,		1 
#EQU x_5,		2 
#EQU x_4,		3 
#EQU x_3,		4 
#EQU x_2,		5 
#EQU x_1,		6 
#EQU x_0,		7
 
#EQU y_7,		8 
#EQU y_6,		9 
#EQU y_5,		10 
#EQU y_4,		11 
#EQU y_3,		12 
#EQU y_2,		13 
#EQU y_1,		14 
#EQU y_0,		15 

#EQU r_7,		16
#EQU r_6,		17
#EQU r_5,		18 
#EQU r_4,		19 
#EQU r_3,		20 
#EQU r_2,		21 
#EQU r_1,		22 
#EQU r_0,		23 

#EQU x_sign,		24		; positive = 0x00, negative = 0x80
#EQU x_ex7,		25
#EQU x_ex6,		26
#EQU x_m6,		27
#EQU x_m5,		28
#EQU x_m4,		29
#EQU x_m3,		30
#EQU x_m2,		31
#EQU x_m1,		32
#EQU x_m0,		33
#EQU x_grs,		34		; 8-bit: grs0_0000

#EQU y_sign,		35		; positive = 0x00, negative = 0x80
#EQU y_ex7,		36
#EQU y_ex6,		37
#EQU y_m6,		38
#EQU y_m5,		39
#EQU y_m4,		40
#EQU y_m3,		41
#EQU y_m2,		42
#EQU y_m1,		43
#EQU y_m0,		44
#EQU y_grs,		45		; 8-bit: grs0_0000

#EQU r_sign,		46		; positive = 0x00, negative = 0x80
#EQU r_ex7,		47
#EQU r_ex6,		48
#EQU r_m6,		49
#EQU r_m5,		50
#EQU r_m4,		51
#EQU r_m3,		52
#EQU r_m2,		53
#EQU r_m1,		55
#EQU r_m0,		56
#EQU r_grs,		57		; 8-bit: grs0_0000

 ;----------------------------------------------------------------
 ; If a bit is 0 = no, 1 = yes
 ;
 ; Bit 7	  6	5	4	3	2	1	0
 ;     |	  |	|	|	            |
 ;     |	  |	|	|	            [ Normal 
 ;     |	  |	|	[ NaN       
 ;     |	  |	[ Infinite
 ;     |	  [ Zero
 ;     [ Subnormal
 ;
 ;	
 ;	An operand can have one of the following statuses:
 ;	1) 	Normal
 ;	2)	Subnormal
 ;	3) 	Zero	+/-
 ;	4)  Infinit +/-
 ;	5) 	NaN
 ;---------------------------------------------------------------
#EQU op1_status, 58
#EQU op2_status, 59


#EQU underflow,	60				; underflow not applied = 0x00, underflow applied = 0x01

;----------------------------------------------------------------
	 ; Bit 7	  6	 5	4	3	2	1	0
	 ;     |	  |	 |	|	|
	 ;     |	  |	 |	|	[Inexact
	 ;     |	  |	 |	[Underflow
	 ;     |	  |	 [Overflow
	 ;     |	  [Division by zero  
	 ;     [Invalid Opration: Quite Not A Nuber (qNaN)
	 ;
	 ;	
	 ;---------------------------------------------------------------	 

#EQU IEEE_754_DP_signals,	61


; Multiplication of two 53-bits operand is 106-bits.
#EQU Umr_6,	64				; 0x40	only two bits on right is used : 0b----_--XX 
#EQU Umr_5,	65
#EQU Umr_4,	66
#EQU Umr_3,	67
#EQU Umr_2,	68
#EQU Umr_1,	69
#EQU Umr_0,	70
#EQU Lmr_6,	71
#EQU Lmr_5,	72
#EQU Lmr_4,	73
#EQU Lmr_3,	74
#EQU Lmr_2,	75
#EQU Lmr_1,	76
#EQU Lmr_0,	77				; 0x4D
#EQU mr_save_carry,	78		; 0x4E			0x00 = no carry, 0x01 = carry


#EQU Umx_shifted_6,	80		; 0x50
#EQU Umx_shifted_5,	81
#EQU Umx_shifted_4,	82
#EQU Umx_shifted_3,	83
#EQU Umx_shifted_2,	84
#EQU Umx_shifted_1,	85
#EQU Umx_shifted_0,	86
#EQU Lmx_shifted_6,	87
#EQU Lmx_shifted_5,	88
#EQU Lmx_shifted_4,	89
#EQU Lmx_shifted_3,	90
#EQU Lmx_shifted_2,	91
#EQU Lmx_shifted_1,	92
#EQU Lmx_shifted_0,	93		; 0x5D

start: 
	; We assume that two 8-bytes operands are present in SPM	 Location: 
	;	Op1: 	SPM[0 to 7]
	;	Op2: 	SPM[8 to 15]	
	CALL	fill_SPM

	;CALL 	arith_div_x_y	
	;CALL 	arith_mul_x_y	
    CALL 	arith_add_x_y

hanging_loop:
			JUMP hanging_loop



	;---------------------------------------`---------------------------------------------
	; Procedure:			fill_SPM()
	;
	; Registers Used:	Bank0 : s5
	;					Bank1 : None		
	;		
	; Arguments:			Bank0 : None
	;					Bank1 : None
	;
	; Calls:				None
	;
	; RETs:				None
	; 
	; RET Flags:			None
	;
	; Description:		Loads two sample operands into SPM for performing arithmatic 
	;					operations on them in test environment.
	;------------------------------------------------------------------------------------
fill_SPM:
	; Fill SPM with first oeprand
	LOAD	s5, OP1_0	
	WRMEM	s5, x_0
	LOAD	s5, OP1_1	
	WRMEM	s5, x_1
	LOAD	s5, OP1_2	
	WRMEM	s5, x_2
	LOAD	s5, OP1_3	
	WRMEM	s5, x_3
	LOAD	s5, OP1_4	
	WRMEM	s5, x_4
	LOAD	s5, OP1_5	
	WRMEM	s5, x_5
	LOAD	s5, OP1_6	
	WRMEM	s5, x_6
	LOAD	s5, OP1_7	
	WRMEM	s5, x_7
	; Fill SPM with second oeprand
	LOAD	s5, OP2_0	
	WRMEM	s5, y_0
	LOAD	s5, OP2_1	
	WRMEM	s5, y_1
	LOAD	s5, OP2_2	
	WRMEM	s5, y_2
	LOAD	s5, OP2_3	
	WRMEM	s5, y_3
	LOAD	s5, OP2_4	
	WRMEM	s5, y_4
	LOAD	s5, OP2_5	
	WRMEM	s5, y_5
	LOAD	s5, OP2_6	
	WRMEM	s5, y_6
	LOAD	s5, OP2_7	
	WRMEM	s5, y_7
	RET
	
fill_SPM_swaped:
	; Fill SPM with second oeprand
	LOAD	s5, OP2_0	
	WRMEM	s5, x_0
	LOAD	s5, OP2_1	
	WRMEM	s5, x_1
	LOAD	s5, OP2_2	
	WRMEM	s5, x_2
	LOAD	s5, OP2_3	
	WRMEM	s5, x_3
	LOAD	s5, OP2_4	
	WRMEM	s5, x_4
	LOAD	s5, OP2_5	
	WRMEM	s5, x_5
	LOAD	s5, OP2_6	
	WRMEM	s5, x_6
	LOAD	s5, OP2_7	
	WRMEM	s5, x_7
	; Fill SPM with first oeprand
	LOAD	s5, OP1_0	
	WRMEM	s5, y_0
	LOAD	s5, OP1_1	
	WRMEM	s5, y_1
	LOAD	s5, OP1_2	
	WRMEM	s5, y_2
	LOAD	s5, OP1_3	
	WRMEM	s5, y_3
	LOAD	s5, OP1_4	
	WRMEM	s5, y_4
	LOAD	s5, OP1_5	
	WRMEM	s5, y_5
	LOAD	s5, OP1_6	
	WRMEM	s5, y_6
	LOAD	s5, OP1_7	
	WRMEM	s5, y_7
	RET

	;-----------------------------------------------------------------------------------
	; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
	;
	;	beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
	;

	;------------------------------------------------------------------------------------
	; Procedure:			arith_add_x_y()
	;
	; Registers Used:	Bank0 : All
	;					Bank1 : None		
	;		
	; Arguments:			Bank0 : 
	;					Bank1 : None
	;					SPM   : x = [x_7, x_6, ..., x_0]
	;			      			y = [y_7, y_6, ..., y_0]						
	;
	; Calls:				RORC
	;					load_mx
	;					load_my
	;					swap_operands
	;					count_nlz
	;					round
	;
	; RETs:				None
	; 
	; RET Flags:			None
	;
	; Description:		Adds two 64-bit double-precision floating point numbers.
	;  	This procedure always add. For subtraction set the sign of second  operand 
	;	to negative due to the fact that x + (-y) = x - y.          
	;------------------------------------------------------------------------------------
	
arith_add_x_y:
	CALL 	set_ops_status
	CALL 	decompose_x
	CALL 	decompose_y

	RDMEM 	s1, op1_status	; read the ops status
	RDMEM 	s2, op2_status	; read the ops status

	; We check op1 for 
	; 1) NaN
	;		Yes:	Check op2, if NaN then return Y_NaN else return X_NaN	
	;		No:		Go to step 2.
	; 2) Infinity
	;		Yes:	Check op2, if Inf then return_NaN_Inf
	;		No:		Go to step 3.
	; 3) Zero
	;		Yes:	check if op2 is NaN then return_NaN_Inf else return y
	;		No:		swap_step
	
	; Check if op1 is NaN
	TEST	s1, 0x10
	JUMP	Z, final_op1_not_NaN		; No

final_op1_NaN:						; Yes
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP 	NZ, return_NAN			; Yes
	JUMP	return_x_NAN
	
return_NAN:
	; check op1 NaN bit
	RDMEM	s3, x_m6
	TEST	s3, 0x08
	JUMP	Z, return_x_NAN
	; op1 NaN bit is 1, so check op2 NaN bit
	RDMEM	s3, y_m6
	TEST	s3, 0x08
	JUMP	Z, return_y_NAN
	JUMP	return_x_NAN

final_op1_not_NaN:
	;	+inf + + inf = +inf
	;	+inf + - inf = +NaN
	;	-inf + + inf = +NaN
	;	-inf + - inf = -inf
	; infinity sign is the AND of both operands' sign bits.
	; Result NaN bit is XOR of both operands' sign bits.

	; Check if op1 is Inf
	TEST	s1, 0x20
	JUMP	Z, final_op1_not_Inf		; No

final_op1_Inf:						; Yes
	; Check if op2 is Inf	
	TEST	s2, 0x20
	JUMP	NZ, return_y_NAN_Inf		; Yes
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN		; Yes
	JUMP	return_x
	
final_op1_not_Inf:	
		
	; Check if op1 is zero
	TEST	s1, 0x40
	JUMP	Z, check_final_op2		; No
	
final_op1_is_zero:
	; Check if op2 is zero
	TEST	s2, 0x40
	JUMP	NZ, return_zero		; Yes

	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN		;Yes
	JUMP	return_y
	
	; Op1 is not NaN, Inf, and zero, so we conclude op1 is (sub)normal.	

	; We check op2 for 
	; 1) NaN
	;		Yes:	return_NaN_Inf
	;		No:		Go to step 2.
		; 2) Infinity
	;		Yes:	return_NaN_Inf
	;		No:		return x
	; 3) Zero
	;		Yes:	return zero
	;		No:		swap_step

check_final_op2:	
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN		;Yes

final_op2_not_NaN:					; NoSL0 	s8
	ROLC	s9
	ROLC	s8
	ROLC	s9
	ROLC	s8
	ROLC	s9
	ROLC	s8
	ROLC	s9
			
	;	+inf + + inf = +inf
	;	+inf + - inf = +NaN
	;	-inf + + inf = +NaN
	;	-inf + - inf = -inf
	; infinity sign is the AND of both operands' sign bits.
	; Result NaN bit is XOR of both operands' sign bits.

	; Check if op2 is Inf
	TEST	s2, 0x20
	JUMP	NZ, return_y		; Yes

final_op2_not_Inf:					; No
	; Check if op2 is zero
	TEST	s2, 0x40
	JUMP	NZ, return_x				; Yes
	
	; Both operators are (sub)normal. Perform the addition.
	; op1 = subnormal	op2 = subnormal		- Normal procedure works
	;	ex = 0				ey = 0  
	; op1 = subnormal	op2 = normal			- hidden 0 must be injected.
	;	ex = 0				ey != 0			subnormal
	; op1 = normal		op2 = subnormal		- hidden 0 must be injected.
	;	ex != 0				ey = 0
	; op1 = normal		op2 = normal	  		- Normal procedure works
	JUMP 	COMP_swap_ex

return_zero:
	LOAD	sF, 0xFF
;	+0 +0	=> +0 	
;	-0 +0	=> +0 	
;	+0 -0	=> +0 	
;	-0 -0	=> -0 	
	RDMEM	s1, x_sign
	RDMEM	s2, y_sign
	AND		s1, s2			; Calculate the sign of zero
	AND		s1, 0x80			; zero all other bits except sign
	LOAD	s0, 0x00
	WRMEM 	s0, r_6
	WRMEM 	s0, r_5
	WRMEM 	s0, r_4
	WRMEM 	s0, r_3
	WRMEM 	s0, r_2
	WRMEM 	s0, r_1
	WRMEM 	s0, r_0
	WRMEM 	s1, r_7
	RET

return_x:
	LOAD	sF, 0xFF
	RDMEM	s7, x_7	       
	RDMEM	s6, x_6	       
	RDMEM	s5, x_5	       
	RDMEM	s4, x_4	       
	RDMEM	s3, x_3	       
	RDMEM	s2, x_2	       
	RDMEM	s1, x_1	       
	RDMEM	s0, x_0	      
	WRMEM 	s7, r_7
	WRMEM 	s6, r_6
	WRMEM 	s5, r_5
	WRMEM 	s4, r_4
	WRMEM 	s3, r_3
	WRMEM 	s2, r_2
	WRMEM 	s1, r_1
	WRMEM 	s0, r_0
	RET

return_x_NAN:
	LOAD	sF, 0xFF
	RDMEM	s7, x_7	       
	RDMEM	s6, x_6	   
	OR		s6, 0x08    	; ensure the result is NaN
	RDMEM	s5, x_5	       
	RDMEM	s4, x_4	       
	RDMEM	s3, x_3	       
	RDMEM	s2, x_2	       
	RDMEM	s1, x_1	       
	RDMEM	s0, x_0	      
	WRMEM 	s7, r_7
	WRMEM 	s6, r_6
	WRMEM 	s5, r_5
	WRMEM 	s4, r_4
	WRMEM 	s3, r_3
	WRMEM 	s2, r_2
	WRMEM 	s1, r_1
	WRMEM 	s0, r_0
	RET
	
return_x_NAN_Inf:
	LOAD	sF, 0xFF
	; Read operand signs
	RDMEM	s9, x_7
	RDMEM	s8, y_7
	AND		s9, 0x80	  	; op1 sign bit
	AND		s8, 0x80		; op2 sign bit
	;	+inf + + inf = +inf
	;	+inf + - inf = +NaN
	;	-inf + + inf = +NaN
	;	-inf + - inf = -inf
	; infinity sign is the AND of both operands' sign bits.
	; Result NaN bit is XOR of both operands' sign bits.
	LOAD	sA, s9		; copy s9 into sA
	AND		sA, s8	

	XOR		s9, s8
	TEST 	s9, 0x80
	JUMP	Z, NaN_bit_off
	
	LOAD 	s8, 0x08	
	JUMP	done_applying_NaN_bit
	
NaN_bit_off:
	LOAD	s8, 0x00	
	
done_applying_NaN_bit:
	RDMEM	s7, x_7	       
	OR		s7, sA		; Apply infinity sign
	RDMEM	s6, x_6	       
	OR		s6, s8		; Apply Result NaN bit
	RDMEM	s5, x_5	       
	RDMEM	s4, x_4	       
	RDMEM	s3, x_3	       
	RDMEM	s2, x_2	       
	RDMEM	s1, x_1	       
	RDMEM	s0, x_0	      
	WRMEM 	s7, r_7
	WRMEM 	s6, r_6
	WRMEM 	s5, r_5
	WRMEM 	s4, r_4
	WRMEM 	s3, r_3
	WRMEM 	s2, r_2
	WRMEM 	s1, r_1
	WRMEM 	s0, r_0
	RET

return_y:
	LOAD	sF, 0xFF
	RDMEM	s7, y_7	       
	RDMEM	s6, y_6	       
	RDMEM	s5, y_5	       
	RDMEM	s4, y_4	       
	RDMEM	s3, y_3	       
	RDMEM	s2, y_2	       
	RDMEM	s1, y_1	       
	RDMEM	s0, y_0	      
	WRMEM 	s7, r_7
	WRMEM 	s6, r_6
	WRMEM 	s5, r_5
	WRMEM 	s4, r_4
	WRMEM 	s3, r_3
	WRMEM 	s2, r_2
	WRMEM 	s1, r_1
	WRMEM 	s0, r_0
	RET

return_y_NAN:
	LOAD	sF, 0xFF
	RDMEM	s7, y_7	       
	RDMEM	s6, y_6	       
	OR		s6, 0x08		; ensure the result is NaN
	RDMEM	s5, y_5	       
	RDMEM	s4, y_4	       
	RDMEM	s3, y_3	       
	RDMEM	s2, y_2	       
	RDMEM	s1, y_1	       
	RDMEM	s0, y_0	      
	WRMEM 	s7, r_7
	WRMEM 	s6, r_6
	WRMEM 	s5, r_5
	WRMEM 	s4, r_4
	WRMEM 	s3, r_3
	WRMEM 	s2, r_2
	WRMEM 	s1, r_1
	WRMEM 	s0, r_0
	RET

return_y_NAN_Inf:
	LOAD	sF, 0xFF
	; Read operand signs
	RDMEM	s9, x_7
	RDMEM	s8, y_7
	AND		s9, 0x80	  	; op1 sign bit
	AND		s8, 0x80		; op2 sign bit
	;	+inf + + inf = +inf
	;	+inf + - inf = +NaN
	;	-inf + + inf = +NaN
	;	-inf + - inf = -inf
	; infinity sign is the AND of both operands' sign bits.
	; Result NaN bit is XOR of both operands' sign bits.
	LOAD	sA, s9		; copy s9 into sA
	AND		sA, s8	
	XOR		s9, s8
	RDMEM	s7, y_7	
	; Apply the sign
	TEST	sA, 0x80
	JUMP	NZ, set_sign_bit_to_1	
set_sign_bit_to_0:
	AND		s7, 0x7F	
	JUMP 	set_sign_bit_done	
set_sign_bit_to_1:	
	OR		s7,	0x80
set_sign_bit_done:
	RDMEM	s6, y_6	   
	; Apply the sign
	TEST	s9, 0x80
	JUMP	NZ, set_NaN_bit_to_1	
set_NaN_bit_to_0:
	AND		s6, 0xF7
	JUMP 	set_NaN_bit_done	
set_NaN_bit_to_1:	
	OR		s6,	0x08
set_NaN_bit_done:
	RDMEM	s5, y_5	       
	RDMEM	s4, y_4	       
	RDMEM	s3, y_3	       
	RDMEM	s2, y_2	       
	RDMEM	s1, y_1	       
	RDMEM	s0, y_0	      
	WRMEM 	s7, r_7
	WRMEM 	s6, r_6
	WRMEM 	s5, r_5
	WRMEM 	s4, r_4
	WRMEM 	s3, r_3
	WRMEM 	s2, r_2
	WRMEM 	s1, r_1
	WRMEM 	s0, r_0
	RET
;--------------------------------------------------------------------------
COMP_swap_ex:
	; Read ex : [s1, s0]
	RDMEM s1, x_ex7	       
	RDMEM s0, x_ex6
	; Read ey: [s3, s2]
	RDMEM s3, y_ex7
	RDMEM s2, y_ex6
	; COMP ex [s1, s0] VS ey [s3, s2]
	COMP  	s0, s2
	COMPC 	s1, s3		
	JUMP  	C, ex_less_than_ey					
ex_greater_equal_than_ey:
	JUMP	NZ, swap_done
ex_equal_ey:
	;when both exponents are equal then we compare the significand
	REGBANK B
	CALL 	load_mx
	CALL 	load_my
	COMP	s1, s9
	COMPC	s2, sA
	COMPC	s3, sB
	COMPC	s4, sC
	COMPC	s5, sD
	COMPC	s6, sE
	COMPC	s7, sF
	REGBANK A
	JUMP  	NC, swap_done					
ex_less_than_ey:
	CALL swap_operands
swap_done:		
	; Reread ex : [s1, s0]
	RDMEM s1, x_ex7	       
	RDMEM s0, x_ex6
	; Reread ey: [s3, s2]
	RDMEM s3, y_ex7
	RDMEM s2, y_ex6
	; Save the sign of the bigger number into result.
	RDMEM 	sF, x_sign
	WRMEM	sF, r_sign	
;-------------------------------------------- --------------------------
;     Exponent Alignment		
;-----------------------------------------------------------------------
	; We set "er" as "ex" 
	WRMEM s1, r_ex7				; Write the exponent of result in SPM
	WRMEM s0, r_ex6		
  	; ex = Ex - bias + 1 - nx
	; ey = Ey - bias + 1 - ny
	; ex - nx - ey + ny  
	;  where nx and ny are normal bits. means if op is normal nx = 1
	;  otheriwse nx = 0.
	; Is op1 normal? 
	RDMEM 	s4, op1_status
	TEST	s4,  0x01
	JUMP	NZ,  op1_is_normal_nx_is_1
	ADD  	s0, 0x01     	  			; nx = 0
	ADDC 	s1, 0x00
op1_is_normal_nx_is_1:	
; Is op2 normal? 
	RDMEM 	s4, op2_status
	TEST	s4, 0x01
	JUMP	NZ, op2_is_normal_ny_is_1
	ADD  	s2, 0x01     	  			; ny = 0
	ADDC 	s3, 0x00
op2_is_normal_ny_is_1:

	SUB  	s0, s2     	      	;ex - ey
	SUBC 	s1, s3
	; ex = ey so (ex - ey) will set zero flag
	;  thus we don't need to shift mantisa right  			       
	JUMP Z, my_mantisa_shift_right_done	
	; Check if [s1, s0] is more than 56, if yes then reduce it to 56 as
	;	shofting to right more than 56 times sets the whole mantisa 
	;	to zero completely
	COMP 	s0, 0x38	
	COMPC	s1, 0x00	
	JUMP	C, not_a_big_shift				; s0 is less than 56
	LOAD	s0, 0x38
	LOAD	s1, 0x00
not_a_big_shift:	
	; Shift "my" to right by (ex - ey) in [s1, s0]:	
	CALL 	load_my
	SR0	   	sF        							
	RORC   	sE			
	RORC   	sD
	RORC   	sC
	RORC   	sB
	RORC   	sA
	RORC   	s9
	RORC   	s8				; extra bits: gaurd-round-sticky-xxxxx
	SUB    	s0, 0x01      ; subtract by 1 to take into account the manual
	SUBC   	s1, 0x00		; first round shift:  ex - ey - 1
	JUMP   	Z, my_mantisa_shift_right_loop_done
my_mantisa_shift_right_loop:              
	SR0	   	sF			; 52 bit "my" mantisa right shift by 1-bit
	RORC   	sE			;  loop for (ex - ey - 1) times
	RORC   	sD
	RORC   	sC
	RORC   	sB
	RORC   	sA
	RORC   	s9
	RORC   	s8			; extra bits: gaurd-round-sticky-xxxxx
	; if sticky bit of s8 ever becomes 1 set sticky bit of op2 to 1
	TEST   s8, 0x20
	JUMP   Z, dont_set_sticky_bit_y			
	LOAD   s2, 0x20
	WRMEM  s2, y_grs 				       
dont_set_sticky_bit_y:
	SUB   s0, 0x01
	SUBC  s1, 0x00
	JUMP  NZ, my_mantisa_shift_right_loop
my_mantisa_shift_right_loop_done:
	; Save "my" back to SMP
	WRMEM 	sF, y_m6								
	WRMEM 	sE, y_m5								
	WRMEM 	sD, y_m4								
	WRMEM 	sC, y_m3								
	WRMEM 	sB, y_m2								
	WRMEM 	sA, y_m1								
	WRMEM 	s9, y_m0
	
	RDMEM 	s2, y_grs			; Update the gr bits for y
	OR		s8, s2				; Apply sticky bit
	AND		s8, 0xE0				; Zero all bits except grs
	WRMEM 	s8, y_grs
my_mantisa_shift_right_done:
;---------------------------------------------------------------------------
; Convert to two's complement
;---------------------------------------------------------------------------
	RDMEM s0, x_sign				; Read sign bit of x	
	TEST  s0, 0x80				; Test the x sign bit
	JUMP  Z, sx_is_positive
	; x is negative
	RDMEM s0, y_sign				; Read sign bit of y	
	TEST  s0, 0x80				
	JUMP  Z, sx_is_neg_sy_is_pos
	; x is negative , y is negative
	; Set the result sign as negative
	LOAD 	s0, 0x80
	WRMEM	s0, r_sign 	
	CALL 	twos_mx
	CALL 	twos_my
	JUMP 	perform_addition
sx_is_neg_sy_is_pos:	
	; Set the result sign as negative
	LOAD 	s0, 0x80
	WRMEM	s0, r_sign 	
	CALL 	twos_mx
	CALL 	load_my
	JUMP perform_addition
sx_is_positive:
	RDMEM 	s0, y_7				; Read sign bit of y	
	TEST  	s0, 0x80				
	JUMP  	Z, sx_sy_is_positive
	; x is positive but y is negative
	; Set the result sign as positive
	LOAD 	s0, 0x00
	WRMEM	s0, r_sign 	
	CALL 	load_mx	
	CALL 	twos_my
	JUMP 	perform_addition
sx_sy_is_positive:
	; Set the result sign as positive
	LOAD 	s0, 0x00
	WRMEM	s0, r_sign 	
	CALL load_mx
	CALL load_my
perform_addition:
	; Add mx and my
	ADD		s0, s8
	ADDC	s1, s9
	ADDC	s2, sA
	ADDC	s3, sB
	ADDC	s4, sC
	ADDC	s5, sD
	ADDC	s6, sE
	ADDC	s7, sF

	
	
	; Is negative ?
	TEST	s7, 0x40
	JUMP	Z, dont_apply_twos
	XOR 	s0, 0xE0		; toggle all bits and then add 1
	XOR 	s1, 0xFF		
	XOR 	s2, 0xFF		
	XOR 	s3, 0xFF		
	XOR 	s4, 0xFF		
	XOR 	s5, 0xFF		
	XOR 	s6, 0xFF		
	XOR 	s7, 0x7F
	ADD  	s0, 0x20		; Add 1 to the sticky bit		   
	ADDC 	s1, 0x00		
	ADDC 	s2, 0x00		   
	ADDC 	s3, 0x00		   
	ADDC 	s4, 0x00		   
	ADDC 	s5, 0x00		   
	ADDC 	s6, 0x00		   
	ADDC 	s7, 0x00
	LOAD	s8, 0x80
	WRMEM	s8, r_sign
	JUMP	sign_calc_done
dont_apply_twos:
	LOAD	s8, 0x00
	WRMEM	s8, r_sign
sign_calc_done:	
;	TEST	s7, 0x10
;	JUMP	Z, carry_not_found_dont_shift_right_by_one		
	; carry found
;	SR0		s7				; shift left by 1
;	RORC	s6
;	RORC	s5
;	RORC	s4
;	RORC	s3
;	RORC	s2
;	RORC	s1
;	RORC	s0
;	RDMEM	s8, r_ex6				; Yes: Increment exponent by 1
;	RDMEM	s9, r_ex7
;	ADD		s8, 0x01
;	ADDC	s9, 0x00
;	WRMEM	s8, r_ex6
;	WRMEM	s9, r_ex7
;	JUMP	no_carry
;carry_not_found_dont_shift_right_by_one:
	; There is carry so apply 2'scomplement
	
	; Check both operands are normal
	;RDMEM 	sF, op1_status
	;RDMEM 	sE, op2_status
	;AND		sF, sE
	;TEST	sF, 0x01
	;JUMP	NZ, both_ops_normals
	
	
	;JUMP	no_carry
	
;both_ops_normals:		; here 0x20 in s7 means overflow
;	SR0		s7				; shift left by 1
;	RORC	s6
;	RORC	s5
;	RORC	s4
;	RORC	s3
;	RORC	s2
;	RORC	s1
;	RORC	s0
;	RDMEM	s8, r_ex6				; Yes: Increment exponent by 1
;	RDMEM	s9, r_ex7
;	ADD		s8, 0x01
;	ADDC	s9, 0x00
;	WRMEM	s8, r_ex6
;	WRMEM	s9, r_ex7
		
;no_carry:	
	;TEST	s7, 0x40
	;JUMP	Z, overflow_not_found
	; overflow found
	
	
;overflow_not_found:

	; Check both operands are subnormals 
;	RDMEM 	sF, op1_status
;	RDMEM 	sE, op2_status
;	AND		sF, sE
;	TEST	sF, 0x80
;	JUMP	NZ, both_ops_subnormals
	; Both ops not subnormal therefore normalize
	CALL 	normalize			; normalize
	CALL 	round				

CALL 	normalize			; normalize
CALL 	round				
CALL 	normalize			; normalize

;both_ops_subnormals:	
;	CALL 	round				
	; Compose the result: 
	; 	r exponent 	= [s9, s8], 
	;	r mantisa 	= [s7, s6, ..., s1]
	;	r sign    	= r_sign
;	JUMP 	normalizaion_done
;dont_normalize_as_both_are_subnormals:	
;	TEST	s7, 0x10	; Subnormals addition produced carry?
;	JUMP	Z, normalizaion_done		; No

;normalizaion_done:	
	; Compose
	RDMEM	s8, r_ex6
	RDMEM	s9, r_ex7
	SL0		s8
	ROLC	s9
	ROLC	s8
	ROLC	s9
	ROLC	s8
	ROLC	s9
	ROLC	s8
	ROLC	s9
	AND		s7, 0x0F
	OR		s7, s8
	; Apply the result sign
	RDMEM	sA, r_sign
	OR		s9, sA		
		
	; Save the result in SMP
	WRMEM 	s1, r_0
	WRMEM 	s2, r_1
	WRMEM 	s3, r_2
	WRMEM 	s4, r_3
	WRMEM 	s5, r_4
	WRMEM 	s6, r_5
	WRMEM 	s7, r_6 
	WRMEM 	s9, r_7		
	RET			

;------------------------------------------------------------------------------------
; Procedure:		load_mx()
; Registers Used:	
; 	    		Bank0 : s7, s6, ... , s0
;				Bank1 : None		
;				SPM   : op1_status
;		
; Arguments:		
; 				Bank0 : None
;				Bank1 : None
;
; Calls:			None
;
; RETs:			None
; 
; RET Flags:		None
;
; Description:	Load x oeprand mantisa to register s7 down to s0. 
;				- Hidden bit aleardy has been set in x_m6.
;				- gsr bits apears in s0.
;------------------------------------------------------------------------------------
load_mx: 
	; Load mx into registers
	RDMEM s7, x_m6
	RDMEM s6, x_m5
	RDMEM s5, x_m4
	RDMEM s4, x_m3
	RDMEM s3, x_m2
	RDMEM s2, x_m1
	RDMEM s1, x_m0
	RDMEM s0, x_grs
    RET	 
    
;------------------------------------------------------------------------------------
; Procedure:		load_my()
; Registers Used:	
; 	    		Bank0 : sF, sE, ... , s8
;				Bank1 : None		
;				SPM   : op1_status
;		
; Arguments:		
; 				Bank0 : None
;				Bank1 : None
;result_is_positive
; Calls:			None
;
; RETs:			None
; 
; RET Flags:		None
;
; Description:	Load y oeprand mantisa to register sF down to s8.
;				- Hidden bit aleardy has been set in y_m6.
;				- gsr bits apears in s0.
;------------------------------------------------------------------------------------
load_my: 
	; Load mx into registers
	RDMEM sF, y_m6
	RDMEM sE, y_m5
	RDMEM sD, y_m4
	RDMEM sC, y_m3
	RDMEM sB, y_m2
	RDMEM sA, y_m1
	RDMEM s9, y_m0
	RDMEM s8, y_grs
    RET	     

;------------------------------------------------------------------------------------
	; Procedure:			swap_operands()
	;
	; Registers Used:	Bank0 : None
	;					Bank1 : All		
	;		
	; Arguments:			Bank0 : None
	;					Bank1 : None
	;
	; Calls:				None
	;
	; RETs:				None
	; 
	; RET Flags:			None
	;
	; Description:		Loads two sample operands into SPM for performing arithmatic 
	;					operations on them in test environment.
	;------------------------------------------------------------------------------------	
swap_operands:
	REGBANK	B
	RDMEM 	s7, x_7 	
	RDMEM 	s6, x_6 	
	RDMEM 	s5, x_5 	
	RDMEM 	s4, x_4 	
	RDMEM 	s3, x_3 	
	RDMEM 	s2, x_2 	
	RDMEM 	s1, x_1 	
	RDMEM 	s0, x_0
	RDMEM 	s8, x_grs 	
	
	RDMEM 	sF, y_7 	
	RDMEM 	sE, y_6 	
	RDMEM 	sD, y_5 	
	RDMEM 	sC, y_4 	
	RDMEM 	sB, y_3 	
	RDMEM 	sA, y_2 	
	RDMEM 	s9, y_1 	
	
	WRMEM	s7, y_7	
	WRMEM	s6, y_6	
	WRMEM	s5, y_5	
	WRMEM	s4, y_4	
	WRMEM	s3, y_3	
	WRMEM	s2, y_2	
	WRMEM	s1, y_1	

	RDMEM 	s7, y_0
	RDMEM 	s6, y_grs 	

	WRMEM	s0, y_0	
	WRMEM	s8, y_grs
	
	WRMEM	sF, x_7	
	WRMEM	sE, x_6	
	WRMEM	sD, x_5	
	WRMEM	sC, x_4	
	WRMEM	sB, x_3	
	WRMEM	sA, x_2	
	WRMEM	s9, x_1	
	WRMEM	s7, x_0	
	WRMEM	s6, x_grs
	
	; Swap the operands' status		
	RDMEM 	s5, op1_status	       
	RDMEM 	s6, op2_status	       
	WRMEM	s5, op2_status
	WRMEM	s6, op1_status
	
	CALL	decompose_x
	CALL	decompose_y
	
	REGBANK A
	RET
;------------------------------------------------------------------------------------
; Procedure:		count_nlz()
; Registers Used:	
; 	    		Bank0 : s8, s9
;				Bank1 : None		
;		
; Arguments:		
; 				Bank0 : s8
;				Bank1 : None
;
; Calls:			None
;
; RETs:			s9: number of leading zeros
; 
; RET Flags:		None
;
; Description:	Counts the number of leading zeros in a byte given in s8.
;------------------------------------------------------------------------------------
count_nlz:
	LOAD s9, 0x00			
count_mlz_loop:
	SL1  s8
       	JUMP C, counting_z_done
       	ADD  s9, 0x01			; Increament z by 1
       	JUMP count_mlz_loop
counting_z_done:
	RET


;------------------------------------------------------------------------------------
; Procedure:		round()
;
; Registers Used:	Bank0 : s8 
;					Bank1 : None		
;		
; Arguments:			Bank0 : [s1,s0]
;					Bank1 : None
;
; Calls:				None
;
; RETs:				None
; 
; RET Flags:			None
;
; Description:		This procedure receives guard-sticky-round bits in s0 register
; 			and RETs 0 or 1 in s0 based on rounding algorith. s1 hold the
;			Least signifficant byte.
;			
;			
;	Check the guard bit
; 	If Gaurd bit = 0 : Round down (Do nothing - simple truncation)
; 	If Gaurd bit = 1, Check the Round bit
;	If Gaurd bit = 1, and Round bit = 1 : Round Up (add 1 to mantissa)
;	If Gaurd bit = 1, and Round bit = 0 : Check the Sticky bit
;	If Gaurd bit = 1, and Round bit = 0 , and Sticky bit = 1 : Round Up (add 1 to mantissa)
;	If Gaurd bit = 1, and Round bit = 0 , and Sticky bit = 0 : Round to nearest even. 
;	   Means round up if bitbefore Guard bit is 1, else round down.
;------------------------------------------------------------------------------------
round: 
	; -------------------------------------------------
	; Rounding:
	; Check the guard bit - s0[7]
	TEST 	s0, 0x80
	JUMP 	NZ, guard_bit_is_1
	; Gaurd bit = 0 : Round down (Do  nothing)
	JUMP 	round_RET_zero
guard_bit_is_1:
	; Gaurd bit = 1, Check the round bit
	TEST 	s0, 0x40 
	JUMP 	Z, round_bit_is_0	
	; Gaurd bit = 1, Round bit = 1 : Round Up (add 1 to mantissa)
	JUMP 	round_RET_one
round_bit_is_0:
	; Gaurd bit = 1, Round bit = 0 : Check the Sticky bit
	TEST 	s0, 0x20
	JUMP 	NZ, round_RET_one ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 1 : Round Up (add 1 to mantissa)
	; Gaurd bit = 1, Round bit = 0 , Sticky bit = 0 : Round to nearest even,
	;       Means round up if bit before Guard bit is 1, else round down.
	TEST 	s1, 0x01
	JUMP 	Z, round_RET_zero
round_RET_one:
	; To prevent double round up we  will zero the grs bits
	LOAD 	s0, 0x00			; s0 holing the grs bits of the result
    LOAD 	s8, 0x01	
	JUMP 	apply_rounding
round_RET_zero:
	; To prevent double round up we  will zero the grs bits
	LOAD 	s0, 0x00			; s0 holing the grs bits of the result
	LOAD 	s8, 0x00	
apply_rounding:
 	; Apply rounding
	ADD		s1, s8		
	ADDC	s2, 0x00
	ADDC	s3, 0x00
	ADDC	s4, 0x00
	ADDC	s5, 0x00
	ADDC	s6, 0x00
	ADDC	s7, 0x00       	      
    RET
;------------------------------------------------------------------------------------
; Procedure:			normalize()
;
; Registers Used:	Bank0 : 
;					Bank1 : None		
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;
; Calls:				None
;
; RETs:				None
; 
; RET Flags:			None
;
; Description:		Normalizes a given number
;------------------------------------------------------------------------------------	


;------------------------------------------------------------------------------------
; Procedure:			decompose_x()
;
; Registers Used:	Bank0 : s7, s6, ..., s0
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;					SPM   : x_7, x_6, ..., x_0
;
; Calls:				None
;
; RETs:				None
; 
; RET Flags:			None
;
; Description:		Extracts sign, exonent, and mantisa from given 64-bit number
;------------------------------------------------------------------------------------	
decompose_x:
	RDMEM	s7, x_7
	TEST	s7, 0x80
	JUMP	NZ, negative_sign_x
	LOAD	s0, 0x00		; positive = 0x00 
	JUMP	test_x_sign_done
negative_sign_x:
	LOAD	s0, 0x80		; positive = 0x80 
test_x_sign_done:
	WRMEM	s0, x_sign	; set the sign
	RDMEM	s6, x_6
	AND		s7, 0x7F		; Zero the sign bit
	; Shift right by 4 bits to remove the 4-bits of mantisa on the low 
	;	nibble of s6.
	SR0 	s7  		
	RORC 	s6        	
	SR0 	s7
	RORC 	s6
	SR0 	s7
	RORC 	s6
	SR0 	s7
	RORC 	s6
	; Save extracted exponent in SPM	
	WRMEM	s7, x_ex7	
	WRMEM	s6, x_ex6
	;Is x subnormal? yes: inject hidden 0, No: Inject hidden 1
	RDMEM 	s0, op1_status
	TEST	s0, 0x80
	JUMP	NZ, subnormal_involved_x
	; not a subnormal
	LOAD 	s0, 0x10
	JUMP	subnormal_test_done_x
subnormal_involved_x:
	LOAD 	s0, 0x00
subnormal_test_done_x:
	RDMEM	s6, x_6		; Recover bit no 6
	AND		s6, 0x0F		; Zero the high nibble
	OR		s6, s0
	WRMEM	s6, x_m6		; Save extracted mantisa in SPM
	RDMEM	s5, x_5
	RDMEM	s4, x_4
	RDMEM	s3, x_3
	RDMEM	s2, x_2
	RDMEM	s1, x_1
	RDMEM	s0, x_0
	WRMEM	s5, x_m5
	WRMEM	s4, x_m4
	WRMEM	s3, x_m3
	WRMEM	s2, x_m2
	WRMEM	s1, x_m1
	WRMEM	s0, x_m0
	RET
	
;------------------------------------------------------------------------------------
; Procedure:			decompose_y()
;
; Registers Used:	Bank0 : sF, sE, ..., s8
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;					SPM   : y_7, y_6, ..., y_0
;
; Calls:				None
;
; RETs:				None
; 
; RET Flags:			None
;
; Description:		Extracts sign, exonent, and mantisa from given 64-bit number
;------------------------------------------------------------------------------------	
decompose_y:
	RDMEM	s7, y_7
	TEST	s7, 0x80
	JUMP	NZ, negative_sign_y
positive_sign_y:
	LOAD	s0, 0x00		; positive = 0x00 
	JUMP	test_y_sign_done
negative_sign_y:
	LOAD	s0, 0x80		; positive = 0x80 
test_y_sign_done:
	WRMEM	s0, y_sign	; set the sign
	RDMEM	s6, y_6
	AND		s7, 0x7F		; Zero the sign bit
	; Shift right by 4 bits to remove the 4-bits of mantisa on the low 
	;	nibble of s6.
	SR0 	s7  		
	RORC 	s6        	
	SR0 	s7
	RORC 	s6
	SR0 	s7
	RORC 	s6
	SR0 	s7
	RORC 	s6
	; Save extracted exponent in SPM	
	WRMEM	s7, y_ex7	
	WRMEM	s6, y_ex6
	;Is x subnormal? yes: inject hidden 0, No: Inject hidden 1
	RDMEM 	s0, op2_status
	TEST	s0, 0x80
	JUMP	NZ, subnormal_involved_y
	; not a subnormal
	LOAD 	s0, 0x10
	JUMP	subnormal_test_done_y
subnormal_involved_y:
	LOAD 	s0, 0x00
subnormal_test_done_y:
	RDMEM	s6, y_6		; Recover bit no 6
	AND		s6, 0x0F		; Zero the high nibble
	OR		s6, s0
	WRMEM	s6, y_m6		; Save extracted mantisa in SPM
	RDMEM	s5, y_5
	RDMEM	s4, y_4
	RDMEM	s3, y_3
	RDMEM	s2, y_2
	RDMEM	s1, y_1
	RDMEM	s0, y_0
	WRMEM	s5, y_m5
	WRMEM	s4, y_m4
	WRMEM	s3, y_m3
	WRMEM	s2, y_m2
	WRMEM	s1, y_m1
	WRMEM	s0, y_m0
	RET	
	
;------------------------------------------------------------------------------------
; Procedure:			set_ops_status()
;
; Registers Used:	Bank0 : 
;					Bank1 : None		
;					SPM	  : x_7, x_6, y_7, y_6
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;
; Calls:				None
;					None
;
; RETs:				SPM: 
;						op1_status
;	 					op2_status
; 
; RET Flags:			None
;
; Description:		Set op1 and op2 status flags: Check for subnormals, zeros, 
;						NaNs and infinities.
;------------------------------------------------------------------------------------	
set_ops_status:
 	; Check if the op1 (ex) exponent bits subnormalare all zero      
 	; Extract ex : [s7, s6]
	RDMEM	s7, x_7	       
	RDMEM	s6, x_6
	AND		s7, 0x7F 		; zero the sign bit
	TEST 	s6, 0xF0
	TESTC 	s7, 0x7F 
	JUMP	NZ, ex_not_zero
ex_zero:	
	; Load x mantisa into registers	
	RDMEM s6, x_6
	RDMEM s5, x_5
	RDMEM s4, x_4
	RDMEM s3, x_3
	RDMEM s2, x_2
	RDMEM s1, x_1
	RDMEM s0, x_0
	TEST	s6, 0x0F
	TESTC	s5, 0xFF
	TESTC	s4, 0xFF
	TESTC	s3, 0xFF
	TESTC	s2, 0xFF
	TESTC	s1, 0xFF
	TESTC	s0, 0xFF
	JUMP	NZ, op1_is_subnormal
	SR0		s9					; Shift to right by 4
	RORC	s8
	SR0		s9
	RORC	s8
	SR0		s9
	RORC	s8
	SR0		s9
	RORC 	s8
op_1_is_zero:	
	; set op1 status flag to "Zero"   -- status bits = 0xSZIN 
	RDMEM	s0, op1_status	
	OR 		s0, 0x40		; op1 is zero
	WRMEM	s0, op1_status
	JUMP	set_op2_status
op1_is_subnormal:
	; set op1 status flag to "Subnormal"
	RDMEM	s0, op1_status	
	OR 		s0, 0x80		; op1 is subnormal
	WRMEM	s0, op1_status	
	JUMP	set_op2_status
ex_not_zero:
 	; Check if the op1 (ex) exponent bits are all one
 	; Extract ex : [s7, s6]
	RDMEM	s7, x_7	       
	RDMEM	s6, x_6
	AND		s7, 0x7F 		; zero the sign bit
	AND		s6, 0xF0			; zero the low nibble
	COMP 	s6, 0xF0	
	COMPC 	s7, 0x7F 
	JUMP	NZ, ex_not_all_one
ex_all_one:
	; Load x mantisa into registers	
	RDMEM s6, x_6
	RDMEM s5, x_5
	RDMEM s4, x_4
	RDMEM s3, x_3
	RDMEM s2, x_2
	RDMEM s1, x_1
	RDMEM s0, x_0
	; Check if all bits of significand are zero
	TEST	s6, 0x0F
	TESTC	s5, 0xFF
	TESTC	s4, 0xFF
	TESTC	s3, 0xFF
	TESTC	s2, 0xFF
	TESTC	s1, 0xFF
	TESTC	s0, 0xFF
	JUMP	Z, op1_is_inf
op1_is_NaN:	
	; set op1 status flag to "NaN" -- status bits = 0xSZIN --
	RDMEM	s0, op1_status	
	OR 		s0, 0x10		; op1 is NaN
	WRMEM	s0, op1_status	
	JUMP	set_op2_status
op1_is_inf:	
	; set op1 status flag to "Infinite" 
	RDMEM	s0, op1_status	
	OR 		s0, 0x20		; op1 is infinite
	WRMEM	s0, op1_status	
	JUMP	set_op2_status
ex_not_all_one:	
	; Here we conclude that ex is not all zeros and not all ones.
	;  therefore op1 must be a normal operand.
	; set op1 status flag to "Infinite" 
	RDMEM	s0, op1_status	
	OR 		s0, 0x01		; op1 is normal
	WRMEM	s0, op1_status	
set_op2_status:	
 	; Check if the op2 (ey) exponent bits are all zero      
 	; Extract ex : [s7, s6]
	RDMEM	s7, y_7	       
	RDMEM	s6, y_6
	AND		s7, 0x7F 		; zero the sign bit
	TEST 	s6, 0xF0
	TESTC 	s7, 0x7F 
	JUMP	NZ, ey_not_zero
ey_zero:	
	; Load y mantisa into registers	
	RDMEM sF, y_6
	RDMEM sE, y_5
	RDMEM sD, y_4
	RDMEM sC, y_3
	RDMEM sB, y_2
	RDMEM sA, y_1
	RDMEM s9, y_0
	; Check if all bits of significand are zero
	TEST	sF, 0x0F
	TESTC	sE, 0xFF
	TESTC	sD, 0xFF
	TESTC	sC, 0xFF
	TESTC	sB, 0xFF
	TESTC	sA, 0xFF
	TESTC	s9, 0xFF
	JUMP	NZ, op2_is_subnormal
op_2_is_zero:	
	; set op1 status flag to "Zero"   -- status bits = 0xSZIN --
	RDMEM	s0, op2_status	
	OR 		s0, 0x40		; op2 is zero
	WRMEM	s0, op2_status
	RET
op2_is_subnormal:
	; set op1 status flag to "Subnormal"
	RDMEM	s0, op2_status	
	OR 		s0, 0x80		; op1 is subnormal
	WRMEM	s0, op2_status	
	RET
ey_not_zero:
 	; Check if the op2 (ex) exponent bits are all one
 	; Extract ex : [s7, s6]
	RDMEM	s7, y_7	       
	RDMEM	s6, y_6
	AND		s7, 0x7F 		; zero the sign bit
	AND		s6, 0xF0			; zero the low nibble
	COMP 	s6, 0xF0	
	COMPC 	s7, 0x7F 
	JUMP	NZ, ey_not_all_one
ey_all_one:
	; Load y mantisa into registers	
	RDMEM sF, y_6
	RDMEM sE, y_5
	RDMEM sD, y_4
	RDMEM sC, y_3
	RDMEM sB, y_2
	RDMEM sA, y_1
	RDMEM s9, y_0
	; Check if all bits of significand are zero
	TEST	sF, 0x0F
	TESTC	sE, 0xFF
	TESTC	sD, 0xFF
	TESTC	sC, 0xFF
	TESTC	sB, 0xFF
	TESTC	sA, 0xFF
	TESTC	s9, 0xFF
	JUMP	Z, op2_is_inf
op2_is_NaN:	
	; set op1 status flag to "NaN" -- status bits = 0xSZIN --
	RDMEM	s0, op2_status	
	OR 		s0, 0x10		; op1 is NaN
	WRMEM	s0, op2_status	
	RET
op2_is_inf:	
	; set op1 status flag to "Infinite" 
	RDMEM	s0, op2_status	
	OR 		s0, 0x20		; op1 is infinite
	WRMEM	s0, op2_status	
	RET
ey_not_all_one:	
	; Here we conclude that ey is not all zeros and not all ones.
	;  therefore op1 must be a normal operand.
	RDMEM	s0, op2_status	
	OR 		s0, 0x01		; op2 is normal
	WRMEM	s0, op2_status	
	RET	

;------------------------------------------------------------------------------------
; Procedure:			twos_mx()
;
; Registers Used:	Bank0 : 
;					Bank1 : None		
;					SPM	  : x_m7, x_m6, ... x_m0
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;
; Calls:				None
;					None
;
; RETs:				SPM: 
; 
; RET Flags:			None
;
; Description:		Calcultes the twos complement of mx and replace it 
;						with the result
;------------------------------------------------------------------------------------	
twos_mx:
	CALL 	load_mx			; Load hidden bit+mantisa+guard bits(grs) [s7, s0]
	XOR 	s0, 0xE0			; toggle all bits 
	XOR 	s1, 0xFF		
	XOR 	s2, 0xFF		
	XOR 	s3, 0xFF		
	XOR 	s4, 0xFF		
	XOR 	s5, 0xFF		
	XOR 	s6, 0xFF		
	XOR 	s7, 0x7F
	ADD  	s0, 0x20			; Add 1 to the sticky bit		   
	ADDC 	s1, 0x00		
	ADDC 	s2, 0x00		   
	ADDC 	s3, 0x00		   
	ADDC 	s4, 0x00		   
	ADDC 	s5, 0x00		   
	ADDC 	s6, 0x00		   
	ADDC 	s7, 0x00
	WRMEM 	s7, x_m6			; Save back the shifted mantisa into SPM	
	WRMEM 	s6, x_m5
	WRMEM 	s5, x_m4
	WRMEM 	s4, x_m3
	WRMEM 	s3, x_m2
	WRMEM 	s2, x_m1
	WRMEM 	s1, x_m0
	WRMEM 	s0, x_grs
	RET
	
;------------------------------------------------------------------------------------
; Procedure:			twos_my()
;
; Registers Used:	Bank0 : 
;					Bank1 : None		
;					SPM	  : x_m7, x_m6, ... x_m0
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;
; Calls:				None
;					None
;
; RETs:				SPM: 
; 
; RET Flags:			None
;
; Description:		Calcultes the twos complement of my and replace it 
;						with the result
;------------------------------------------------------------------------------------	
twos_my:
	CALL 	load_my			; Load hidden bit+mantisa+guard bits(grs) [sF, s8]
	XOR 	s8, 0xE0			; toggle all bits 
	XOR 	s9, 0xFF		
	XOR 	sA, 0xFF		
	XOR 	sB, 0xFF		
	XOR 	sC, 0xFF		
	XOR 	sD, 0xFF		
	XOR 	sE, 0xFF		
	XOR 	sF, 0x7F
	ADD  	s8, 0x20			; Add 1 to the sticky bit		   
	ADDC 	s9, 0x00		
	ADDC 	sA, 0x00		   
	ADDC 	sB, 0x00		   
	ADDC 	sC, 0x00		   
	ADDC 	sD, 0x00		   
	ADDC 	sE, 0x00		   
	ADDC 	sF, 0x00
	WRMEM 	sF, y_m6			; Save back the shifted mantisa into SPM		
	WRMEM 	sE, y_m5
	WRMEM 	sD, y_m4
	WRMEM 	sC, y_m3
	WRMEM 	sB, y_m2
	WRMEM 	sA, y_m1
	WRMEM 	s9, y_m0
	WRMEM 	s8, y_grs
	RET	
	
;------------------------------------------------------------------------------------
; Procedure:			normalize()
;
; Registers Used:	Bank0 : s7, s6, ..., s0: Hidden bit + mantisa + guard bits (grs)
;					Bank1 : None		
;		
; Arguments:			Bank0 : s7, s6, ..., s0: Hidden bit + mantisa + guard bits (grs)
;					Bank1 : None
;
; Calls:				None
;					None
;
; RETs:				SPM: 
; 
; RET Flags:			None
;
; Description:		Normalized the result saved in [s7, s6, ..., s0].
;------------------------------------------------------------------------------------	
normalize:
	TEST	s7, 0x20
	JUMP	Z, no_overflow_found
	; Overflow detected
	; if sticky bit of s0 is 1 keep it 1
	TEST   s0, 0x20
	JUMP   Z, dont_keep_sticky_bit			
	LOAD   sF, 0x20
	JUMP   done_keeping_sticky_bit	
dont_keep_sticky_bit:
	LOAD   sF, 0x00
done_keeping_sticky_bit:	
	SR0		s7				; shift right by 1
	RORC	s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0
	RDMEM	s8, r_ex6				; Yes: Increment exponent by 1
	RDMEM	s9, r_ex7
	ADD		s8, 0x01
	ADDC	s9, 0x00
	WRMEM	s8, r_ex6
	WRMEM	s9, r_ex7
	OR		s0, sF
	JUMP	done_cancellation

no_overflow_found:
	; Check if we need normalization or not
	TEST	s7, 0x10
	JUMP	Z, cancellation		; Perform cancellation
;	JUMP	NZ, done_cancellation	; Perform cancellation
	
	
check_subnormal_case:
	; Check if both operands are subnormals 
	RDMEM 	sF, op1_status
	RDMEM 	sE, op2_status
	AND		sF, sE
	TEST	sF, 0x80
	JUMP	Z, done_cancellation
	; Both ops subnormal but bit4 of s7 is 1 => underflow detected
	RDMEM	s8, underflow
	TEST	s8, 0x01
	JUMP	NZ,	done_cancellation	; underflow already applied
	; Both subnormals but we have 1 in bit 1 of s7 =< apply underflow
	RDMEM	s8, r_ex6				; Increment exponent by 1
	RDMEM	s9, r_ex7
	ADD		s8, 0x01
	ADDC	s9, 0x00
	WRMEM	s8, r_ex6
	WRMEM	s9, r_ex7	
	LOAD	s8, 0x01				; Set underflow applied bit
	WRMEM	s8, underflow	
	JUMP 	done_cancellation
cancellation:
	; Cancellation:	
	; Count the number of leading zeros = nlz
	; Shift "mr" left by nlz, and set er = er - nlz
	; Check if er is zero then the result is as it is
	RDMEM 	sB, r_ex7
	RDMEM 	sA, r_ex6
	TEST	sA, 0x0F
	TESTC	sB, 0xFF
	JUMP	Z, 	done_cancellation		; result is subnormal
	; else perform cancellation
	LOAD	sA, 0x01				; nlz nounter	
	; zero the unused bit
	AND 	s7, 0x7F
	LOAD	s8, s7				; make a copy of s7
	SL1  	s8
	SL1		s8
	SL1		s8
	SL1		s8
	; Count nlz in s8
	CALL 	count_nlz			; RETs number of zeros in s9
	TEST	s9, 0xFF				; is s9 = 0 ?	    
	JUMP	Z, nlz_counting_done
	COMP 	s9, 0x04
	JUMP 	Z, got_nlz_4
	ADD	sA, s9					; Less than 4 zeros, Add the counted nlz to sA 
		    					;  and finish the nlz counting,
JUMP	nlz_counting_done

got_nlz_4:
       ADD	sA, 0x08				; Add 8 nlz to sA
       LOAD	s8, s5
       CALL 	count_nlz			; RETs number of zeros in s9
       COMP 	s9, 0x08
       JUMP 	Z, got_nlz_8_s4
       ADD	sA, s9				; Less than 4 zeros, Add the counted nlz to sA 
       		    				;  and finish the nlz counting,
       JUMP	nlz_counting_done
got_nlz_8_s4:
       ADD	sA, 0x08				; Add 8 nlz to sA
       LOAD	s8, s4
       CALL 	count_nlz			; RETs number of zeros in s9
       COMP 	s9, 0x08
       JUMP 	Z, got_nlz_8_s3
       ADD	sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
       		    				;  and finish the nlz counting,
       JUMP	nlz_counting_done
got_nlz_8_s3:
       ADD	sA, 0x08				; Add 8 nlz to sA
       LOAD	s8, s3
       CALL 	count_nlz			; RETs number of zeros in s9
       COMP 	s9, 0x08
       JUMP 	Z, got_nlz_8_s2
       ADD	sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
       		    				;  and finish the nlz counting,
       JUMP	nlz_counting_done
got_nlz_8_s2:
       ADD	sA, 0x08				; Add 8 nlz to sA
       LOAD	s8, s2
       CALL 	count_nlz			; RETs number of zeros in s9
       COMP 	s9, 0x08
       JUMP 	Z, got_nlz_8_s1
       ADD	sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
       		    				;  and finish the nlz counting,
       JUMP	nlz_counting_done
got_nlz_8_s1:
       ADD	sA, 0x08				; Add 8 nlz to sA
       LOAD	s8, s1
       CALL 	count_nlz			; RETs number of zeros in s9
       COMP 	s9, 0x08
       JUMP 	Z, got_nlz_8_s0
       ADD	sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
       		    				;  and finish the nlz counting,
       JUMP	nlz_counting_done
got_nlz_8_s0:
	   ADD	sA, 0x08				; Add 8 nlz to sA
       LOAD	s8, s0
       CALL 	count_nlz			; RETs number of zeros in s9   
       ADD	sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
       		    				;  and finish the nlz counting,
nlz_counting_done:
	TEST sA, 0xFF				; is sA zero ?
	JUMP Z, done_intermediate_shift_riht_loop
    ; Shift the intermediate result to left by nlz(sA) bits.
    LOAD s9, sA					; Copy the sA
 	; At this point result mantisa is in [s7, s6, ..., s1] 				
intermediate_shift_riht_loop:
       SL0  s0					; 1-bit left shift		
       ROLC s1						
       ROLC s2		
       ROLC s3		
       ROLC s4		
       ROLC s5		
       ROLC s6		
       ROLC s7
       SUB s9, 0x01
       JUMP NZ, intermediate_shift_riht_loop
done_intermediate_shift_riht_loop:
	; Subtract the er by the number of bits shifted left (sA).
	RDMEM 	s9, r_ex7				; read exponent
	RDMEM 	s8, r_ex6				 
	SUB		s8, sA
	SUBC	s9,	0x00	
	WRMEM 	s9, r_ex7				; write back result exponent
	WRMEM 	s8, r_ex6		
	JUMP 	done_cancellation
normalize_shift_right_by_one:	
	SR0		s7
	RORC	s6		   
	RORC	s5		   
	RORC	s4		   
	RORC	s3		   
	RORC	s2		   
	RORC	s1		   
	RORC	s0		   
	RDMEM 	s9, r_ex7				; read exponent
	RDMEM 	s8, r_ex6				 
	ADD		s8, 0x01
	ADDC	s9,	0x00	
	WRMEM 	s9, r_ex7				; write back result exponent
	WRMEM 	s8, r_ex6		
done_cancellation:  
	RET
	
;-----------------------------------------------------------------------------------
; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
;
;	beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
;
;------------------------------------------------------------------------------------
; Procedure:			arith_mul_x_y()
;
; Registers Used:	Bank0 : All
;					Bank1 : None		
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;					SPM   : x = [x_7, x_6, ..., x_0]
;			      			y = [y_7, y_6, ..., y_0]						
;
; Calls:				set_ops_status
;					decompose_x
;					decompose_y
;					mul_special_cases
;					mul_normalize_mx
;					mul_mx_my
;					add_ex_ey
;					return_zero_mul
;
; RETs:				None
; 
; RET Flags:			None
;
; Description:		Multiplies two 64-bit double-precision floating point numbers.
;------------------------------------------------------------------------------------
arith_mul_x_y:
	CALL 	set_ops_status
	CALL 	decompose_x
	CALL 	decompose_y
	CALL 	mul_special_cases
	COMP	sF, 0xFF
	JUMP	Z, done_multiplying
	CALL 	mul_normalize_mx
	CALL 	mul_normalize_my
	; op1 and op2 both are normal	
	CALL 	mul_mx_my		; result is in [Umr_6, Umr_0]
	CALL	add_Ex_Ey		; exponent of result in [s1, s0]
	; if er < 0 and er > -53 then result is subnormal, shift significand by er and set the er to zero
	; if er < 0 and er <= -53 then the result is zero (underflow).
	; if er = 0 then the result is subnormal but no shift is needed.	
	; if er > 0 then the result is normal, no further action is needed.
	; -53 = 0xFFDD = - 0x0023
	; Read the mr [Umr_6 downto L_mr_6] (the first 53-bit starting from left)
	RDMEM	s9, Umr_6
	RDMEM	s8, Umr_5
	RDMEM	s7, Umr_4
	RDMEM	s6, Umr_3
	RDMEM	s5, Umr_2
	RDMEM	s4, Umr_1
	RDMEM	s3, Umr_0
	RDMEM	s2, Lmr_6
	LOAD	sF, s1			; Copy s1 into sF. sF will be used later to determine a shift left case
	TEST	s1, 0x80
	JUMP	Z,	mul_compose_result		; Normal case, so skip all subnormal tests
	; Here we are sure that the er is negative 	
	XOR		s1, 0xFF		; Find the twos's complement of er
	XOR		s0, 0xFF
	ADD		s0, 0x01
	ADDC	s1, 0x00
	COMP 	s0, 0x35
	COMPC	s1, 0x00
	JUMP	Z, mul_result_is_zero	; er = -53, underflow
	JUMP 	C, er_greater_than_53	; er > -53, subnormal
	JUMP	mul_result_is_zero		; er < -53. underflow
er_greater_than_53:	
keep_shifting_mr_to_right:
	SR0		s9
	RORC	s8
	RORC	s7	
	RORC	s6	
	RORC	s5	
	RORC	s4	
	RORC	s3	
	RORC	s2	
	SUB		s0, 0x01
	SUBC	s1, 0x00
	JUMP	NZ, keep_shifting_mr_to_right
	; Here [s1, s0] must be zero
mul_compose_result:	
	; Compose the result
	;RDMEM	s8, Umr_6
	;RDMEM	s7, Umr_5
	;RDMEM	s6, Umr_4
	;RDMEM	s5, Umr_3
	;RDMEM	s4, Umr_2round
	;RDMEM	s3, Umr_1
	;RDMEM	s2, Umr_0
	TEST	s9, 0x02					; if bit 106 is 1 then shift significand to right by 1 
	JUMP	Z, dont_inc_exponent		;	and increment the exponent
	; shift significand right by 1	
	SR0		s9
	RORC	s8	
	RORC	s7	
	RORC	s6	
	RORC	s5	
	RORC	s4	
	RORC	s3
	RORC	s2
	; add 1 to exponent
	ADD		s0, 0x01
	ADDC	s1, 0x00
	; Now the significance is in [s8 ... s2] registers with the following pattern:
	;	s8 to s3:		xxxx_xxxx
	;	s2:				xxxx_0000
dont_inc_exponent:	
	TEST	sF, 0x80
	JUMP	NZ, not_normal_case
	SL0		s2
	ROLC	s3
	ROLC	s4
	ROLC	s5
	ROLC	s6
	ROLC	s7
	ROLC	s8
	ROLC	s9
not_normal_case:
	; Now the significance (52-bits) is in [s9 ... s2] registers with the following pattern:
	; X means bit is used
	;	s9:				0000_000x
	;	s8 to s3:		xxxx_xxxx
	;	s2:				xxx0_0000
	; So we shift the registers to left by 3  
	SL0		s2
	ROLC	s3
	ROLC	s4
	ROLC	s5
	ROLC	s6
	ROLC	s7
	ROLC	s8
	ROLC	s9
	SL0		s2
	ROLC	s3
	ROLC	s4
	ROLC	s5
	ROLC	s6
	ROLC	s7
	ROLC	s8
	ROLC	s9
	SL0		s2
	ROLC	s3
	ROLC	s4
	ROLC	s5
	ROLC	s6
	ROLC	s7
	ROLC	s8
	ROLC	s9	
	; Significance now is in [s9(lower nibble), ..., s3]
	; Round
	CALL 	mul_round	; pass s3 as the lowest nibble and s2 has guard bits
	; Propogate the possible carry produced by rounding
	ADDC	s4, 0x00
	ADDC	s5, 0x00
	ADDC	s6, 0x00
	ADDC	s7, 0x00
	ADDC	s8, 0x00
	ADDC	s9, 0x00
	
	; Combine exponent [s1, s0] and significand [s9, ..., s3]
	; Shift exponent to left by 4
	SL0		s0
	ROLC	s1
	SL0		s0
	ROLC	s1
	SL0		s0
	ROLC	s1
	SL0		s0
	ROLC	s1
	; Zero the unused high nibble
	AND		s9, 0x0F
	; Combine the exponent with significand
	OR		s9, s0
	; Calculate the sign
	RDMEM	sF,	x_sign
	RDMEM	sE,	y_sign
	XOR		sF, sE			; Calculate the sign
	AND		sF, 0x80	
	OR		s1, sF			; Apply the sign
	; Save the result in SMP
	WRMEM 	s3, r_0
	WRMEM 	s4, r_1
	WRMEM 	s5, r_2
	WRMEM 	s6, r_3
	WRMEM 	s7, r_4
	WRMEM 	s8, r_5
	WRMEM 	s9, r_6 
	WRMEM 	s1, r_7		
	JUMP	done_multiplying
mul_result_is_zero:
	CALL	return_zero_mul
done_multiplying:	
	RET
	
;------------------------------------------------------------------------------------
; Procedure:			mul_mx_my()
;
; Registers Used:	Bank0 : All
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;					SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
;							y_m6, y_m5, ... y_m0	 (7-bytes)
;			      			
;
; Calls:				
;
; RETs:				Bank1: 
; 
; RET Flags:			None
;
; Description:		Multiplies two 53-bit double-precision floating point numbers.
;------------------------------------------------------------------------------------
mul_mx_my:
	; Setup shifted mx SPM
	LOAD	sD, 0x00
	LOAD	sC, 0x00
	LOAD	sB, 0x00
	LOAD	sA, 0x00
	LOAD	s9, 0x00
	LOAD	s8, 0x00
	LOAD	s7, 0x00
	RDMEM 	s6, x_m6
	RDMEM	s5, x_m5
	RDMEM 	s4, x_m4
	RDMEM 	s3, x_m3
	RDMEM 	s2, x_m2
	RDMEM 	s1, x_m1
	RDMEM 	s0, x_m0
	WRMEM	sD, Umx_shifted_6
	WRMEM	sC, Umx_shifted_5
	WRMEM	sB, Umx_shifted_4
	WRMEM	sA, Umx_shifted_3
	WRMEM	s9, Umx_shifted_2
	WRMEM	s8, Umx_shifted_1
	WRMEM	s7, Umx_shifted_0
	WRMEM	s6, Lmx_shifted_6
	WRMEM	s5, Lmx_shifted_5
	WRMEM	s4, Lmx_shifted_4
	WRMEM	s3, Lmx_shifted_3
	WRMEM	s2, Lmx_shifted_2
	WRMEM	s1, Lmx_shifted_1
	WRMEM	s0, Lmx_shifted_0
	LOAD	sF, 0x00				; Initially shift to left by 0
	LOAD	sE, 0x00				; Initially shift to left by 0
;	TEST	s0, 0x01				; Test if bit 0 is one
;	JUMP 	NZ, shifting_mx_left_done
next_shift_add:
	; load my
	RDMEM 	s6, y_m6
	RDMEM 	s5, y_m5
	RDMEM 	s4, y_m4
	RDMEM 	s3, y_m3
	RDMEM 	s2, y_m2
	RDMEM 	s1, y_m1
	RDMEM 	s0, y_m0
next_right_shift:
	COMP	sF, 0x35						; Have reached 54?		
	JUMP	Z, finish_mul				; Yes: Finish the multiplication
	TEST	s0, 0x01						; Check the LSB
	JUMP 	NZ,	shift_and_add			; if it is 1: shift and add
	; it is 0: shift my to right by 1
	SR0		s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0		
	ADD		sE, 0x01		
	ADD		sF, 0x01	
	JUMP	next_right_shift		
shift_and_add:
	; Save shifted my into SPM
	WRMEM 	s6, y_m6
	WRMEM 	s5, y_m5
	WRMEM 	s4, y_m4
	WRMEM 	s3, y_m3
	WRMEM 	s2, y_m2
	WRMEM 	s1, y_m1
	WRMEM 	s0, y_m0
	; load mx	
	RDMEM	sD, Umx_shifted_6
	RDMEM	sC, Umx_shifted_5
	RDMEM	sB, Umx_shifted_4
	RDMEM	sA, Umx_shifted_3
	RDMEM	s9, Umx_shifted_2
	RDMEM	s8, Umx_shifted_1
	RDMEM	s7, Umx_shifted_0
	RDMEM	s6, Lmx_shifted_6
	RDMEM	s5, Lmx_shifted_5
	RDMEM	s4, Lmx_shifted_4
	RDMEM	s3, Lmx_shifted_3
	RDMEM	s2, Lmx_shifted_2
	RDMEM	s1, Lmx_shifted_1
	RDMEM	s0, Lmx_shifted_0
	COMP	sE, 0x00
	JUMP	Z, shifting_mx_left_done2
	; Shift mx left by sE
keep_shifting_mx_left:	
	Sl0		s0
	ROLC	s1
	ROLC	s2
	ROLC	s3
	ROLC	s4
	ROLC	s5
	ROLC	s6	
	ROLC	s7	
	ROLC	s8	
	ROLC	s9	
	ROLC	sA	
	ROLC	sB	
	ROLC	sC	
	ROLC	sD	
	SUB		sE, 0x01
	JUMP	NZ,	keep_shifting_mx_left
shifting_mx_left_done:
	WRMEM	sD, Umx_shifted_6
	WRMEM	sC, Umx_shifted_5
	WRMEM	sB, Umx_shifted_4
	WRMEM	sA, Umx_shifted_3
	WRMEM	s9, Umx_shifted_2
	WRMEM	s8, Umx_shifted_1
	WRMEM	s7, Umx_shifted_0
	WRMEM	s6, Lmx_shifted_6
	WRMEM	s5, Lmx_shifted_5
	WRMEM	s4, Lmx_shifted_4
	WRMEM	s3, Lmx_shifted_3
	WRMEM	s2, Lmx_shifted_2
	WRMEM	s1, Lmx_shifted_1
	WRMEM	s0, Lmx_shifted_0
shifting_mx_left_done2:	
	; now add shifted mx to the previous result (mr)
	; Load lower half of mr into registers [sD, s7]
	RDMEM	sD, Lmr_6
	RDMEM	sC, Lmr_5
	RDMEM	sB, Lmr_4
	RDMEM	sA, Lmr_3
	RDMEM	s9, Lmr_2
	RDMEM	s8, Lmr_1
	RDMEM	s7, Lmr_0
	; Load lower half of shifted mx into registers [s6, s0] :already there
	; Add 
	ADD		s0, s7
	ADDC	s1, s8
	ADDC	s2, s9
	ADDC	s3, sA
	ADDC	s4, sB
	ADDC	s5, sC
	ADDC	s6, sD
	; save result
	WRMEM	s6, Lmr_6
	WRMEM	s5, Lmr_5
	WRMEM	s4, Lmr_4
	WRMEM	s3, Lmr_3
	WRMEM	s2, Lmr_2
	WRMEM	s1, Lmr_1
	WRMEM	s0, Lmr_0
;	JUMP	NC, no_carry_for_lower_add
	; save the carry
;	LOAD 	s7, 0x01
;	WRMEM	s7, mr_save_carry
;no_carry_for_lower_add:	
	; Load upper half of mr into registers [sD, s7]
	RDMEM	sD, Umr_6
	RDMEM	sC, Umr_5
	RDMEM	sB, Umr_4
	RDMEM	sA, Umr_3
	RDMEM	s9, Umr_2
	RDMEM	s8, Umr_1
	RDMEM	s7, Umr_0
	; Load upper half of shifted mx into registers [s6, s0]
	RDMEM	s6, Umx_shifted_6
	RDMEM	s5, Umx_shifted_5
	RDMEM	s4, Umx_shifted_4
	RDMEM	s3, Umx_shifted_3
	RDMEM	s2, Umx_shifted_2
	RDMEM	s1, Umx_shifted_1
	RDMEM	s0, Umx_shifted_0
	; Add
	ADDC	s0, s7
	ADDC	s1, s8
	ADDC	s2, s9
	ADDC	s3, sA
	ADDC	s4, sB
	ADDC	s5, sC
	ADDC	s6, sD
	; save result
	WRMEM	s6, Umr_6
	WRMEM	s5, Umr_5
	WRMEM	s4, Umr_4
	WRMEM	s3, Umr_3
	WRMEM	s2, Umr_2
	WRMEM	s1, Umr_1
	WRMEM	s0, Umr_0


	;shift my to right by 1 so we can check its LSB in next round
	; load my
	RDMEM 	s6, y_m6
	RDMEM 	s5, y_m5
	RDMEM 	s4, y_m4
	RDMEM 	s3, y_m3
	RDMEM 	s2, y_m2
	RDMEM 	s1, y_m1
	RDMEM 	s0, y_m0
	SR0		s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0
	WRMEM 	s6, y_m6
	WRMEM 	s5, y_m5
	WRMEM 	s4, y_m4
	WRMEM 	s3, y_m3
	WRMEM 	s2, y_m2
	WRMEM 	s1, y_m1
	WRMEM 	s0, y_m0
	
	ADD		sF, 0x01
	LOAD	sE, 0x01				; tracks the numebr of shifts per round, set it to zero for next round
	JUMP 	next_shift_add
	
finish_mul:
	RET
	
;------------------------------------------------------------------------------------
; Procedure:			add_Ex_Ey()
;
; Registers Used:	Bank0 : All
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;					SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
;							y_m6, y_m5, ... y_m0	 (7-bytes)
;			      			
;
; Calls:				
;
; RETs:				Bank1: [s1. s0]
; 
; RET Flags:			None
;
; Description:		Calculates the ex + ey which is Ex + Ey - bias(1023) and returns
;						the result in [s1, s0].
;------------------------------------------------------------------------------------
add_Ex_Ey:	
	; Read ex
	RDMEM 	s1, x_ex7
	RDMEM 	s0, x_ex6
	; if op1 is subnormal then subtract by 1022 else subtract by  1023
	RDMEM	sF, op1_status
	TEST	sF, 0x80
	JUMP	NZ,	subnormal_exponent_detected
	; Subtract by 1023
	SUB		s0, 0xFF
	SUBC	s1,	0x03		
	JUMP	done_exponent_subtracting
subnormal_exponent_detected:			
	; Subtract by 1022
	SUB		s0, 0xFE
	SUBC	s1,	0x03		
done_exponent_subtracting:	
	; Read ey
	RDMEM 	s3, y_ex7
	RDMEM 	s2, y_ex6
	; if [s1, s0] == zero then subtract 1022 elsesubtract 1023
	RDMEM	sF, op2_status
	TEST	sF, 0x80
	JUMP	NZ,	subnormal_exponent_detected_y
	; Subtract by 1023
	SUB		s2, 0xFF
	SUBC	s3,	0x03		
	JUMP	done_exponent_subtracting_y
subnormal_exponent_detected_y:			
	; Subtract by 1022
	SUB		s2, 0xFE
	SUBC	s3,	0x03		
done_exponent_subtracting_y:
	ADD		s0, s2
	ADDC	s1, s3
	ADD		s0, 0xFF			; subtract by 1023'd =  0x03FF
	ADDC	s1, 0x03
	RET
	
;------------------------------------------------------------------------------------
; Procedure:			mul_special_cases()
;
; Registers Used:	Bank0 : s1, s2
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;			      			
;
; Calls:				
;
; RETs:				Bank1: [s1. s0]
; 
; RET Flags:			None
;
; Description:		Takes care of special operands in multiplication.
;					Return 0xFF in sF if one of the operands is special.
;					If sF is 0xFF then the result is already in [r_7, r_8] in SPM.
;------------------------------------------------------------------------------------	
mul_special_cases:
	RDMEM 	s1, op1_status	; read the ops status
	RDMEM 	s2, op2_status	; read the ops status
	; We check op1 for 
	; 1) NaN
	;		Yes:	return X_NaN	
	;		No:		Go to step 2.
	; 2) Infinity
	;		Yes:	Check op2, if +0 and NaN then return_NaN_Inf
	;		No:		return +infinity
	; 3) Zero
	;		Yes:	check if op2 is +inf or NaN then return_NaN_Inf
	;				 else return 0
	;		No:		check op2
	;-----------------------------------------------
	; Check if op1 is NaN
	TEST	s1, 0x10
	JUMP	Z, mul_final_op1_not_NaN		; No
mul_final_op1_NaN:						; Yes
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP 	NZ, return_xy_NAN	; Yes
	JUMP	return_x_NAN
mul_final_op1_not_NaN:
	;	+inf + + inf = +inf
	;	+inf + - inf = +NaN
	;	-inf + + inf = +NaN
	;	-inf + - inf = -inf
	; infinity sign is the AND of both operands' sign bits.
	; Result NaN bit is XOR of both operands' sign bits.
	;-----------------------------------
	; Check if op1 is Inf
	TEST	s1, 0x20
	JUMP	Z, mul_final_op1_not_Inf		; No
mul_final_op1_Inf:						; Yes
	; Check if op2 is zero
	TEST	s2, 0x40
	JUMP	NZ, return_pos_inf
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN		; Yes
	JUMP	return_x_Inf		
mul_final_op1_not_Inf:	
	; Check if op1 is zero
	TEST	s1, 0x40
	JUMP	Z, mul_check_final_op2		; No
mul_final_op1_is_zero:
	; Check if op2 is Inifinity
	TEST	s2, 0x20
	JUMP	NZ, return_y_NAN_positive		; Yes
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN_positive		;Yes
	JUMP	return_zero_mul
	; Op1 is not NaN, Inf, and zero, so we conclude op1 is (sub)normal.	
	; We check op2 for 
	; 1) NaN
	;		Yes:	return_NaN_Inf
	;		No:		Go to step 2.
		; 2) Infinity
	;		Yes:	return_NaN_Inf
	;		No:		return x
	; 3) Zero
	;		Yes:	return zero
	;		No:		swap_step

mul_check_final_op2:				; Here we are sure op1 is (sub)normal
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN_positive		;Yes
	JUMP	mul_final_op2_not_NaN	
return_y_NAN_positive:
	; make y positive
	LOAD 	sE, 0x7F
	RDMEM	sD, y_7
	AND		sD, sE
	WRMEM	sD, y_7	
	JUMP	return_y_NAN
		
mul_final_op2_not_NaN:					; No
	; Check if op2 is Infinity
	TEST	s2, 0x20
	JUMP	NZ, return_y_Inf			; Yes
	; Check if op2 is zero
	TEST	s2, 0x40
	JUMP	NZ, return_zero_mul				; Yes
	
	; Both operators are (sub)normal. Perform the multiplication.
	LOAD	sF, 0x00
	RET	

;------------------------------------------------------------------------------------
; Procedure:			return_zero_mul()
;
; Registers Used:	Bank0 : 
;					Bank1 : None		
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;
; Calls:				None
;					None
;
; RETs:				
; 
; RET Flags:			None
;
; Description:		Returns zero
;------------------------------------------------------------------------------------
return_zero_mul:
	LOAD	sF, 0xFF
;	+0 +0	=> +0 	
;	-0 +0	=> -0 	
;	+0 -0	=> -0 	
;	-0 -0	=> +0 	
	RDMEM	s1, x_sign
	RDMEM	s2, y_sign
	XOR		s1, s2			; Calculate the sign of zero
	AND		s1, 0x80			; zero all other bits except sign
	LOAD	s0, 0x00
	WRMEM 	s0, r_6
	WRMEM 	s0, r_5
	WRMEM 	s0, r_4
	WRMEM 	s0, r_3
	WRMEM 	s0, r_2
	WRMEM 	s0, r_1
	WRMEM 	s0, r_0
	WRMEM 	s1, r_7
	RET	


return_y_Inf:
	LOAD 	sF, 0xFF			; Signal the caller that the operation is complete.
	RDMEM	s3, x_sign	
	RDMEM	s4, y_sign		
	XOR		s3, s4	
	LOAD	s2,	0x7F
	LOAD	s1,	0xF0
	OR		s2, s3
	LOAD	s0, 0x00      
	WRMEM 	s2, r_7
	WRMEM 	s1, r_6
	WRMEM 	s0, r_5
	WRMEM 	s0, r_4
	WRMEM 	s0, r_3
	WRMEM 	s0, r_2
	WRMEM 	s0, r_1
	WRMEM 	s0, r_0
	RET
	
return_x_Inf:
	LOAD 	sF, 0xFF			; Signal the caller that the operation is complete.
	RDMEM	s3, x_sign		
	RDMEM	s4, y_sign		
	XOR		s3, s4
	LOAD	s2,	0x7F
	LOAD	s1,	0xF0
	OR		s2, s3
	LOAD	s0, 0x00      
	WRMEM 	s2, r_7
	WRMEM 	s1, r_6
	WRMEM 	s0, r_5
	WRMEM 	s0, r_4
	WRMEM 	s0, r_3
	WRMEM 	s0, r_2
	WRMEM 	s0, r_1
	WRMEM 	s0, r_0
	RET	
	
return_pos_inf:
	LOAD 	sF, 0xFF			; Signal the caller that the operation is complete.
	; Calculate the sign
	RDMEM	sB,	x_sign
	RDMEM	sA,	y_sign
	XOR		sB, sA			; Calculate the sign
	AND		sB, 0x80	
	LOAD	s2,	0x7F
	OR		s2, sB			; Apply the sign
	LOAD	s1,	0xF0
	LOAD	s0, 0x00      
	WRMEM 	s2, r_7
	WRMEM 	s1, r_6
	WRMEM 	s0, r_5
	WRMEM 	s0, r_4
	WRMEM 	s0, r_3
	WRMEM 	s0, r_2
	WRMEM 	s0, r_1
	WRMEM 	s0, r_0
	RET
	
return_xy_NAN:
	; compare MSB significance of x (the NaN bit) vs MSB significance of y significance
	RDMEM	sF, x_m6
	RDMEM	sE, y_m6
	TEST	sF, 0x08			
	JUMP	NZ,	test_y_significand 
	JUMP	return_x_NAN
test_y_significand:
	TEST	sE, 0x08
	JUMP	Z, return_y_NAN		; x NaN bit is 1, y NaN bit is 0
	JUMP	return_x_NAN
	
;------------------------------------------------------------------------------------
; Procedure:			mul_cancellation()
;
; Registers Used:	Bank0 : [s6, s0]
;					Bank1 : None		
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;
; Calls:				None
;					None
;
; RETs:				sA : the number of bits shifted to left 
; 
; RET Flags:			None
;
; Description:		Receives a subnormal significand in [s6, s0] and normalizes it
;------------------------------------------------------------------------------------	
mul_cancellation:
	; Count the number of leading zeros = nlz
	; Shift left by nlz, and rturn the number of shifted bits.
	; Check if er is zero then the result is as it is
	LOAD	sA, 0x01			; nlz nounter	
	LOAD	s8, s6			; make a copy of s6
	SL1  	s8
	SL1		s8
	SL1		s8
	SL1		s8
	; Count nlz in s8
	CALL 	count_nlz			; RETs number of zeros in s9
	TEST	s9, 0xFF				; is s9 = 0 ?	    
	JUMP	Z, mul_nlz_counting_done
	COMP 	s9, 0x04
	JUMP 	Z, mul_got_nlz_4
	ADD		sA, s9				; Less than 4 zeros, Add the counted nlz to sA 
		    					;  and finish the nlz counting,
	JUMP	mul_nlz_counting_done
mul_got_nlz_4:
	ADD		sA, 0x04				; Add 4 nlz to sA
	LOAD	s8, s5
	CALL 	count_nlz			; RETs number of zeros in s9
	COMP 	s9, 0x08
	JUMP 	Z, mul_got_nlz_8
	ADD		sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
			    				;  and finish the nlz counting,
	JUMP	mul_nlz_counting_done
mul_got_nlz_8:
	ADD		sA, 0x08				; Add 8 nlz to sA
	LOAD	s8, s4
	CALL 	count_nlz			; RETs number of zeros in s9
	COMP 	s9, 0x08
	JUMP 	Z, mul_got_nlz_8_s3
	ADD		sA, s9				; Less than 4 zeros, Add the counted nlz to sA 
			    				;  and finish the nlz counting,
	JUMP	mul_nlz_counting_done
mul_got_nlz_8_s3:
	ADD		sA, 0x08				; Add 8 nlz to sA
	LOAD	s8, s3
	CALL 	count_nlz			; RETs number of zeros in s9
	COMP 	s9, 0x08
	JUMP 	Z, mul_got_nlz_8_s2
	ADD		sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
			    				;  and finish the nlz counting,
	JUMP	mul_nlz_counting_done
mul_got_nlz_8_s2:
	ADD		sA, 0x08				; Add 8 nlz to sA
	LOAD	s8, s2
	CALL 	count_nlz			; RETs number of zeros in s9
	COMP 	s9, 0x08
	JUMP 	Z, mul_got_nlz_8_s1
	ADD		sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
			    				;  and finish the nlz counting,
	JUMP	mul_nlz_counting_done
mul_got_nlz_8_s1:
	ADD		sA, 0x08				; Add 8 nlz to sA
	LOAD	s8, s1
	CALL 	count_nlz			; RETs number of zeros in s9
	COMP 	s9, 0x08
	JUMP 	Z, mul_got_nlz_8_s0
	ADD		sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
			    				;  and finish the nlz counting,
	JUMP	mul_nlz_counting_done
mul_got_nlz_8_s0:
	ADD		sA, 0x08				; Add 8 nlz to sA
	LOAD	s8, s0
	CALL 	count_nlz			; RETs number of zeros in s9
	ADD		sA, s9				; Less than 8 zeros, Add the counted nlz to sA 
			    				;  and finish the nlz counting,
mul_nlz_counting_done:
	; Shift the significand to left by nlz(sA) bits.
	LOAD s9, sA			; Copy the sA
	; At this point result mantisa is in [s7, s6, ..., s1] 				
mul_intermediate_shift_riht_loop:
	SL0  s0				; 1-bit left shift		
	ROLC s1						
	ROLC s2		
	ROLC s3		
	ROLC s4		
	ROLC s5		
	ROLC s6		
	ROLC s7
	SUB s9, 0x01
	JUMP NZ, mul_intermediate_shift_riht_loop
	RET

mul_normalize_mx:
	; Load mx into registers
	RDMEM 	s6, x_m6
	; Check if the significant is already normalized or not
	TEST	s6, 0x10
	JUMP	NZ,	already_normalized				
	; Significand is not normalized so normalize it.
	; Continue loading mx into registers
	RDMEM 	s5, x_m5
	RDMEM 	s4, x_m4
	RDMEM 	s3, x_m3
	RDMEM 	s2, x_m2
	RDMEM 	s1, x_m1
	RDMEM 	s0, x_m0
	CALL 	mul_cancellation		; return sA = number of bits shifted to left
	WRMEM 	s6, x_m6
	WRMEM 	s5, x_m5
	WRMEM 	s4, x_m4
	WRMEM 	s3, x_m3
	WRMEM 	s2, x_m2
	WRMEM 	s1, x_m1
	WRMEM 	s0, x_m0
	; Subtract exponent by sA
	RDMEM	sE, x_ex6
	RDMEM	sF, x_ex7
	SUB		sE, sA
	SUBC	sF, 0x00
	WRMEM	sE, x_ex6
	WRMEM	sF, x_ex7	
already_normalized:	
	RET	
	
mul_normalize_my:
	; Load mx into registers
	RDMEM 	s6, y_m6
	; Check if the significant is already normalized or not
	TEST	s6, 0x10
	JUMP	NZ,	already_normalized_y			
	; Significand is not normalized so normalize it.
	; Continue loading mx into registers
	RDMEM 	s5, y_m5
	RDMEM 	s4, y_m4
	RDMEM 	s3, y_m3
	RDMEM 	s2, y_m2
	RDMEM 	s1, y_m1
	RDMEM 	s0, y_m0
	CALL 	mul_cancellation		; return sA = number of bits shifted to left
	WRMEM 	s6, y_m6
	WRMEM 	s5, y_m5
	WRMEM 	s4, y_m4
	WRMEM 	s3, y_m3
	WRMEM 	s2, y_m2
	WRMEM 	s1, y_m1
	WRMEM 	s0, y_m0
	; Subtract exponent by sA
	RDMEM	sE, y_ex6
	RDMEM	sF, y_ex7
	SUB		sE, sA
	SUBC	sF, 0x00
	WRMEM	sE, y_ex6
	WRMEM	sF, y_ex7	
already_normalized_y:	
	RET		
	;-------------------------------------------------------------
	; s3 is lowest byte and s2 has guard bits
mul_round: 
	; -------------------------------------------------
	; Calculate the sticky bit
	TEST	s2, 0x10
	JUMP 	Z, dont_set_sticky_bit
	OR		s2, 0x20
dont_set_sticky_bit:
	; Rounding:
	; Check the guard bit - s0[7]
	TEST 	s2, 0x80
	JUMP 	NZ, mul_guard_bit_is_1
	; Gaurd bit = 0 : Round down (Do  nothing)
	JUMP 	mul_round_RET_zero
mul_guard_bit_is_1:
	; Gaurd bit = 1, Check the round bit
	TEST 	s2, 0x40 
	JUMP 	Z, mul_round_bit_is_0	
	; Gaurd bit = 1, Round bit = 1 : Round Up (add 1 to mantissa)
	JUMP 	mul_round_RET_one
mul_round_bit_is_0:
	; Gaurd bit = 1, Round bit = 0 : Check the Sticky bit
	TEST 	s2, 0x20
	JUMP 	NZ, mul_round_RET_one ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 1 : Round Up (add 1 to mantissa)
	; Gaurd bit = 1, Round bit = 0 , Sticky bit = 0 : Round to nearest even,
	;       Means round up if bit before Guard bit is 1, else round down.
	TEST 	s3, 0x01
	JUMP 	Z, mul_round_RET_zero
mul_round_RET_one:
    ADD 		s3, 0x01	
mul_round_RET_zero:
    RET	
    
;-----------------------------------------------------------------------------------
; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
;
;	beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
;
;------------------------------------------------------------------------------------
; Procedure:			arith_div_x_y()
;
; Registers Used:	Bank0 : All
;					Bank1 : None		
;		
; Arguments:			Bank0 : 
;					Bank1 : None
;					SPM   : x = [x_7, x_6, ..., x_0]
;			      			y = [y_7, y_6, ..., y_0]						
;
; Calls:				set_ops_status
;					decompose_x
;					decompose_y
;					
;
; RETs:				None
; 
; RET Flags:			None
;
; Description:		Divides two 64-bit double-precision floating point numbers.
;------------------------------------------------------------------------------------
arith_div_x_y:
	CALL 	set_ops_status
	CALL 	decompose_x
	CALL 	decompose_y
	CALL 	div_special_cases
	COMP	sF, 0xFF
	JUMP	Z, done_dividing
	CALL 	mul_normalize_mx
	CALL 	mul_normalize_my
	; op1 and op2 both are normal	
	CALL 	div_mx_my		; result is in [Umr_6, Lmr_6]
	CALL	sub_Ex_Ey		; exponent of result in [s1, s0]
	JUMP	NC, no_sub_ex_ey_overflow
	LOAD	sC, 0x01			; Set flag
	JUMP	sub_ex_ey_overflow_done
no_sub_ex_ey_overflow:
	LOAD	sC, 0x00
sub_ex_ey_overflow_done:
	; Save the er
	WRMEM	s0, r_ex6
	WRMEM	s1, r_ex7
	; Check the result exponent
	;---------------------------------------------------------------
	; if er < 0 and er > -53 then result is subnormal, shift significand by er and set the er to zero
	; if er < 0 and er <= -53 then the result is zero (underflow).
	; if er = 0 then the result is subnormal but no shift is needed.	
	; if er > 0 then the result is normal.
	; if er > 0x7FE then the result is infinity.
	; -53 = 0xFFDD = - 0x0023
	; Read the mr [Umr_6 downto Lmr_6] (64-bits) 
div_result_not_inf:
	RDMEM	s7, Umr_6
	RDMEM	s6, Umr_5
	RDMEM	s5, Umr_4
	RDMEM	s4, Umr_3
	RDMEM	s3, Umr_2
	RDMEM	s2, Umr_1
	RDMEM	s1, Umr_0
	RDMEM	s0, Lmr_6		
	; Set the sticky bit
	LOAD	sE, 0x06			; Counter
	LOAD	sF, s0			; Copy s0
div_set_sticky_bit_loop:	
	SR0		sF
	JUMP	NC,	dont_turn_sticky_bit_on
	OR		s0, 0x20			; Turn sticky bit on
dont_turn_sticky_bit_on:	
	SUB		sE, 0x01
	JUMP	NZ, div_set_sticky_bit_loop
	RDMEM	sB, r_ex7
	RDMEM	sA, r_ex6
	TEST	sB, 0x80
	JUMP	Z,	div_check_overflow		; Normal case, so skip all subnormal tests, and check compose result if there is no overflow
	; Here we are sure that the er is negative 	
	XOR		sB, 0xFF		; Find the twos's complement of er
	XOR		sA, 0xFF
	ADD		sA, 0x01
	ADDC	sB, 0x00
	COMP 	sA, 0x34
	COMPC	sB, 0x00
	JUMP	Z, div_result_is_zero	; er = -53, underflow
	JUMP 	C, div_er_greater_than_53	; er > -53, subnormal
	JUMP	div_result_is_zero		; er < -53. underflow
div_er_greater_than_53:	
div_keep_shifting_mr_to_right:
	SR0		s7
	RORC	s6
	RORC	s5	
	RORC	s4	
	RORC	s3	
	RORC	s2	
	RORC	s1
	RORC	s0
	SUB		sA, 0x01
	SUBC	sB, 0x00
	JUMP	NZ, div_keep_shifting_mr_to_right
	; Here [sB, sA] must be zero
	; Save the er
	WRMEM	sA, r_ex6
	WRMEM	sB, r_ex7
	JUMP	div_dont_shift_mr_left_subnormal
 div_check_overflow:	
	; exponent is in [sB, sA], check if result exp. > 0x7FF? 
	COMP 	sA, 0xFF
	COMPC	sB, 0x07
	JUMP	Z, div_compose_result
	JUMP	C, div_compose_result	 	
	; Overflow
	JUMP 	return_inf
div_compose_result:	
	; Significance now is in [s7, s0] with these structure:
	;		s6       _ s5,...,s1 _ 
	;		hsss_ssss_  ss...ss  _ ssss_sggg
	; h means hidden bit, s means significance, g means three guard bits
	; Check Bit 53, if it is 0 we have to shift left by 1 otherwise don't do anything
	TEST	s7, 0x80
	JUMP	NZ, div_dont_shift_mr_left
	SL0		s0
	ROLC	s1
	ROLC	s2
	ROLC	s3
	ROLC	s4
	ROLC	s5
	ROLC	s6
	ROLC	s7
	; Load the er
	RDMEM	sE, r_ex6
	RDMEM	sF, r_ex7
	SUB		sE, 0x01
	SUBC	sF, 0x00
	; Save the er
	WRMEM	sE, r_ex6
	WRMEM	sF, r_ex7
	JUMP	div_dont_shift_mr_left
div_dont_shift_mr_left_subnormal:	
	SR0		s7
	RORC	s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0
div_dont_shift_mr_left:
	; now the significance is [s7 downto s1] with following pattern:
	; s7		s6,...,s2 s1
	; xsss ssss
	; shift to right by 3 
	SR0		s7
	RORC	s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0
	SR0		s7
	RORC	s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0	
	SR0		s7
	RORC	s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0
	TEST	sC, 0x01
	JUMP 	Z, div_no_exp_overflow_detected
	COMP 	sA, 0x00
	COMPC	sB, 0x00
	JUMP	NZ, div_no_exp_overflow_detected
	SR0		s7
	RORC	s6
	RORC	s5
	RORC	s4
	RORC	s3
	RORC	s2
	RORC	s1
	RORC	s0
div_no_exp_overflow_detected:	
	; Now significance is in [s7, s1]
	AND		s7, 0x0F	
	; Round	the significance s1 lowest byte, s0 has guard bits.
	CALL	div_round
	; Propogate the carry produced by possible rounding
	ADDC	s2, 0x00
	ADDC	s3, 0x00
	ADDC	s4, 0x00
	ADDC	s5, 0x00
	ADDC	s6, 0x00	
	ADDC	s7, 0x00	
	; Load the er
	RDMEM	sE, r_ex6
	RDMEM	sF, r_ex7
	; Compose the result
	; Combine exponent [sF, sE] and significand [s6, ..., s0]
	; Shift exponent to left by 4
	SL0		sE
	ROLC	sF
	SL0		sE
	ROLC	sF
	SL0		sE
	ROLC	sF
	SL0		sE
	ROLC	sF
	; Combine the exponent with significand
	OR		sE, s7
	; Calculate the sign
	RDMEM	sB,	x_sign
	RDMEM	sA,	y_sign
	XOR		sB, sA			; Calculate the sign
	AND		sB, 0x80	
	OR		sF, sB			; Apply the sign
	; Save the result in SMP
	WRMEM 	s1, r_0
	WRMEM 	s2, r_1
	WRMEM 	s3, r_2
	WRMEM 	s4, r_3
	WRMEM 	s5, r_4
	WRMEM 	s6, r_5
	WRMEM 	sE, r_6 
	WRMEM 	sF, r_7	
	jump	done_dividing	
div_result_is_zero:
	CALL	return_zero_mul	
done_dividing:	
	RET
    
;------------------------------------------------------------------------------------
; Procedure:			div_special_cases()
;
; Registers Used:	Bank0 : s1, s2
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;			      			
;
; Calls:				
;
; RETs:				Bank1: [s1. s0]
; 
; RET Flags:			None
;
; Description:		Takes care of special operands in division.
;					Return 0xFF in sF if one of the operands is special.
;					If sF is 0xFF then the result is already in [r_7, r_8] in SPM.
;------------------------------------------------------------------------------------	
div_special_cases:
	RDMEM 	s1, op1_status	; read the ops status
	RDMEM 	s2, op2_status	; read the ops status
	; We check op1 for 
	; 1) NaN
	;		Yes:	return X_NaN	
	;		No:		Go to step 2.
	; 2) Infinity
	;		Yes:	Check op2, if +0 and NaN then return_NaN_Inf
	;		No:		return +infinity
	; 3) Zero
	;		Yes:	check if op2 is +inf or NaN then return_NaN_Inf
	;				 else return 0
	;		No:		check op2
	;-----------------------------------------------
	; Check if op1 is NaN
	TEST	s1, 0x10
	JUMP	Z, div_final_op1_not_NaN		; No
div_final_op1_NaN:						; Yes
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP 	NZ, return_xy_NAN	; Yes
	JUMP	return_x_NAN
div_final_op1_not_NaN:
	; Check if op1 is Inf
	TEST	s1, 0x20
	JUMP	Z, div_final_op1_not_Inf		; No
div_final_op1_Inf:						; Yes
	; Check if op2 is zero
	TEST	s2, 0x40
	JUMP	NZ, return_pos_inf			; Yes
	; Check if op2 is Inf
	TEST	s2, 0x20
	JUMP	NZ, div_return_NAN				; Yes
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN				; Yes
	JUMP	return_x_Inf		
div_final_op1_not_Inf:	
	; Check if op1 is zero
	TEST	s1, 0x40
	JUMP	Z, div_check_final_op2		; No
div_final_op1_is_zero:
	; Check if op2 is zero
	TEST	s2, 0x40
	JUMP	NZ, return_div_NAN				; Yes
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, return_y_NAN_positive		;Yes
	JUMP	return_zero_mul
div_check_final_op2:				; Here we are sure op1 is (sub)normal
	; Check if op2 is NaN
	TEST	s2, 0x10
	JUMP	NZ, div_return_y_NAN_positive		;Yes
	JUMP	div_final_op2_not_NaN	
div_return_y_NAN_positive:
	; make y positive
	LOAD 	sE, 0x7F
	RDMEM	sD, y_7
	AND		sD, sE
	WRMEM	sD, y_7	
	JUMP	return_y_NAN
div_final_op2_not_NaN:					; No
	; Check if op2 is Infinity
	TEST	s2, 0x20
	JUMP	NZ, return_zero_mul			; Yes
	; Check if op2 is zero
	TEST	s2, 0x40
	JUMP	NZ, return_x_Inf				; Yes
	; Both operators are (sub)normal. Perform the multiplication.
	LOAD	sF, 0x00
	RET	
    
;------------------------------------------------------------------------------------
; Procedure:			div_mx_my()
;
; Registers Used:	Bank0 : All
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;					SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
;							y_m6, y_m5, ... y_m0	 (7-bytes)
;			      			
;
; Calls:				
;
; RETs:				Bank0: [s6 doento s0] is reminder
;					Bank1: [s6 downto s0] is Quotient
; 
; RET Flags:			None
;
; Description:		Divides two 53-bit double-precision floating point numbers.
;------------------------------------------------------------------------------------
div_mx_my:
	; Set quotient [s7, s0] to 0
	REGBANK B
	LOAD	s0, 0x00
	LOAD	s1, 0x00
	LOAD	s2, 0x00
	LOAD	s3, 0x00
	LOAD	s4, 0x00
	LOAD	s5, 0x00
	LOAD	s6, 0x00
	LOAD	s7, 0x00
	REGBANK A
	; Load mx: dividend
	LOAD	s7, 0x00
	RDMEM 	s6, x_m6
	RDMEM	s5, x_m5
	RDMEM 	s4, x_m4
	RDMEM 	s3, x_m3
	RDMEM 	s2, x_m2
	RDMEM 	s1, x_m1
	RDMEM 	s0, x_m0
	; Load my: divisor
	LOAD	sF, 0x00
	RDMEM 	sE, y_m6
	RDMEM	sD, y_m5
	RDMEM 	sC, y_m4
	RDMEM 	sB, y_m3
	RDMEM 	sA, y_m2
	RDMEM 	s9, y_m1
	RDMEM 	s8, y_m0
	REGBANK B
	LOAD	sF, 0x40			; This is the counter, we need to loop 64 times
	REGBANK A
compare_dividend:
	; Is dividend >= divisor ?
	COMP	s0, s8
	COMPC	s1, s9
	COMPC	s2, sA
	COMPC	s3, sB
	COMPC	s4, sC
	COMPC	s5, sD
	COMPC	s6, sE
	COMPC	s7, sF
	JUMP	C, dividend_is_less
	; dividend is greateror than divisor
	; mx - my
	SUB		s0, s8
	SUBC	s1, s9
	SUBC	s2, sA
	SUBC	s3, sB
	SUBC	s4, sC
	SUBC	s5, sD
	SUBC	s6, sE
	SUBC	s7, sF
	; Append 1 to quotient
	REGBANK	B
	SL1		s0
	ROLC	s1
	ROLC	s2	 
	ROLC	s3	 
	ROLC	s4	 
	ROLC	s5	 
	ROLC	s6	 
	ROLC	s7	 
	REGBANK A
	JUMP	shift_dividend_left
dividend_is_less:	
	; Append 0 to quotient
	REGBANK	B
	SL0		s0
	ROLC	s1	 
	ROLC	s2	 
	ROLC	s3	 
	ROLC	s4	 
	ROLC	s5	 
	ROLC	s6	
	ROLC	s7	 
	REGBANK A
shift_dividend_left:		
	; Shift mx (dividend) to left by 1
	SL0		s0
	ROLC	s1
	ROLC	s2
	ROLC	s3
	ROLC	s4
	ROLC	s5
	ROLC	s6
	ROLC	s7
	REGBANK	B
	SUB		sF, 0x01		; Decrement the counter
	REGBANK	A
	JUMP	NZ, compare_dividend
div_finished:
	REGBANK	B
	WRMEM	s7, Umr_6 
	WRMEM	s6, Umr_5 
	WRMEM	s5, Umr_4 
	WRMEM	s4, Umr_3 
	WRMEM	s3, Umr_2 
	WRMEM	s2, Umr_1 
	WRMEM	s1, Umr_0
	WRMEM	s0, Lmr_6
	REGBANK A 
	RET
    
;------------------------------------------------------------------------------------
; Procedure:			sub_Ex_Ey()
;
; Registers Used:	Bank0 : All
;					Bank1 : None		
;		
; Arguments:			Bank0 : None
;					Bank1 : None
;					SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
;							y_m6, y_m5, ... y_m0	 (7-bytes)
;			      			
;
; Calls:				
;
; RETs:				Bank1: [s1. s0]
; 
; RET Flags:			None
;
; Description:		Calculates the ex + ey which is Ex + Ey - bias(1023) and returns
;						the result in [s1, s0].
;------------------------------------------------------------------------------------
sub_Ex_Ey:	
	; Read ex
	RDMEM 	s1, x_ex7
	RDMEM 	s0, x_ex6
	; if op1 is subnormal then subtract by 1022 else subtract by  1023
	RDMEM	sF, op1_status
	TEST	sF, 0x80
	JUMP	NZ,	sub_subnormal_exponent_detected
	; Subtract by 1023
	SUB		s0, 0xFF
	SUBC	s1,	0x03		
	JUMP	sub_done_exponent_subtracting
sub_subnormal_exponent_detected:			
	; Subtract by 1022
	SUB		s0, 0xFE
	SUBC	s1,	0x03		
sub_done_exponent_subtracting:	
	; Read ey
	RDMEM 	s3, y_ex7
	RDMEM 	s2, y_ex6
	; if [s1, s0] == zero then subtract 1022 else subtract 1023
	RDMEM	sF, op2_status
	TEST	sF, 0x80
	JUMP	NZ,	sub_subnormal_exponent_detected_y
	; Subtract by 1023
	SUB		s2, 0xFF
	SUBC	s3,	0x03		
	JUMP	sub_done_exponent_subtracting_y
sub_subnormal_exponent_detected_y:			
	; Subtract by 1022
	SUB		s2, 0xFE
	SUBC	s3,	0x03		
sub_done_exponent_subtracting_y:
	SUB		s0, s2
	SUBC	s1, s3
	ADD		s0, 0xFF			; subtract by 1023'd =  0x03FF
	ADDC	s1, 0x03
	RET
	
return_div_NAN:
	LOAD	sF, 0xFF
	LOAD	s7, 0x7F	       
	LOAD	s6, 0xF8	   
	LOAD 	s5, 0x00
	LOAD 	s4, 0x00
	LOAD 	s3, 0x00
	LOAD 	s2, 0x00
	LOAD 	s1, 0x00
	LOAD 	s0, 0x00
	WRMEM 	s7, r_7
	WRMEM 	s6, r_6
	WRMEM 	s5, r_5
	WRMEM 	s4, r_4
	WRMEM 	s3, r_3
	WRMEM 	s2, r_2
	WRMEM 	s1, r_1
	WRMEM 	s0, r_0
	RET	
	
	;-------------------------------------------------------------
	; s1 has the lowest byte, and s0 has the guard bits
div_round: 
	; -------------------------------------------------
	; Calculate the sticky bit
	; Check the guard bit - s0[7]
	TEST 	s0, 0x80
	JUMP 	NZ, div_guard_bit_is_1
	; Gaurd bit = 0 : Round down (Do  nothing)
	JUMP 	div_round_RET_zero
div_guard_bit_is_1:
	; Gaurd bit = 1, Check the round bit
	TEST 	s0, 0x40
	JUMP 	Z, div_round_bit_is_0	
	; Gaurd bit = 1, Round bit = 1 : Round Up (add 1 to mantissa)
	JUMP 	div_round_RET_one
div_round_bit_is_0:
	; Gaurd bit = 1, Round bit = 0 : Check the Sticky bit
	TEST 	s0, 0x20
	JUMP 	NZ, div_round_RET_one ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 1 : Round Up (add 1 to mantissa)
	; Gaurd bit = 1, Round bit = 0 , Sticky bit = 0 : Round to nearest even,
	;       Means round up if bit before Guard bit is 1, else round down.
	;TEST 	s1, 0x01
	;JUMP 	Z, div_round_RET_zero
div_round_RET_one:
    ADD 		s1, 0x01
div_round_RET_zero:
    RET		
    
return_inf:
	LOAD 	sF, 0xFF			; Signal the caller that the operation is complete.
	; Calculate the sign
	RDMEM	sB,	x_sign
	RDMEM	sA,	y_sign
	XOR		sB, sA			; Calculate the sign
	AND		sB, 0x80	
	LOAD	s2,	0x7F
	OR		s2, sB			; Apply the sign
	LOAD	s1,	0xF0
	LOAD	s0, 0x00      
	WRMEM 	s2, r_7
	WRMEM 	s1, r_6
	WRMEM 	s0, r_5
	WRMEM 	s0, r_4
	WRMEM 	s0, r_3
	WRMEM 	s0, r_2
	WRMEM 	s0, r_1
	WRMEM 	s0, r_0	
	RET    

div_return_NAN:
	LOAD 	sF, 0xFF			; Signal the caller that the operation is complete.
	; Calculate the sign
	RDMEM	sB,	x_sign
	RDMEM	sA,	y_sign
	XOR		sB, sA			; Calculate the sign
	AND		sB, 0x80	
	LOAD	s2,	0x7F
	;OR		s2, sB			; Apply the sign
	LOAD	s1,	0xF8
	LOAD	s0, 0x00      
	WRMEM 	s2, r_7
	WRMEM 	s1, r_6
	WRMEM 	s0, r_5
	WRMEM 	s0, r_4
	WRMEM 	s0, r_3
	WRMEM 	s0, r_2
	WRMEM 	s0, r_1
	WRMEM 	s0, r_0	
	RET	
    