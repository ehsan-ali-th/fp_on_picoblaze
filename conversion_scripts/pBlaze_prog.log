KCPSM6 Assembler log file for program 'Z:\home\esi\workspace\pico_blaze_conversion\pBlaze_prog.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 03 Mar 2019
Assembly timestamp: 02:07:34

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 82E hex
Nominal program memory size: 4K (4096)   address(11:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 2095
Memory locations available: 2001


Assembly listing

 Addr Code                                      Instruction

 000                                            CONSTANT UART_Tx_data_present, 00000001'b
 000                                            CONSTANT UART_Tx_half_full, 00000010'b
 000                                            CONSTANT UART_Tx_full, 00000100'b
 000                                            CONSTANT UART_Rx_data_present, 00001000'b
 000                                            CONSTANT UART_Rx_half_full, 00010000'b
 000                                            CONSTANT UART_Rx_full, 00100000'b
 000                                            ; Input Ports
 000                                            CONSTANT UART_RX6_status_input_port, 00
 000                                            CONSTANT UART_RX6_data_input_port, 01
 000                                            CONSTANT Extra_mem_input_port, 02
 000                                            ; Output Ports
 000                                            CONSTANT UART_TX6_output_port, 00
 000                                            CONSTANT Extra_mem_lo_output_port, 01
 000                                            CONSTANT Extra_mem_hi_output_port, 02
 000                                            CONSTANT Extra_mem_output_port, 03
 000                                            CONSTANT irqs_output_port, 04
 000                                            CONSTANT reset_UART_port, 01
 000                                            CONSTANT UART_tx_reset, 00000001'b
 000                                            CONSTANT UART_rx_reset, 00000010'b
 000                                            CONSTANT UART_reset, 00000011'b
 000                                            ;reset Tx and Rx
 000                                            CONSTANT UART_operate, 00000000'b               ; Tx and Rx free to operate
 000                                            ; Scratch Pad Memory locations
 000                                            CONSTANT x_7, 0'd                               ; Do not change the decimal numbers or load into SPM will not work
 000                                            CONSTANT x_6, 1'd
 000                                            CONSTANT x_5, 2'd
 000                                            CONSTANT x_4, 3'd
 000                                            CONSTANT x_3, 4'd
 000                                            CONSTANT x_2, 5'd
 000                                            CONSTANT x_1, 6'd
 000                                            CONSTANT x_0, 7'd
 000                                            CONSTANT y_7, 8'd
 000                                            CONSTANT y_6, 9'd
 000                                            CONSTANT y_5, 10'd
 000                                            CONSTANT y_4, 11'd
 000                                            CONSTANT y_3, 12'd
 000                                            CONSTANT y_2, 13'd
 000                                            CONSTANT y_1, 14'd
 000                                            CONSTANT y_0, 15'd
 000                                            CONSTANT r_7, 16'd
 000                                            CONSTANT r_6, 17'd
 000                                            CONSTANT r_5, 18'd
 000                                            CONSTANT r_4, 19'd
 000                                            CONSTANT r_3, 20'd
 000                                            CONSTANT r_2, 21'd
 000                                            CONSTANT r_1, 22'd
 000                                            CONSTANT r_0, 23'd
 000                                            CONSTANT x_sign, 24'd                           ; positive = 0x00, negative = 0x80
 000                                            CONSTANT x_ex7, 25'd
 000                                            CONSTANT x_ex6, 26'd
 000                                            CONSTANT x_m6, 27'd
 000                                            CONSTANT x_m5, 28'd
 000                                            CONSTANT x_m4, 29'd
 000                                            CONSTANT x_m3, 30'd
 000                                            CONSTANT x_m2, 31'd
 000                                            CONSTANT x_m1, 32'd
 000                                            CONSTANT x_m0, 33'd
 000                                            CONSTANT x_grs, 34'd                            ; 8-bit: grs0_0000
 000                                            CONSTANT y_sign, 35'd                           ; positive = 0x00, negative = 0x80
 000                                            CONSTANT y_ex7, 36'd
 000                                            CONSTANT y_ex6, 37'd
 000                                            CONSTANT y_m6, 38'd
 000                                            CONSTANT y_m5, 39'd
 000                                            CONSTANT y_m4, 40'd
 000                                            CONSTANT y_m3, 41'd
 000                                            CONSTANT y_m2, 42'd
 000                                            CONSTANT y_m1, 43'd
 000                                            CONSTANT y_m0, 44'd
 000                                            CONSTANT y_grs, 45'd                            ; 8-bit: grs0_0000
 000                                            CONSTANT r_sign, 46'd                           ; positive = 0x00, negative = 0x80
 000                                            CONSTANT r_ex7, 47'd
 000                                            CONSTANT r_ex6, 48'd
 000                                            CONSTANT r_m6, 49'd
 000                                            CONSTANT r_m5, 50'd
 000                                            CONSTANT r_m4, 51'd
 000                                            CONSTANT r_m3, 52'd
 000                                            CONSTANT r_m2, 53'd
 000                                            CONSTANT r_m1, 55'd
 000                                            CONSTANT r_m0, 56'd
 000                                            CONSTANT r_grs, 57'd                            ; 8-bit: grs0_0000
 000                                            ;----------------------------------------------------------------
 000                                            ; If a bit is 0 = no, 1 = yes
 000                                            ;
 000                                            ; Bit 7   6 5 4 3 2 1 0
 000                                            ;     |   | | |             |
 000                                            ;     |   | | |             [ Normal
 000                                            ;     |   | | [ NaN
 000                                            ;     |   | [ Infinite
 000                                            ;     |   [ Zero
 000                                            ;     [ Subnormal
 000                                            ;
 000                                            ;
 000                                            ; An operand can have one of the following statuses:
 000                                            ; 1)  Normal
 000                                            ; 2) Subnormal
 000                                            ; 3)  Zero +/-
 000                                            ; 4)  Infinit +/-
 000                                            ; 5)  NaN
 000                                            ;---------------------------------------------------------------
 000                                            CONSTANT op1_status, 58'd
 000                                            CONSTANT op2_status, 59'd
 000                                            CONSTANT underflow, 60'd                        ; underflow not applied = 0x00, underflow applied = 0x01
 000                                            ;----------------------------------------------------------------
 000                                            ; Bit 7   6  5 4 3 2 1 0
 000                                            ;     |   |  | | |
 000                                            ;     |   |  | | [Inexact
 000                                            ;     |   |  | [Underflow
 000                                            ;     |   |  [Overflow
 000                                            ;     |   [Division by zero
 000                                            ;     [Invalid Opration: Quite Not A Nuber (qNaN)
 000                                            ;
 000                                            ;
 000                                            ;---------------------------------------------------------------
 000                                            CONSTANT IEEE_754_DP_signals, 61'd
 000                                            CONSTANT Umr_6, 64'd                            ; 0x40 only two bits on right is used : 0b----_--XX
 000                                            CONSTANT Umr_5, 65'd
 000                                            CONSTANT Umr_4, 66'd
 000                                            CONSTANT Umr_3, 67'd
 000                                            CONSTANT Umr_2, 68'd
 000                                            CONSTANT Umr_1, 69'd
 000                                            CONSTANT Umr_0, 70'd
 000                                            CONSTANT Lmr_6, 71'd
 000                                            CONSTANT Lmr_5, 72'd
 000                                            CONSTANT Lmr_4, 73'd
 000                                            CONSTANT Lmr_3, 74'd
 000                                            CONSTANT Lmr_2, 75'd
 000                                            CONSTANT Lmr_1, 76'd
 000                                            CONSTANT Lmr_0, 77'd                            ; 0x4D
 000                                            CONSTANT mr_save_carry, 78'd                    ; 0x4E   0x00 = no carry, 0x01 = carry
 000                                            CONSTANT Umx_shifted_6, 80'd                    ; 0x50
 000                                            CONSTANT Umx_shifted_5, 81'd
 000                                            CONSTANT Umx_shifted_4, 82'd
 000                                            CONSTANT Umx_shifted_3, 83'd
 000                                            CONSTANT Umx_shifted_2, 84'd
 000                                            CONSTANT Umx_shifted_1, 85'd
 000                                            CONSTANT Umx_shifted_0, 86'd
 000                                            CONSTANT Lmx_shifted_6, 87'd
 000                                            CONSTANT Lmx_shifted_5, 88'd
 000                                            CONSTANT Lmx_shifted_4, 89'd
 000                                            CONSTANT Lmx_shifted_3, 90'd
 000                                            CONSTANT Lmx_shifted_2, 91'd
 000                                            CONSTANT Lmx_shifted_1, 92'd
 000                                            CONSTANT Lmx_shifted_0, 93'd                    ; 0x5D
 000  22004                                     JUMP 004[start]
 001  22004                                     JUMP 004[start]
 002  22004                                     JUMP 004[start]
 003  22004                                     JUMP 004[start]
 004                                     start: 
 004  2008B                                     CALL 08B[reset_UART_macros]
 005                                            ;      JUMP uart_loop
 005  01600                                     LOAD s6, 00                                     ; Start at address [s6,s5] = 0x000
 006  01500                                     LOAD s5, 00
 007  01800                                     LOAD s8, 00[x_7]                                ; Save at starting point = x_7
 008  200E3                                     CALL 0E3[load_8Bytes_from_ext_BRAM]
 009  01600                                     LOAD s6, 00                                     ; Start at address [s6,s5] = 0x008
 00A  01508                                     LOAD s5, 08
 00B  01808                                     LOAD s8, 08[y_7]                                ; Save at starting point = y_7
 00C  200E3                                     CALL 0E3[load_8Bytes_from_ext_BRAM]
 00D                                            ; Clear the operand status, as the SPM holds its previous values
 00D                                            ;  even after picoBlaze gets reset.
 00D  01000                                     LOAD s0, 00
 00E  2F022                                     STORE s0, 22[x_grs]
 00F  2F02D                                     STORE s0, 2D[y_grs]
 010  2F039                                     STORE s0, 39[r_grs]
 011  2F02E                                     STORE s0, 2E[r_sign]
 012  2F03A                                     STORE s0, 3A[op1_status]
 013  2F03B                                     STORE s0, 3B[op2_status]
 014  2F03C                                     STORE s0, 3C[underflow]
 015  2F040                                     STORE s0, 40[Umr_6]
 016  2F041                                     STORE s0, 41[Umr_5]
 017  2F042                                     STORE s0, 42[Umr_4]
 018  2F043                                     STORE s0, 43[Umr_3]
 019  2F044                                     STORE s0, 44[Umr_2]
 01A  2F045                                     STORE s0, 45[Umr_1]
 01B  2F046                                     STORE s0, 46[Umr_0]
 01C  2F047                                     STORE s0, 47[Lmr_6]
 01D  2F048                                     STORE s0, 48[Lmr_5]
 01E  2F049                                     STORE s0, 49[Lmr_4]
 01F  2F04A                                     STORE s0, 4A[Lmr_3]
 020  2F04B                                     STORE s0, 4B[Lmr_2]
 021  2F04C                                     STORE s0, 4C[Lmr_1]
 022  2F04D                                     STORE s0, 4D[Lmr_0]
 023  2F04E                                     STORE s0, 4E[mr_save_carry]
 024  2F050                                     STORE s0, 50[Umx_shifted_6]
 025  2F051                                     STORE s0, 51[Umx_shifted_5]
 026  2F052                                     STORE s0, 52[Umx_shifted_4]
 027  2F053                                     STORE s0, 53[Umx_shifted_3]
 028  2F054                                     STORE s0, 54[Umx_shifted_2]
 029  2F055                                     STORE s0, 55[Umx_shifted_1]
 02A  2F056                                     STORE s0, 56[Umx_shifted_0]
 02B  2F057                                     STORE s0, 57[Lmx_shifted_6]
 02C  2F058                                     STORE s0, 58[Lmx_shifted_5]
 02D  2F059                                     STORE s0, 59[Lmx_shifted_4]
 02E  2F05A                                     STORE s0, 5A[Lmx_shifted_3]
 02F  2F05B                                     STORE s0, 5B[Lmx_shifted_2]
 030  2F05C                                     STORE s0, 5C[Lmx_shifted_1]
 031  2F05D                                     STORE s0, 5D[Lmx_shifted_0]
 032                                            ; Load configuration at address 0xFFC
 032  015FC                                     LOAD s5, FC
 033  0160F                                     LOAD s6, 0F
 034  200ED                                     CALL 0ED[Read_ext_mem]                          ; config byte will be  returned in s7
 035  0D701                                     TEST s7, 01
 036  3603B                                     JUMP NZ, 03B[debug_mode]
 037  206B8                                     CALL 6B8[arith_div_x_y]
 038                                            ;       CALL  arith_add_x_y
 038                                            ;       CALL arith_mul_x_y
 038  20108                                     CALL 108[write_result_to_external_memory]
 039  200FD                                     CALL 0FD[invoke_done_interrupt]
 03A                      finished_calculation: 
 03A  2203A                                     JUMP 03A[finished_calculation]
 03B                                debug_mode: 
 03B  200A0                                     CALL 0A0[clear_screen]
 03C                                            ;       CALL  arith_add_x_y
 03C  2048E                                     CALL 48E[arith_mul_x_y]
 03D  20108                                     CALL 108[write_result_to_external_memory]
 03E  01B00                                     LOAD sB, 00[welcome_msg'upper]                  ;Display message
 03F  01A53                                     LOAD sA, 53[welcome_msg'lower]
 040  20099                                     CALL 099[send_message]
 041  20094                                     CALL 094[send_CRLF]
 042                        print_two_operands: 
 042  01900                                     LOAD s9, 00[x_7]
 043  200C5                                     CALL 0C5[SPM_print_hex]
 044  20094                                     CALL 094[send_CRLF]
 045  01908                                     LOAD s9, 08[y_7]
 046  200C5                                     CALL 0C5[SPM_print_hex]
 047  20094                                     CALL 094[send_CRLF]
 048  01910                                     LOAD s9, 10[r_7]
 049  200C5                                     CALL 0C5[SPM_print_hex]
 04A  20094                                     CALL 094[send_CRLF]
 04B  200FD                                     CALL 0FD[invoke_done_interrupt]
 04C                            wait_for_start: 
 04C  20082                                     CALL 082[UART_RX]
 04D  3204C                                     JUMP Z, 04C[wait_for_start]                     ;check for UART timeout
 04E  1D553                                     COMPARE s5, 53["S"]                             ;test character received
 04F  32042                                     JUMP Z, 042[print_two_operands]
 050  1D573                                     COMPARE s5, 73["s"]
 051  3604C                                     JUMP NZ, 04C[wait_for_start]
 052  22042                                     JUMP 042[print_two_operands]
 053                                            STRING welcome$, "Welcome to KCPSM6 !!! (Debug Mode)"
 053                               welcome_msg: 
 053  2150D                                     LOAD&RETURN s5, 0D[CR]
 054  2150A                                     LOAD&RETURN s5, 0A[LF]
 055  21557                                     LOAD&RETURN s5, 57[welcome$:"W"]
 056  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 057  2156C                                     LOAD&RETURN s5, 6C[welcome$:"l"]
 058  21563                                     LOAD&RETURN s5, 63[welcome$:"c"]
 059  2156F                                     LOAD&RETURN s5, 6F[welcome$:"o"]
 05A  2156D                                     LOAD&RETURN s5, 6D[welcome$:"m"]
 05B  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 05C  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 05D  21574                                     LOAD&RETURN s5, 74[welcome$:"t"]
 05E  2156F                                     LOAD&RETURN s5, 6F[welcome$:"o"]
 05F  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 060  2154B                                     LOAD&RETURN s5, 4B[welcome$:"K"]
 061  21543                                     LOAD&RETURN s5, 43[welcome$:"C"]
 062  21550                                     LOAD&RETURN s5, 50[welcome$:"P"]
 063  21553                                     LOAD&RETURN s5, 53[welcome$:"S"]
 064  2154D                                     LOAD&RETURN s5, 4D[welcome$:"M"]
 065  21536                                     LOAD&RETURN s5, 36[welcome$:"6"]
 066  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 067  21521                                     LOAD&RETURN s5, 21[welcome$:"!"]
 068  21521                                     LOAD&RETURN s5, 21[welcome$:"!"]
 069  21521                                     LOAD&RETURN s5, 21[welcome$:"!"]
 06A  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 06B  21528                                     LOAD&RETURN s5, 28[welcome$:"("]
 06C  21544                                     LOAD&RETURN s5, 44[welcome$:"D"]
 06D  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 06E  21562                                     LOAD&RETURN s5, 62[welcome$:"b"]
 06F  21575                                     LOAD&RETURN s5, 75[welcome$:"u"]
 070  21567                                     LOAD&RETURN s5, 67[welcome$:"g"]
 071  21520                                     LOAD&RETURN s5, 20[welcome$:" "]
 072  2154D                                     LOAD&RETURN s5, 4D[welcome$:"M"]
 073  2156F                                     LOAD&RETURN s5, 6F[welcome$:"o"]
 074  21564                                     LOAD&RETURN s5, 64[welcome$:"d"]
 075  21565                                     LOAD&RETURN s5, 65[welcome$:"e"]
 076  21529                                     LOAD&RETURN s5, 29[welcome$:")"]
 077  21500                                     LOAD&RETURN s5, 00[NUL]
 078                                            ;------------------------------------------------------------------------------------
 078                                            ; Procedure:  UART_TX()
 078                                            ; Registers Used:
 078                                            ;        Bank0 : s6 , s5
 078                                            ;   Bank1 : None
 078                                            ;
 078                                            ; Arguments:
 078                                            ;    Bank0 : None
 078                                            ;   Bank1 : None
 078                                            ;
 078                                            ; Calls:  delay_1ms
 078                                            ;
 078                                            ; Returns:  None
 078                                            ;
 078                                            ; Return Flags:  None
 078                                            ;
 078                                            ; Description:  Routine to send one character to the UART Transmitter (UART_TX6)
 078                                            ;
 078                                            ; This routine will transmit the character provided in register 's5'.
 078                                            ;------------------------------------------------------------------------------------
 078                                   UART_TX: 
 078  09600                                     INPUT s6, 00[UART_RX6_status_input_port]
 079  0D604                                     TEST s6, 04[UART_Tx_full]
 07A  36078                                     JUMP NZ, 078[UART_TX]
 07B  2D500                                     OUTPUT s5, 00[UART_TX6_output_port]
 07C                                            ; We need a bit of delay here: 10240 cycles : 2800 hex
 07C                                            ; ((6 x 1us_delay_count]) + 8) clock cycles.
 07C                                            ;   ; 100Mhz => 1us = 100,000 cycles
 07C                                            ;    We need 16,665 cycles = 4119 hex
 07C  01519                                     LOAD s5, 19
 07D  01641                                     LOAD s6, 41
 07E                             UART_TX_delay: 
 07E  19501                                     SUB s5, 01
 07F  1B600                                     SUBCY s6, 00
 080  3607E                                     JUMP NZ, 07E[UART_TX_delay]
 081  25000                                     RETURN 
 082                                            ;------------------------------------------------------------------------------------
 082                                            ; Procedure:  UART_RX()
 082                                            ; Registers Used:
 082                                            ;        Bank0 : s7, s6 , s5
 082                                            ;   Bank1 : None
 082                                            ;
 082                                            ; Arguments:
 082                                            ;    Bank0 : None
 082                                            ;   Bank1 : None
 082                                            ;
 082                                            ; Calls:  None
 082                                            ;
 082                                            ; Returns:  s5 (character read)
 082                                            ;
 082                                            ; Return Flags:  Zero flag will be reset (Z=0) if read is successful.
 082                                            ;
 082                                            ; Description:  Routine to attempt to receive one character from the UART
 082                                            ;    Receiver 'uart_rx6'.
 082                                            ;
 082                                            ; This routine will attempt to receive one character from the 'UART_RX6' macro, and if
 082                                            ; successful, will return that character in register 's5' and the Zero flag will be
 082                                            ; reset (Z=0).
 082                                            ;
 082                                            ; If there are no characters available to be read from the FIFO buffer within the
 082                                            ; 'UART_RX6' macro then this routine will timeout after ~2,000 clock cycles (which is
 082                                            ; 40us at 50MHz) with the Zero flag set (Z=1). This timeout scheme ensures that KCPSM6
 082                                            ; cannot become stuck in this routine if no characters are received. If you do want
 082                                            ; KCPSM6 to wait indefinitely for a character to be received then either modify this
 082                                            ; routine or perform a test of the Zero flag and repeat the call to this routine as
 082                                            ; shown in this example...
 082                                            ;
 082                                            ;          wait_for_UART_RX: CALL UART_RX
 082                                            ;                            JUMP Z, wait_for_UART_RX
 082                                            ;------------------------------------------------------------------------------------
 082                                   UART_RX: 
 082  017A7                                     LOAD s7, A7[167'd]                              ;Timeout =
 083                                            ;167 x (6 instructions x 2 clock cycles)
 083                                rx_timeout: 
 083  09600                                     INPUT s6, 00[UART_RX6_status_input_port]
 084  0D608                                     TEST s6, 08[UART_Rx_data_present]               ;Z=0 and C=1 when data present
 085  36089                                     JUMP NZ, 089[read_Rx]
 086  19701                                     SUB s7, 01[1'd]
 087  31000                                     RETURN Z                                        ;Timeout returns with Z=1 and C=0
 088  22083                                     JUMP 083[rx_timeout]
 089  09501                            read_Rx: INPUT s5, 01[UART_RX6_data_input_port]          ;read character from buffer
 08A  25000                                     RETURN 
 08B                                            ;------------------------------------------------------------------------------------
 08B                                            ; Procedure:  reset_UART_macros()
 08B                                            ; Registers Used:
 08B                                            ;        Bank0 : None
 08B                                            ;   Bank1 : None
 08B                                            ;
 08B                                            ; Arguments:
 08B                                            ;    Bank0 : None
 08B                                            ;   Bank1 : None
 08B                                            ;
 08B                                            ; Calls:  None
 08B                                            ;
 08B                                            ;
 08B                                            ; Description:  Resets UART.
 08B                                            ;
 08B                                            ;------------------------------------------------------------------------------------
 08B                         reset_UART_macros: 
 08B  2B031                                     OUTPUTK 03[UART_reset], 1[reset_UART_port]
 08C  2B001                                     OUTPUTK 00[UART_operate], 1[reset_UART_port]
 08D  25000                                     RETURN 
 08E                                            ;------------------------------------------------------------------------------------
 08E                                            ; Procedure:  delay_1ms()
 08E                                            ; Registers Used:
 08E                                            ;        Bank0 : s7, s6
 08E                                            ;   Bank1 : None
 08E                                            ;
 08E                                            ; Arguments:
 08E                                            ;    Bank0 : None
 08E                                            ;   Bank1 : None
 08E                                            ;
 08E                                            ; Calls:  None
 08E                                            ;
 08E                                            ;
 08E                                            ; Description:  1ms delay.
 08E                                            ;
 08E                                            ;   ((6 x 1ms_delay_count1]) + 8) clock cycles.
 08E                                            ;   ; 125Mhz => 1ms = 125,000 cycles
 08E                                            ;    We need 20,832 cycles = 5160 hex
 08E                                            ;------------------------------------------------------------------------------------
 08E                                 delay_1ms: 
 08E  01660                                     LOAD s6, 60
 08F  01751                                     LOAD s7, 51
 090                            delay_1ms_loop: 
 090  19601                                     SUB s6, 01
 091  1B700                                     SUBCY s7, 00
 092  36090                                     JUMP NZ, 090[delay_1ms_loop]
 093  25000                                     RETURN 
 094                                            ;------------------------------------------------------------------------------------
 094                                            ; Procedure:  send_CRLF()
 094                                            ; Registers Used:
 094                                            ;        Bank0 : s5
 094                                            ;   Bank1 : None
 094                                            ;
 094                                            ; Arguments:
 094                                            ;    Bank0 : None
 094                                            ;   Bank1 : None
 094                                            ;
 094                                            ; Calls:  UART_TX()
 094                                            ;
 094                                            ;
 094                                            ; Description:  Sends a CRLF to the UART.
 094                                            ;
 094                                            ;------------------------------------------------------------------------------------
 094                                 send_CRLF: 
 094  0150D                                     LOAD s5, 0D[CR]
 095  20078                                     CALL 078[UART_TX]
 096  0150A                                     LOAD s5, 0A[LF]
 097  20078                                     CALL 078[UART_TX]
 098  25000                                     RETURN 
 099                                            ;------------------------------------------------------------------------------------
 099                                            ; Procedure:  send_message()
 099                                            ; Registers Used:
 099                                            ;        Bank0 : s5, sA, sB
 099                                            ;   Bank1 : None
 099                                            ;
 099                                            ; Arguments:
 099                                            ;    Bank0 : None
 099                                            ;   Bank1 : None
 099                                            ;
 099                                            ; Calls:  UART_TX()
 099                                            ;
 099                                            ;
 099                                            ; Description:  Sends a message to the UART.
 099                                            ;
 099                                            ;   The start address of the message must be provided in [sB,sA].
 099                                            ;    Terminate the transmission with a NULL character (00 hex).
 099                                            ;------------------------------------------------------------------------------------
 099                              send_message: 
 099  24BA0                                     CALL@ (sB, sA)
 09A  1D500                                     COMPARE s5, 00                                  ;terminate on NUL character
 09B  31000                                     RETURN Z
 09C  20078                                     CALL 078[UART_TX]
 09D  11A01                                     ADD sA, 01[1'd]
 09E  13B00                                     ADDCY sB, 00[0'd]
 09F  22099                                     JUMP 099[send_message]
 0A0                                            ;------------------------------------------------------------------------------------
 0A0                                            ; Procedure:  clear_screen()
 0A0                                            ; Registers Used:
 0A0                                            ;        Bank0 : s5
 0A0                                            ;   Bank1 : None
 0A0                                            ;
 0A0                                            ; Arguments:
 0A0                                            ;    Bank0 : None
 0A0                                            ;   Bank1 : None
 0A0                                            ;
 0A0                                            ; Calls:  UART_TX()
 0A0                                            ;
 0A0                                            ; Description:  Clears the UART screen.
 0A0                                            ;------------------------------------------------------------------------------------
 0A0                              clear_screen: 
 0A0  0151B                                     LOAD s5, 1B[ESC]                                ;clear terminal sequence
 0A1  20078                                     CALL 078[UART_TX]
 0A2  0155B                                     LOAD s5, 5B["["]
 0A3  20078                                     CALL 078[UART_TX]
 0A4  01532                                     LOAD s5, 32["2"]
 0A5  20078                                     CALL 078[UART_TX]
 0A6  0154A                                     LOAD s5, 4A["J"]
 0A7  20078                                     CALL 078[UART_TX]
 0A8  0151B                                     LOAD s5, 1B[ESC]
 0A9  20078                                     CALL 078[UART_TX]
 0AA  0155B                                     LOAD s5, 5B["["]
 0AB  20078                                     CALL 078[UART_TX]
 0AC  01548                                     LOAD s5, 48["H"]
 0AD  20078                                     CALL 078[UART_TX]
 0AE  25000                                     RETURN 
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                                            ; Procedure:  print_hex_from_table()
 0AF                                            ; Registers Used:
 0AF                                            ;        Bank0 : sB, sA, s8, s7 , s5
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Arguments:
 0AF                                            ;    Bank0 : [sB, sA] :Message upper/lower address
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Calls:  UART_TX (s6, s5)
 0AF                                            ;
 0AF                                            ; Returns:  None
 0AF                                            ;
 0AF                                            ; Return Flags:  None
 0AF                                            ;
 0AF                                            ; Description:  Prints a 64-bit double precision number.
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                                            ; print_hex_from_table:
 0AF                                            ;  LOAD s8, 8'd  ; Double precision has 8 bytes
 0AF                                            ; print_hex_loop:
 0AF                                            ;  CALL@ (sB, sA)  ; read the first byte in s5
 0AF                                            ;  LOAD s7, s5  ; Copy s5
 0AF                                            ;  SR0 s5      ; shift the 4 bit on he left to the right
 0AF                                            ;  SR0 s5
 0AF                                            ;  SR0 s5
 0AF                                            ;  SR0 s5
 0AF                                            ;  COMPARE s5, 10'd
 0AF                                            ;  JUMP C, less_or_eq_to_nine
 0AF                                            ;  JUMP greater_than_nine
 0AF                                            ; less_or_eq_to_nine:
 0AF                                            ;  ADD s5, 48'd
 0AF                                            ;  JUMP done_adding
 0AF                                            ; greater_than_nine:
 0AF                                            ;  ADD s5, 87'd
 0AF                                            ; done_adding:
 0AF                                            ;  CALL UART_TX  ; send it to UART via s5
 0AF                                            ;  ;--- Second nibble
 0AF                                            ;  AND s7, 0f   ; select the 4 bit on the right
 0AF                                            ;  COMPARE s7, 10'd
 0AF                                            ;  JUMP C, less_or_eq_to_nine2
 0AF                                            ;  JUMP greater_than_nine2
 0AF                                            ; less_or_eq_to_nine2:
 0AF                                            ;  ADD s7, 48'd
 0AF                                            ;  JUMP done_adding2
 0AF                                            ; greater_than_nine2:
 0AF                                            ;  ADD s7, 87'd
 0AF                                            ; done_adding2:
 0AF                                            ;  LOAD s5, s7
 0AF                                            ;  CALL UART_TX  ; send it to UART via s5
 0AF                                            ; done_print_one_hex:
 0AF                                            ;  ADD sA, 1'd  ; read the next byte
 0AF                                            ;  ADDCY sB, 0'd
 0AF                                            ;  SUB s8, 1'd  ; decrement the counter
 0AF                                            ;  TEST s8, FF  ; Is cunter zero?
 0AF                                            ;  RETURN Z
 0AF                                            ;  JUMP print_hex_loop
 0AF                                            ;  RETURN
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                                            ; Procedure:  reg_print_hex()
 0AF                                            ; Registers Used:
 0AF                                            ;        Bank0 : s5, s7
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Arguments:
 0AF                                            ;    Bank0 : s5 : content to print
 0AF                                            ;   Bank1 : None
 0AF                                            ;
 0AF                                            ; Calls:  UART_TX
 0AF                                            ;
 0AF                                            ; Returns:  None
 0AF                                            ;
 0AF                                            ; Return Flags:  None
 0AF                                            ;
 0AF                                            ; Description:  Prints an 8-bit number stored in s5 in hex formatx
 0AF                                            ;------------------------------------------------------------------------------------
 0AF                             reg_print_hex: 
 0AF  00750                                     LOAD s7, s5                                     ; Copy s5
 0B0  1450E                                     SR0 s5                                          ; shift the 4 bit on the left to the right
 0B1  1450E                                     SR0 s5
 0B2  1450E                                     SR0 s5
 0B3  1450E                                     SR0 s5
 0B4  1D50A                                     COMPARE s5, 0A[10'd]
 0B5  3A0B7                                     JUMP C, 0B7[less_or_eq_to_nine3]
 0B6  220B9                                     JUMP 0B9[greater_than_nine3]
 0B7                       less_or_eq_to_nine3: 
 0B7  11530                                     ADD s5, 30[48'd]
 0B8  220BA                                     JUMP 0BA[done_adding3]
 0B9                        greater_than_nine3: 
 0B9  11557                                     ADD s5, 57[87'd]
 0BA                              done_adding3: 
 0BA  20078                                     CALL 078[UART_TX]                               ; send it to UART via s5
 0BB                                            ;--- Second nibble
 0BB  0370F                                     AND s7, 0F                                      ; select the 4 bit on the right
 0BC  1D70A                                     COMPARE s7, 0A[10'd]
 0BD  3A0BF                                     JUMP C, 0BF[less_or_eq_to_nine4]
 0BE  220C1                                     JUMP 0C1[greater_than_nine4]
 0BF                       less_or_eq_to_nine4: 
 0BF  11730                                     ADD s7, 30[48'd]
 0C0  220C2                                     JUMP 0C2[done_adding4]
 0C1                        greater_than_nine4: 
 0C1  11757                                     ADD s7, 57[87'd]
 0C2                              done_adding4: 
 0C2  00570                                     LOAD s5, s7
 0C3  20078                                     CALL 078[UART_TX]                               ; send it to UART via s5
 0C4  25000                                     RETURN 
 0C5                                            ;------------------------------------------------------------------------------------
 0C5                                            ; Procedure:  SPM_print_hex()
 0C5                                            ; Registers Used:
 0C5                                            ;        Bank0 : s9, s8, s7, s5,
 0C5                                            ;   Bank1 : None
 0C5                                            ;
 0C5                                            ; Arguments:
 0C5                                            ;    Bank0 : s6
 0C5                                            ;   Bank1 : None
 0C5                                            ;
 0C5                                            ; Calls:  UART_TX
 0C5                                            ;
 0C5                                            ; Returns:  None
 0C5                                            ;
 0C5                                            ; Return Flags:  None
 0C5                                            ;
 0C5                                            ; Description:  Prints a 64-bit double precision number starting from location
 0C5                                            ; index (s9) of SPM.
 0C5                                            ;------------------------------------------------------------------------------------
 0C5                             SPM_print_hex: 
 0C5  01808                                     LOAD s8, 08[8'd]                                ; Double precision has 8 bytes
 0C6                            print_hex_loop: 
 0C6  0A590                                     FETCH s5, (s9)
 0C7  00750                                     LOAD s7, s5                                     ; Copy s5
 0C8  1450E                                     SR0 s5                                          ; shift the 4 bit on the left to the right
 0C9  1450E                                     SR0 s5
 0CA  1450E                                     SR0 s5
 0CB  1450E                                     SR0 s5
 0CC  1D50A                                     COMPARE s5, 0A[10'd]
 0CD  3A0CF                                     JUMP C, 0CF[less_or_eq_to_nine]
 0CE  220D1                                     JUMP 0D1[greater_than_nine]
 0CF                        less_or_eq_to_nine: 
 0CF  11530                                     ADD s5, 30[48'd]
 0D0  220D2                                     JUMP 0D2[done_adding]
 0D1                         greater_than_nine: 
 0D1  11557                                     ADD s5, 57[87'd]
 0D2                               done_adding: 
 0D2  20078                                     CALL 078[UART_TX]                               ; send it to UART via s5
 0D3                                            ;--- Second nibble
 0D3  0370F                                     AND s7, 0F                                      ; select the 4 bit on the right
 0D4  1D70A                                     COMPARE s7, 0A[10'd]
 0D5  3A0D7                                     JUMP C, 0D7[less_or_eq_to_nine2]
 0D6  220D9                                     JUMP 0D9[greater_than_nine2]
 0D7                       less_or_eq_to_nine2: 
 0D7  11730                                     ADD s7, 30[48'd]
 0D8  220DA                                     JUMP 0DA[done_adding2]
 0D9                        greater_than_nine2: 
 0D9  11757                                     ADD s7, 57[87'd]
 0DA                              done_adding2: 
 0DA  00570                                     LOAD s5, s7
 0DB  20078                                     CALL 078[UART_TX]                               ; send it to UART via s5
 0DC                     done_printing_one_hex: 
 0DC  11901                                     ADD s9, 01                                      ; read the next byte
 0DD  19801                                     SUB s8, 01[1'd]                                 ; decrement the counter
 0DE  0D8FF                                     TEST s8, FF                                     ; Is cunter zero?
 0DF  31000                                     RETURN Z
 0E0  220C6                                     JUMP 0C6[print_hex_loop]
 0E1  25000                                     RETURN 
 0E2                                            ;-----------------------------------------------------------------------------------
 0E2                                            ; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
 0E2                                            ;
 0E2                                            ; beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
 0E2                                            ;
 0E2                                            ;------------------------------------------------------------------------------------
 0E2                                            ; Procedure:  add_dp()
 0E2                                            ; Registers Used:
 0E2                                            ;        Bank0 :
 0E2                                            ;   Bank1 : None
 0E2                                            ;
 0E2                                            ; Arguments:
 0E2                                            ;    Scratch Pad Memory (SPM-256): position 0 to 15.
 0E2                                            ;   x: SPM position 0 to 7.
 0E2                                            ;   y: SPM position 8 to 15.
 0E2                                            ;
 0E2                                            ;    Bank0 : None
 0E2                                            ;   Bank1 : None
 0E2                                            ;
 0E2                                            ; Calls:  None
 0E2                                            ;
 0E2                                            ; Returns:  Scratch Pad Memory (SPM-256): position 0 to 7.
 0E2                                            ;    r: SPM position 0 to 7.
 0E2                                            ;
 0E2                                            ; Return Flags:  None
 0E2                                            ;
 0E2                                            ; Description:  Adds two double-precisin IEEE-754 numbers.
 0E2                                            ;    Computes x + y and returns the result in r.
 0E2                                            ;    x + y = r.
 0E2                                            ;------------------------------------------------------------------------------------
 0E2                                    add_dp: 
 0E2  25000                                     RETURN 
 0E3                                            ;------------------------------------------------------------------------------------
 0E3                                            ; Procedure:  load_8Bytes_from_ext_BRAM()
 0E3                                            ; Registers Used:
 0E3                                            ;        Bank0 : s6, s5, s9
 0E3                                            ;   Bank1 : None
 0E3                                            ;
 0E3                                            ; Arguments:
 0E3                                            ;    Bank0 : [s6, s5] : The address of starting point of memory
 0E3                                            ;   Bank1 : None
 0E3                                            ;
 0E3                                            ; Calls:  Read_ext_mem()
 0E3                                            ;
 0E3                                            ; Returns:  8 bytes in SPM, starts  at s8.
 0E3                                            ;
 0E3                                            ; Return Flags:  None
 0E3                                            ;
 0E3                                            ; Description:  Load 8 sequential bytes into SPM starting at position set in s8.
 0E3                                            ;------------------------------------------------------------------------------------
 0E3                 load_8Bytes_from_ext_BRAM: 
 0E3  00980                                     LOAD s9, s8                                     ; Copy s8
 0E4  11908                                     ADD s9, 08[8'd]                                 ; After 8 reads the the loop must stop
 0E5                 read_8bytes_ext_BRAM_loop: 
 0E5  200ED                                     CALL 0ED[Read_ext_mem]                          ; Read the first byte and save it in s7
 0E6  2E780                                     STORE s7, (s8)
 0E7  11501                                     ADD s5, 01                                      ; Point to the next byte
 0E8  13600                                     ADDCY s6, 00
 0E9  11801                                     ADD s8, 01[1'd]                                 ; Increment SPM pointer by 1
 0EA  1C890                                     COMPARE s8, s9                                  ; 8 bytes reached ?
 0EB  3A0E5                                     JUMP C, 0E5[read_8bytes_ext_BRAM_loop]          ; Jump if s8 is less than s9
 0EC  25000                                     RETURN 
 0ED                                            ;------------------------------------------------------------------------------------
 0ED                                            ; Procedure:  Read_ext_mem()
 0ED                                            ; Registers Used:
 0ED                                            ;        Bank0 : s7, s6, s5
 0ED                                            ;   Bank1 : None
 0ED                                            ;
 0ED                                            ; Arguments:
 0ED                                            ;    Bank0 : None
 0ED                                            ;   Bank1 : None
 0ED                                            ;
 0ED                                            ; Calls:  None
 0ED                                            ;
 0ED                                            ; Returns:  s7: The read data
 0ED                                            ;
 0ED                                            ; Return Flags:  None
 0ED                                            ;
 0ED                                            ; Description:  Reads the external memory.
 0ED                                            ;
 0ED                                            ;   [s6, s5] must contains the read address (12 bits).
 0ED                                            ;   - Bit 7 of s6 is clock  enable.
 0ED                                            ;   Uppder nibble of s6 must contain 8, to enable the block RAM.
 0ED                                            ;------------------------------------------------------------------------------------
 0ED                              Read_ext_mem: 
 0ED  05680                                     OR s6, 80                                       ; Enable BRAM clock
 0EE  2D501                                     OUTPUT s5, 01[Extra_mem_lo_output_port]
 0EF  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0F0  04550                                     OR s5, s5                                       ; Delay
 0F1  09702                                     INPUT s7, 02[Extra_mem_input_port]
 0F2  0367F                                     AND s6, 7F                                      ; Disable BRAM clock
 0F3  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0F4  25000                                     RETURN 
 0F5                                            ;------------------------------------------------------------------------------------
 0F5                                            ; Procedure:  Write_ext_mem()
 0F5                                            ; Registers Used:
 0F5                                            ;        Bank0 : s7, s6, s5
 0F5                                            ;   Bank1 : None
 0F5                                            ;
 0F5                                            ; Arguments:
 0F5                                            ;    Bank0 : None
 0F5                                            ;   Bank1 : None
 0F5                                            ;
 0F5                                            ; Calls:  None
 0F5                                            ;
 0F5                                            ; Returns:  None
 0F5                                            ;
 0F5                                            ; Return Flags:  None
 0F5                                            ;
 0F5                                            ; Description:  Writes to external memory.
 0F5                                            ;
 0F5                                            ;   [s6, s5] must contains the write address.
 0F5                                            ;   - Bit 7 of s6 is Clock Enable
 0F5                                            ;   - Bit 6 of s6 is Write Enable
 0F5                                            ;   - Write at address:  EW00_AAAA_AAAA_AAAA
 0F5                                            ;   - Uppder nibble of s6 must contain C, to enable the block RAM
 0F5                                            ;          and write enable.
 0F5                                            ;   - s7 regiser has 8-bit data to be written at location [s6, s5].
 0F5                                            ;
 0F5                                            ;------------------------------------------------------------------------------------
 0F5                             Write_ext_mem: 
 0F5  056C0                                     OR s6, C0                                       ; Enable block RAM and write enable.
 0F6  2D703                                     OUTPUT s7, 03[Extra_mem_output_port]
 0F7  2D501                                     OUTPUT s5, 01[Extra_mem_lo_output_port]
 0F8  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0F9  04550                                     OR s5, s5                                       ; Delay
 0FA  0363F                                     AND s6, 3F                                      ; disable block RAM and write enable.
 0FB  2D602                                     OUTPUT s6, 02[Extra_mem_hi_output_port]
 0FC  25000                                     RETURN 
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                                            ; Procedure:  SPM_load_8Bytes()
 0FD                                            ; Registers Used:
 0FD                                            ;        Bank0 : sB, sA, s8, s6, s5
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Arguments:
 0FD                                            ;    Bank0 : s5
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Calls:  None
 0FD                                            ;
 0FD                                            ; Returns:  None
 0FD                                            ;
 0FD                                            ; Return Flags:  None
 0FD                                            ;
 0FD                                            ; Description:  Load 8 sequential bytes into SPM starting at position set in s5.
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                                            ; SPM_load_8Bytes:
 0FD                                            ;  LOAD s8, s5  ; Set SPM starting position
 0FD                                            ;  LOAD s6, s5
 0FD                                            ;  ADD s6, 8'd
 0FD                                            ; SPM_load_loop:
 0FD                                            ;  CALL@ (sB, sA)  ; read the first byte in s5
 0FD                                            ;  STORE s5, (s8)
 0FD                                            ;  ADD sA, 1'd  ; read the next byte
 0FD                                            ;  ADDCY sB, 0'd
 0FD                                            ;  ADD s8, 1'd  ; Increment SPM pointer by 1
 0FD                                            ;  COMPAREARE s8, s6  ; 8 bytes reached ?
 0FD                                            ;  JUMP C,SPM_load_loop
 0FD                                            ;  RETURN
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                                            ; Procedure:  invoke_done_interrupt()
 0FD                                            ;
 0FD                                            ; Registers Used: Bank0 : s5, s6
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Arguments:  Bank0 : [s1,s0]
 0FD                                            ;   Bank1 : None
 0FD                                            ;
 0FD                                            ; Calls:  None
 0FD                                            ;
 0FD                                            ; Returns:  s0
 0FD                                            ;
 0FD                                            ; Return Flags:  None
 0FD                                            ;
 0FD                                            ; Description: Invoke Done interrupt
 0FD                                            ;------------------------------------------------------------------------------------
 0FD                     invoke_done_interrupt: 
 0FD  01500                                     LOAD s5, 00
 0FE  2D504                                     OUTPUT s5, 04[irqs_output_port]
 0FF  04550                                     OR s5, s5                                       ; Delay
 100  01501                                     LOAD s5, 01
 101  2D504                                     OUTPUT s5, 04[irqs_output_port]
 102                                            ; delay after setting the line to high: 32 cycles
 102  01640                                     LOAD s6, 40
 103                            delay_int_loop: 
 103  19601                                     SUB s6, 01
 104  36103                                     JUMP NZ, 103[delay_int_loop]
 105  01500                                     LOAD s5, 00
 106  2D504                                     OUTPUT s5, 04[irqs_output_port]
 107  25000                                     RETURN 
 108                                            ;------------------------------------------------------------------------------------
 108                                            ; Procedure:  write_result_to_external_memory()
 108                                            ;
 108                                            ; Registers Used: Bank0 : s5, s6
 108                                            ;   Bank1 : None
 108                                            ;
 108                                            ; Arguments:  Bank0 : [s1,s0]
 108                                            ;   Bank1 : None
 108                                            ;
 108                                            ; Calls:  None
 108                                            ;
 108                                            ; Returns:  s0
 108                                            ;
 108                                            ; Return Flags:  None
 108                                            ;
 108                                            ; Description:  Write the arithmathic result to external memory.
 108                                            ;------------------------------------------------------------------------------------
 108           write_result_to_external_memory: 
 108  01600                                     LOAD s6, 00                                     ; Write result at address  010
 109  01510                                     LOAD s5, 10
 10A  0B717                                     FETCH s7, 17[r_0]
 10B                                            ;LOAD s7, 25
 10B  200F5                                     CALL 0F5[Write_ext_mem]
 10C  01600                                     LOAD s6, 00                                     ; Write result at address  011
 10D  01511                                     LOAD s5, 11
 10E  0B716                                     FETCH s7, 16[r_1]
 10F                                            ;LOAD s7, 26
 10F  200F5                                     CALL 0F5[Write_ext_mem]
 110  01600                                     LOAD s6, 00                                     ; Write result at address  012
 111  01512                                     LOAD s5, 12
 112  0B715                                     FETCH s7, 15[r_2]
 113                                            ;LOAD s7, 27
 113  200F5                                     CALL 0F5[Write_ext_mem]
 114  01600                                     LOAD s6, 00                                     ; Write result at address  013
 115  01513                                     LOAD s5, 13
 116  0B714                                     FETCH s7, 14[r_3]
 117                                            ;LOAD s7, 28
 117  200F5                                     CALL 0F5[Write_ext_mem]
 118  01600                                     LOAD s6, 00                                     ; Write result at address  014
 119  01514                                     LOAD s5, 14
 11A  0B713                                     FETCH s7, 13[r_4]
 11B                                            ;LOAD s7, 29
 11B  200F5                                     CALL 0F5[Write_ext_mem]
 11C  01600                                     LOAD s6, 00                                     ; Write result at address  015
 11D  01515                                     LOAD s5, 15
 11E  0B712                                     FETCH s7, 12[r_5]
 11F                                            ;LOAD s7, 30
 11F  200F5                                     CALL 0F5[Write_ext_mem]
 120  01600                                     LOAD s6, 00                                     ; Write result at address  016
 121  01516                                     LOAD s5, 16
 122  0B711                                     FETCH s7, 11[r_6]
 123                                            ;LOAD s7, 31
 123  200F5                                     CALL 0F5[Write_ext_mem]
 124  01600                                     LOAD s6, 00                                     ; Write result at address  017
 125  01517                                     LOAD s5, 17
 126  0B710                                     FETCH s7, 10[r_7]
 127                                            ;LOAD s7, 32
 127  200F5                                     CALL 0F5[Write_ext_mem]
 128  25000                                     RETURN 
 129                                            ;-----------------------------------------------------------------------------------
 129                                            ; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
 129                                            ;
 129                                            ; beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
 129                                            ;
 129                                            ;------------------------------------------------------------------------------------
 129                                            ; Procedure:   arith_add_x_y()
 129                                            ;
 129                                            ; Registers Used: Bank0 : All
 129                                            ;     Bank1 : None
 129                                            ;
 129                                            ; Arguments:   Bank0 :
 129                                            ;     Bank1 : None
 129                                            ;     SPM   : x = [x_7, x_6, ..., x_0]
 129                                            ;            y = [y_7, y_6, ..., y_0]
 129                                            ;
 129                                            ; Calls:
 129                                            ;     load_mx
 129                                            ;     load_my
 129                                            ;     swap_operands
 129                                            ;     count_nlz
 129                                            ;     round
 129                                            ;
 129                                            ; RETs:    None
 129                                            ;
 129                                            ; RET Flags:   None
 129                                            ;
 129                                            ; Description:  Adds two 64-bit double-precision floating point numbers.
 129                                            ;   This procedure always add. For subtraction set the sign of second  operand
 129                                            ; to negative due to the fact that x + (-y) = x - y.
 129                                            ;------------------------------------------------------------------------------------
 129                             arith_add_x_y: 
 129  2034E                                     CALL 34E[set_ops_status]
 12A  202FA                                     CALL 2FA[decompose_x]
 12B  20324                                     CALL 324[decompose_y]
 12C  0B13A                                     FETCH s1, 3A[op1_status]                        ; read the ops status
 12D  0B23B                                     FETCH s2, 3B[op2_status]                        ; read the ops status
 12E                                            ; We check op1 for
 12E                                            ; 1) NaN
 12E                                            ;  Yes: Check op2, if NaN then return Y_NaN else return X_NaN
 12E                                            ;  No:  Go to step 2.
 12E                                            ; 2) Infinity
 12E                                            ;  Yes: Check op2, if Inf then return_NaN_Inf
 12E                                            ;  No:  Go to step 3.
 12E                                            ; 3) Zero
 12E                                            ;  Yes: check if op2 is NaN then return_NaN_Inf else return y
 12E                                            ;  No:  swap_step
 12E                                            ; Check if op1 is NaN
 12E  0D110                                     TEST s1, 10
 12F  3213A                                     JUMP Z, 13A[final_op1_not_NaN]                  ; No
 130                             final_op1_NaN: ; Yes
 130                                            ; Check if op2 is NaN
 130  0D210                                     TEST s2, 10
 131  36133                                     JUMP NZ, 133[return_NAN]                        ; Yes
 132  22177                                     JUMP 177[return_x_NAN]
 133                                return_NAN: 
 133                                            ; check op1 NaN bit
 133  0B31B                                     FETCH s3, 1B[x_m6]
 134  0D308                                     TEST s3, 08
 135  32177                                     JUMP Z, 177[return_x_NAN]
 136                                            ; op1 NaN bit is 1, so check op2 NaN bit
 136  0B326                                     FETCH s3, 26[y_m6]
 137  0D308                                     TEST s3, 08
 138  321BC                                     JUMP Z, 1BC[return_y_NAN]
 139  22177                                     JUMP 177[return_x_NAN]
 13A                         final_op1_not_NaN: 
 13A                                            ; +inf + + inf = +inf
 13A                                            ; +inf + - inf = +NaN
 13A                                            ; -inf + + inf = +NaN
 13A                                            ; -inf + - inf = -inf
 13A                                            ; infinity sign is the AND of both operands' sign bits.
 13A                                            ; Result NaN bit is XOR of both operands' sign bits.
 13A                                            ; Check if op1 is Inf
 13A  0D120                                     TEST s1, 20
 13B  32141                                     JUMP Z, 141[final_op1_not_Inf]                  ; No
 13C                             final_op1_Inf: ; Yes
 13C                                            ; Check if op2 is Inf
 13C  0D220                                     TEST s2, 20
 13D  361CF                                     JUMP NZ, 1CF[return_y_NAN_Inf]                  ; Yes
 13E                                            ; Check if op2 is NaN
 13E  0D210                                     TEST s2, 10
 13F  361BC                                     JUMP NZ, 1BC[return_y_NAN]                      ; Yes
 140  22165                                     JUMP 165[return_x]
 141                         final_op1_not_Inf: 
 141                                            ; Check if op1 is zero
 141  0D140                                     TEST s1, 40
 142  32148                                     JUMP Z, 148[check_final_op2]                    ; No
 143                         final_op1_is_zero: 
 143                                            ; Check if op2 is zero
 143  0D240                                     TEST s2, 40
 144  36156                                     JUMP NZ, 156[return_zero]                       ; Yes
 145                                            ; Check if op2 is NaN
 145  0D210                                     TEST s2, 10
 146  361BC                                     JUMP NZ, 1BC[return_y_NAN]                      ;Yes
 147  221AA                                     JUMP 1AA[return_y]
 148                                            ; Op1 is not NaN, Inf, and zero, so we conclude op1 is (sub)normal.
 148                                            ; We check op2 for
 148                                            ; 1) NaN
 148                                            ;  Yes: return_NaN_Inf
 148                                            ;  No:  Go to step 2.
 148                                            ; 2) Infinity
 148                                            ;  Yes: return_NaN_Inf
 148                                            ;  No:  return x
 148                                            ; 3) Zero
 148                                            ;  Yes: return zero
 148                                            ;  No:  swap_step
 148                           check_final_op2: 
 148                                            ; Check if op2 is NaN
 148  0D210                                     TEST s2, 10
 149  361BC                                     JUMP NZ, 1BC[return_y_NAN]                      ;Yes
 14A                         final_op2_not_NaN: ; NoSL0  s8
 14A  14900                                     SLA s9
 14B  14800                                     SLA s8
 14C  14900                                     SLA s9
 14D  14800                                     SLA s8
 14E  14900                                     SLA s9
 14F  14800                                     SLA s8
 150  14900                                     SLA s9
 151                                            ; +inf + + inf = +inf
 151                                            ; +inf + - inf = +NaN
 151                                            ; -inf + + inf = +NaN
 151                                            ; -inf + - inf = -inf
 151                                            ; infinity sign is the AND of both operands' sign bits.
 151                                            ; Result NaN bit is XOR of both operands' sign bits.
 151                                            ; Check if op2 is Inf
 151  0D220                                     TEST s2, 20
 152  361AA                                     JUMP NZ, 1AA[return_y]                          ; Yes
 153                         final_op2_not_Inf: ; No
 153                                            ; Check if op2 is zero
 153  0D240                                     TEST s2, 40
 154  36165                                     JUMP NZ, 165[return_x]                          ; Yes
 155                                            ; Both operators are (sub)normal. Perform the addition.
 155                                            ; op1 = subnormal op2 = subnormal  - Normal procedure works
 155                                            ; ex = 0    ey = 0
 155                                            ; op1 = subnormal op2 = normal   - hidden 0 must be injected.
 155                                            ; ex = 0    ey != 0   subnormal
 155                                            ; op1 = normal  op2 = subnormal  - hidden 0 must be injected.
 155                                            ; ex != 0    ey = 0
 155                                            ; op1 = normal  op2 = normal     - Normal procedure works
 155  221F2                                     JUMP 1F2[COMP_swap_ex]
 156                               return_zero: 
 156  01FFF                                     LOAD sF, FF
 157                                            ; +0 +0 => +0
 157                                            ; -0 +0 => +0
 157                                            ; +0 -0 => +0
 157                                            ; -0 -0 => -0
 157  0B118                                     FETCH s1, 18[x_sign]
 158  0B223                                     FETCH s2, 23[y_sign]
 159  02120                                     AND s1, s2                                      ; Calculate the sign of zero
 15A  03180                                     AND s1, 80                                      ; zero all other bits except sign
 15B  01000                                     LOAD s0, 00
 15C  2F011                                     STORE s0, 11[r_6]
 15D  2F012                                     STORE s0, 12[r_5]
 15E  2F013                                     STORE s0, 13[r_4]
 15F  2F014                                     STORE s0, 14[r_3]
 160  2F015                                     STORE s0, 15[r_2]
 161  2F016                                     STORE s0, 16[r_1]
 162  2F017                                     STORE s0, 17[r_0]
 163  2F110                                     STORE s1, 10[r_7]
 164  25000                                     RETURN 
 165                                  return_x: 
 165  01FFF                                     LOAD sF, FF
 166  0B700                                     FETCH s7, 00[x_7]
 167  0B601                                     FETCH s6, 01[x_6]
 168  0B502                                     FETCH s5, 02[x_5]
 169  0B403                                     FETCH s4, 03[x_4]
 16A  0B304                                     FETCH s3, 04[x_3]
 16B  0B205                                     FETCH s2, 05[x_2]
 16C  0B106                                     FETCH s1, 06[x_1]
 16D  0B007                                     FETCH s0, 07[x_0]
 16E  2F710                                     STORE s7, 10[r_7]
 16F  2F611                                     STORE s6, 11[r_6]
 170  2F512                                     STORE s5, 12[r_5]
 171  2F413                                     STORE s4, 13[r_4]
 172  2F314                                     STORE s3, 14[r_3]
 173  2F215                                     STORE s2, 15[r_2]
 174  2F116                                     STORE s1, 16[r_1]
 175  2F017                                     STORE s0, 17[r_0]
 176  25000                                     RETURN 
 177                              return_x_NAN: 
 177  01FFF                                     LOAD sF, FF
 178  0B700                                     FETCH s7, 00[x_7]
 179  0B601                                     FETCH s6, 01[x_6]
 17A  05608                                     OR s6, 08                                       ; ensure the result is NaN
 17B  0B502                                     FETCH s5, 02[x_5]
 17C  0B403                                     FETCH s4, 03[x_4]
 17D  0B304                                     FETCH s3, 04[x_3]
 17E  0B205                                     FETCH s2, 05[x_2]
 17F  0B106                                     FETCH s1, 06[x_1]
 180  0B007                                     FETCH s0, 07[x_0]
 181  2F710                                     STORE s7, 10[r_7]
 182  2F611                                     STORE s6, 11[r_6]
 183  2F512                                     STORE s5, 12[r_5]
 184  2F413                                     STORE s4, 13[r_4]
 185  2F314                                     STORE s3, 14[r_3]
 186  2F215                                     STORE s2, 15[r_2]
 187  2F116                                     STORE s1, 16[r_1]
 188  2F017                                     STORE s0, 17[r_0]
 189  25000                                     RETURN 
 18A                          return_x_NAN_Inf: 
 18A  01FFF                                     LOAD sF, FF
 18B                                            ; Read operand signs
 18B  0B900                                     FETCH s9, 00[x_7]
 18C  0B808                                     FETCH s8, 08[y_7]
 18D  03980                                     AND s9, 80                                      ; op1 sign bit
 18E  03880                                     AND s8, 80                                      ; op2 sign bit
 18F                                            ; +inf + + inf = +inf
 18F                                            ; +inf + - inf = +NaN
 18F                                            ; -inf + + inf = +NaN
 18F                                            ; -inf + - inf = -inf
 18F                                            ; infinity sign is the AND of both operands' sign bits.
 18F                                            ; Result NaN bit is XOR of both operands' sign bits.
 18F  00A90                                     LOAD sA, s9                                     ; copy s9 into sA
 190  02A80                                     AND sA, s8
 191  06980                                     XOR s9, s8
 192  0D980                                     TEST s9, 80
 193  32196                                     JUMP Z, 196[NaN_bit_off]
 194  01808                                     LOAD s8, 08
 195  22197                                     JUMP 197[done_applying_NaN_bit]
 196                               NaN_bit_off: 
 196  01800                                     LOAD s8, 00
 197                     done_applying_NaN_bit: 
 197  0B700                                     FETCH s7, 00[x_7]
 198  047A0                                     OR s7, sA                                       ; Apply infinity sign
 199  0B601                                     FETCH s6, 01[x_6]
 19A  04680                                     OR s6, s8                                       ; Apply Result NaN bit
 19B  0B502                                     FETCH s5, 02[x_5]
 19C  0B403                                     FETCH s4, 03[x_4]
 19D  0B304                                     FETCH s3, 04[x_3]
 19E  0B205                                     FETCH s2, 05[x_2]
 19F  0B106                                     FETCH s1, 06[x_1]
 1A0  0B007                                     FETCH s0, 07[x_0]
 1A1  2F710                                     STORE s7, 10[r_7]
 1A2  2F611                                     STORE s6, 11[r_6]
 1A3  2F512                                     STORE s5, 12[r_5]
 1A4  2F413                                     STORE s4, 13[r_4]
 1A5  2F314                                     STORE s3, 14[r_3]
 1A6  2F215                                     STORE s2, 15[r_2]
 1A7  2F116                                     STORE s1, 16[r_1]
 1A8  2F017                                     STORE s0, 17[r_0]
 1A9  25000                                     RETURN 
 1AA                                  return_y: 
 1AA  01FFF                                     LOAD sF, FF
 1AB  0B708                                     FETCH s7, 08[y_7]
 1AC  0B609                                     FETCH s6, 09[y_6]
 1AD  0B50A                                     FETCH s5, 0A[y_5]
 1AE  0B40B                                     FETCH s4, 0B[y_4]
 1AF  0B30C                                     FETCH s3, 0C[y_3]
 1B0  0B20D                                     FETCH s2, 0D[y_2]
 1B1  0B10E                                     FETCH s1, 0E[y_1]
 1B2  0B00F                                     FETCH s0, 0F[y_0]
 1B3  2F710                                     STORE s7, 10[r_7]
 1B4  2F611                                     STORE s6, 11[r_6]
 1B5  2F512                                     STORE s5, 12[r_5]
 1B6  2F413                                     STORE s4, 13[r_4]
 1B7  2F314                                     STORE s3, 14[r_3]
 1B8  2F215                                     STORE s2, 15[r_2]
 1B9  2F116                                     STORE s1, 16[r_1]
 1BA  2F017                                     STORE s0, 17[r_0]
 1BB  25000                                     RETURN 
 1BC                              return_y_NAN: 
 1BC  01FFF                                     LOAD sF, FF
 1BD  0B708                                     FETCH s7, 08[y_7]
 1BE  0B609                                     FETCH s6, 09[y_6]
 1BF  05608                                     OR s6, 08                                       ; ensure the result is NaN
 1C0  0B50A                                     FETCH s5, 0A[y_5]
 1C1  0B40B                                     FETCH s4, 0B[y_4]
 1C2  0B30C                                     FETCH s3, 0C[y_3]
 1C3  0B20D                                     FETCH s2, 0D[y_2]
 1C4  0B10E                                     FETCH s1, 0E[y_1]
 1C5  0B00F                                     FETCH s0, 0F[y_0]
 1C6  2F710                                     STORE s7, 10[r_7]
 1C7  2F611                                     STORE s6, 11[r_6]
 1C8  2F512                                     STORE s5, 12[r_5]
 1C9  2F413                                     STORE s4, 13[r_4]
 1CA  2F314                                     STORE s3, 14[r_3]
 1CB  2F215                                     STORE s2, 15[r_2]
 1CC  2F116                                     STORE s1, 16[r_1]
 1CD  2F017                                     STORE s0, 17[r_0]
 1CE  25000                                     RETURN 
 1CF                          return_y_NAN_Inf: 
 1CF  01FFF                                     LOAD sF, FF
 1D0                                            ; Read operand signs
 1D0  0B900                                     FETCH s9, 00[x_7]
 1D1  0B808                                     FETCH s8, 08[y_7]
 1D2  03980                                     AND s9, 80                                      ; op1 sign bit
 1D3  03880                                     AND s8, 80                                      ; op2 sign bit
 1D4                                            ; +inf + + inf = +inf
 1D4                                            ; +inf + - inf = +NaN
 1D4                                            ; -inf + + inf = +NaN
 1D4                                            ; -inf + - inf = -inf
 1D4                                            ; infinity sign is the AND of both operands' sign bits.
 1D4                                            ; Result NaN bit is XOR of both operands' sign bits.
 1D4  00A90                                     LOAD sA, s9                                     ; copy s9 into sA
 1D5  02A80                                     AND sA, s8
 1D6  06980                                     XOR s9, s8
 1D7  0B708                                     FETCH s7, 08[y_7]
 1D8                                            ; Apply the sign
 1D8  0DA80                                     TEST sA, 80
 1D9  361DC                                     JUMP NZ, 1DC[set_sign_bit_to_1]
 1DA                         set_sign_bit_to_0: 
 1DA  0377F                                     AND s7, 7F
 1DB  221DD                                     JUMP 1DD[set_sign_bit_done]
 1DC                         set_sign_bit_to_1: 
 1DC  05780                                     OR s7, 80
 1DD                         set_sign_bit_done: 
 1DD  0B609                                     FETCH s6, 09[y_6]
 1DE                                            ; Apply the sign
 1DE  0D980                                     TEST s9, 80
 1DF  361E2                                     JUMP NZ, 1E2[set_NaN_bit_to_1]
 1E0                          set_NaN_bit_to_0: 
 1E0  036F7                                     AND s6, F7
 1E1  221E3                                     JUMP 1E3[set_NaN_bit_done]
 1E2                          set_NaN_bit_to_1: 
 1E2  05608                                     OR s6, 08
 1E3                          set_NaN_bit_done: 
 1E3  0B50A                                     FETCH s5, 0A[y_5]
 1E4  0B40B                                     FETCH s4, 0B[y_4]
 1E5  0B30C                                     FETCH s3, 0C[y_3]
 1E6  0B20D                                     FETCH s2, 0D[y_2]
 1E7  0B10E                                     FETCH s1, 0E[y_1]
 1E8  0B00F                                     FETCH s0, 0F[y_0]
 1E9  2F710                                     STORE s7, 10[r_7]
 1EA  2F611                                     STORE s6, 11[r_6]
 1EB  2F512                                     STORE s5, 12[r_5]
 1EC  2F413                                     STORE s4, 13[r_4]
 1ED  2F314                                     STORE s3, 14[r_3]
 1EE  2F215                                     STORE s2, 15[r_2]
 1EF  2F116                                     STORE s1, 16[r_1]
 1F0  2F017                                     STORE s0, 17[r_0]
 1F1  25000                                     RETURN 
 1F2                                            ;--------------------------------------------------------------------------
 1F2                              COMP_swap_ex: 
 1F2                                            ; Read ex : [s1, s0]
 1F2  0B119                                     FETCH s1, 19[x_ex7]
 1F3  0B01A                                     FETCH s0, 1A[x_ex6]
 1F4                                            ; Read ey: [s3, s2]
 1F4  0B324                                     FETCH s3, 24[y_ex7]
 1F5  0B225                                     FETCH s2, 25[y_ex6]
 1F6                                            ; COMPARE ex [s1, s0] VS ey [s3, s2]
 1F6  1C020                                     COMPARE s0, s2
 1F7  1E130                                     COMPARECY s1, s3
 1F8  3A206                                     JUMP C, 206[ex_less_than_ey]
 1F9                  ex_greater_equal_than_ey: 
 1F9  36207                                     JUMP NZ, 207[swap_done]
 1FA                               ex_equal_ey: 
 1FA                                            ;when both exponents are equal then we compare the significand
 1FA  37001                                     REGBANK B
 1FB  2029E                                     CALL 29E[load_mx]
 1FC  202A7                                     CALL 2A7[load_my]
 1FD  1C190                                     COMPARE s1, s9
 1FE  1E2A0                                     COMPARECY s2, sA
 1FF  1E3B0                                     COMPARECY s3, sB
 200  1E4C0                                     COMPARECY s4, sC
 201  1E5D0                                     COMPARECY s5, sD
 202  1E6E0                                     COMPARECY s6, sE
 203  1E7F0                                     COMPARECY s7, sF
 204  37000                                     REGBANK A
 205  3E207                                     JUMP NC, 207[swap_done]
 206                           ex_less_than_ey: 
 206  202B0                                     CALL 2B0[swap_operands]
 207                                 swap_done: 
 207                                            ; Reread ex : [s1, s0]
 207  0B119                                     FETCH s1, 19[x_ex7]
 208  0B01A                                     FETCH s0, 1A[x_ex6]
 209                                            ; Reread ey: [s3, s2]
 209  0B324                                     FETCH s3, 24[y_ex7]
 20A  0B225                                     FETCH s2, 25[y_ex6]
 20B                                            ; Save the sign of the bigger number into result.
 20B  0BF18                                     FETCH sF, 18[x_sign]
 20C  2FF2E                                     STORE sF, 2E[r_sign]
 20D                                            ;-------------------------------------------- --------------------------
 20D                                            ;     Exponent Alignment
 20D                                            ;-----------------------------------------------------------------------
 20D                                            ; We set "er" as "ex"
 20D  2F12F                                     STORE s1, 2F[r_ex7]                             ; Write the exponent of result in SPM
 20E  2F030                                     STORE s0, 30[r_ex6]
 20F                                            ; ex = Ex - bias + 1 - nx
 20F                                            ; ey = Ey - bias + 1 - ny
 20F                                            ; ex - nx - ey + ny
 20F                                            ;  where nx and ny are normal bits. means if op is normal nx = 1
 20F                                            ;  otheriwse nx = 0.
 20F                                            ; Is op1 normal?
 20F  0B43A                                     FETCH s4, 3A[op1_status]
 210  0D401                                     TEST s4, 01
 211  36214                                     JUMP NZ, 214[op1_is_normal_nx_is_1]
 212  11001                                     ADD s0, 01                                      ; nx = 0
 213  13100                                     ADDCY s1, 00
 214                     op1_is_normal_nx_is_1: 
 214                                            ; Is op2 normal?
 214  0B43B                                     FETCH s4, 3B[op2_status]
 215  0D401                                     TEST s4, 01
 216  36219                                     JUMP NZ, 219[op2_is_normal_ny_is_1]
 217  11201                                     ADD s2, 01                                      ; ny = 0
 218  13300                                     ADDCY s3, 00
 219                     op2_is_normal_ny_is_1: 
 219  18020                                     SUB s0, s2                                      ;ex - ey
 21A  1A130                                     SUBCY s1, s3
 21B                                            ; ex = ey so (ex - ey) will set zero flag
 21B                                            ;  thus we don't need to shift mantisa right
 21B  32247                                     JUMP Z, 247[my_mantisa_shift_right_done]
 21C                                            ; Check if [s1, s0] is more than 56, if yes then reduce it to 56 as
 21C                                            ; shofting to right more than 56 times sets the whole mantisa
 21C                                            ; to zero completely
 21C  1D038                                     COMPARE s0, 38
 21D  1F100                                     COMPARECY s1, 00
 21E  3A221                                     JUMP C, 221[not_a_big_shift]                    ; s0 is less than 56
 21F  01038                                     LOAD s0, 38
 220  01100                                     LOAD s1, 00
 221                           not_a_big_shift: 
 221                                            ; Shift "my" to right by (ex - ey) in [s1, s0]:
 221  202A7                                     CALL 2A7[load_my]
 222  14F0E                                     SR0 sF
 223  14E08                                     SRA sE
 224  14D08                                     SRA sD
 225  14C08                                     SRA sC
 226  14B08                                     SRA sB
 227  14A08                                     SRA sA
 228  14908                                     SRA s9
 229  14808                                     SRA s8                                          ; extra bits: gaurd-round-sticky-xxxxx
 22A  19001                                     SUB s0, 01                                      ; subtract by 1 to take into account the manual
 22B  1B100                                     SUBCY s1, 00                                    ; first round shift:  ex - ey - 1
 22C  3223C                                     JUMP Z, 23C[my_mantisa_shift_right_loop_done]
 22D               my_mantisa_shift_right_loop: 
 22D  14F0E                                     SR0 sF                                          ; 52 bit "my" mantisa right shift by 1-bit
 22E  14E08                                     SRA sE                                          ;  loop for (ex - ey - 1) times
 22F  14D08                                     SRA sD
 230  14C08                                     SRA sC
 231  14B08                                     SRA sB
 232  14A08                                     SRA sA
 233  14908                                     SRA s9
 234  14808                                     SRA s8                                          ; extra bits: gaurd-round-sticky-xxxxx
 235                                            ; if sticky bit of s8 ever becomes 1 set sticky bit of op2 to 1
 235  0D820                                     TEST s8, 20
 236  32239                                     JUMP Z, 239[dont_set_sticky_bit_y]
 237  01220                                     LOAD s2, 20
 238  2F22D                                     STORE s2, 2D[y_grs]
 239                     dont_set_sticky_bit_y: 
 239  19001                                     SUB s0, 01
 23A  1B100                                     SUBCY s1, 00
 23B  3622D                                     JUMP NZ, 22D[my_mantisa_shift_right_loop]
 23C          my_mantisa_shift_right_loop_done: 
 23C                                            ; Save "my" back to SMP
 23C  2FF26                                     STORE sF, 26[y_m6]
 23D  2FE27                                     STORE sE, 27[y_m5]
 23E  2FD28                                     STORE sD, 28[y_m4]
 23F  2FC29                                     STORE sC, 29[y_m3]
 240  2FB2A                                     STORE sB, 2A[y_m2]
 241  2FA2B                                     STORE sA, 2B[y_m1]
 242  2F92C                                     STORE s9, 2C[y_m0]
 243  0B22D                                     FETCH s2, 2D[y_grs]                             ; Update the gr bits for y
 244  04820                                     OR s8, s2                                       ; Apply sticky bit
 245  038E0                                     AND s8, E0                                      ; Zero all bits except grs
 246  2F82D                                     STORE s8, 2D[y_grs]
 247               my_mantisa_shift_right_done: 
 247                                            ;---------------------------------------------------------------------------
 247                                            ; Convert to two's complement
 247                                            ;---------------------------------------------------------------------------
 247  0B018                                     FETCH s0, 18[x_sign]                            ; Read sign bit of x
 248  0D080                                     TEST s0, 80                                     ; Test the x sign bit
 249  32257                                     JUMP Z, 257[sx_is_positive]
 24A                                            ; x is negative
 24A  0B023                                     FETCH s0, 23[y_sign]                            ; Read sign bit of y
 24B  0D080                                     TEST s0, 80
 24C  32252                                     JUMP Z, 252[sx_is_neg_sy_is_pos]
 24D                                            ; x is negative , y is negative
 24D                                            ; Set the result sign as negative
 24D  01080                                     LOAD s0, 80
 24E  2F02E                                     STORE s0, 2E[r_sign]
 24F  203D3                                     CALL 3D3[twos_mx]
 250  203ED                                     CALL 3ED[twos_my]
 251  22263                                     JUMP 263[perform_addition]
 252                       sx_is_neg_sy_is_pos: 
 252                                            ; Set the result sign as negative
 252  01080                                     LOAD s0, 80
 253  2F02E                                     STORE s0, 2E[r_sign]
 254  203D3                                     CALL 3D3[twos_mx]
 255  202A7                                     CALL 2A7[load_my]
 256  22263                                     JUMP 263[perform_addition]
 257                            sx_is_positive: 
 257  0B008                                     FETCH s0, 08[y_7]                               ; Read sign bit of y
 258  0D080                                     TEST s0, 80
 259  3225F                                     JUMP Z, 25F[sx_sy_is_positive]
 25A                                            ; x is positive but y is negative
 25A                                            ; Set the result sign as positive
 25A  01000                                     LOAD s0, 00
 25B  2F02E                                     STORE s0, 2E[r_sign]
 25C  2029E                                     CALL 29E[load_mx]
 25D  203ED                                     CALL 3ED[twos_my]
 25E  22263                                     JUMP 263[perform_addition]
 25F                         sx_sy_is_positive: 
 25F                                            ; Set the result sign as positive
 25F  01000                                     LOAD s0, 00
 260  2F02E                                     STORE s0, 2E[r_sign]
 261  2029E                                     CALL 29E[load_mx]
 262  202A7                                     CALL 2A7[load_my]
 263                          perform_addition: 
 263                                            ; Add mx and my
 263  10080                                     ADD s0, s8
 264  12190                                     ADDCY s1, s9
 265  122A0                                     ADDCY s2, sA
 266  123B0                                     ADDCY s3, sB
 267  124C0                                     ADDCY s4, sC
 268  125D0                                     ADDCY s5, sD
 269  126E0                                     ADDCY s6, sE
 26A  127F0                                     ADDCY s7, sF
 26B                                            ; Is negative ?
 26B  0D740                                     TEST s7, 40
 26C  32280                                     JUMP Z, 280[dont_apply_twos]
 26D  070E0                                     XOR s0, E0                                      ; toggle all bits and then add 1
 26E  071FF                                     XOR s1, FF
 26F  072FF                                     XOR s2, FF
 270  073FF                                     XOR s3, FF
 271  074FF                                     XOR s4, FF
 272  075FF                                     XOR s5, FF
 273  076FF                                     XOR s6, FF
 274  0777F                                     XOR s7, 7F
 275  11020                                     ADD s0, 20                                      ; Add 1 to the sticky bit
 276  13100                                     ADDCY s1, 00
 277  13200                                     ADDCY s2, 00
 278  13300                                     ADDCY s3, 00
 279  13400                                     ADDCY s4, 00
 27A  13500                                     ADDCY s5, 00
 27B  13600                                     ADDCY s6, 00
 27C  13700                                     ADDCY s7, 00
 27D  01880                                     LOAD s8, 80
 27E  2F82E                                     STORE s8, 2E[r_sign]
 27F  22282                                     JUMP 282[sign_calc_done]
 280                           dont_apply_twos: 
 280  01800                                     LOAD s8, 00
 281  2F82E                                     STORE s8, 2E[r_sign]
 282                            sign_calc_done: 
 282                                            ; TEST s7, 10
 282                                            ; JUMP Z, carry_not_found_dont_shift_right_by_one
 282                                            ; carry found
 282                                            ; SR0  s7    ; shift left by 1
 282                                            ; SRA s6
 282                                            ; SRA s5
 282                                            ; SRA s4
 282                                            ; SRA s3
 282                                            ; SRA s2
 282                                            ; SRA s1
 282                                            ; SRA s0
 282                                            ; FETCH s8, r_ex6    ; Yes: Increment exponent by 1
 282                                            ; FETCH s9, r_ex7
 282                                            ; ADD  s8, 01
 282                                            ; ADDCY s9, 00
 282                                            ; STORE s8, r_ex6
 282                                            ; STORE s9, r_ex7
 282                                            ; JUMP no_carry
 282                                            ;carry_not_found_dont_shift_right_by_one:
 282                                            ; There is carry so apply 2'scomplement
 282                                            ; Check both operands are normal
 282                                            ;FETCH  sF, op1_status
 282                                            ;FETCH  sE, op2_status
 282                                            ;AND  sF, sE
 282                                            ;TEST sF, 01
 282                                            ;JUMP NZ, both_ops_normals
 282                                            ;JUMP no_carry
 282                                            ;both_ops_normals:  ; here 20 in s7 means overflow
 282                                            ; SR0  s7    ; shift left by 1
 282                                            ; SRA s6
 282                                            ; SRA s5
 282                                            ; SRA s4
 282                                            ; SRA s3
 282                                            ; SRA s2
 282                                            ; SRA s1
 282                                            ; SRA s0
 282                                            ; FETCH s8, r_ex6    ; Yes: Increment exponent by 1
 282                                            ; FETCH s9, r_ex7
 282                                            ; ADD  s8, 01
 282                                            ; ADDCY s9, 00
 282                                            ; STORE s8, r_ex6
 282                                            ; STORE s9, r_ex7
 282                                            ;no_carry:
 282                                            ;TEST s7, 40
 282                                            ;JUMP Z, overflow_not_found
 282                                            ; overflow found
 282                                            ;overflow_not_found:
 282                                            ; Check both operands are subnormals
 282                                            ; FETCH  sF, op1_status
 282                                            ; FETCH  sE, op2_status
 282                                            ; AND  sF, sE
 282                                            ; TEST sF, 80
 282                                            ; JUMP NZ, both_ops_subnormals
 282                                            ; Both ops not subnormal therefore normalize
 282  20407                                     CALL 407[normalize]                             ; normalize
 283  202E3                                     CALL 2E3[round]
 284  20407                                     CALL 407[normalize]                             ; normalize
 285  202E3                                     CALL 2E3[round]
 286  20407                                     CALL 407[normalize]                             ; normalize
 287                                            ;both_ops_subnormals:
 287                                            ; CALL  round
 287                                            ; Compose the result:
 287                                            ;  r exponent  = [s9, s8],
 287                                            ; r mantisa  = [s7, s6, ..., s1]
 287                                            ; r sign     = r_sign
 287                                            ; JUMP  normalizaion_done
 287                                            ;dont_normalize_as_both_are_subnormals:
 287                                            ; TEST s7, 10 ; Subnormals addition produced carry?
 287                                            ; JUMP Z, normalizaion_done  ; No
 287                                            ;normalizaion_done:
 287                                            ; Compose
 287  0B830                                     FETCH s8, 30[r_ex6]
 288  0B92F                                     FETCH s9, 2F[r_ex7]
 289  14806                                     SL0 s8
 28A  14900                                     SLA s9
 28B  14800                                     SLA s8
 28C  14900                                     SLA s9
 28D  14800                                     SLA s8
 28E  14900                                     SLA s9
 28F  14800                                     SLA s8
 290  14900                                     SLA s9
 291  0370F                                     AND s7, 0F
 292  04780                                     OR s7, s8
 293                                            ; Apply the result sign
 293  0BA2E                                     FETCH sA, 2E[r_sign]
 294  049A0                                     OR s9, sA
 295                                            ; Save the result in SMP
 295  2F117                                     STORE s1, 17[r_0]
 296  2F216                                     STORE s2, 16[r_1]
 297  2F315                                     STORE s3, 15[r_2]
 298  2F414                                     STORE s4, 14[r_3]
 299  2F513                                     STORE s5, 13[r_4]
 29A  2F612                                     STORE s6, 12[r_5]
 29B  2F711                                     STORE s7, 11[r_6]
 29C  2F910                                     STORE s9, 10[r_7]
 29D  25000                                     RETURN 
 29E                                            ;------------------------------------------------------------------------------------
 29E                                            ; Procedure:  load_mx()
 29E                                            ; Registers Used:
 29E                                            ;        Bank0 : s7, s6, ... , s0
 29E                                            ;    Bank1 : None
 29E                                            ;    SPM   : op1_status
 29E                                            ;
 29E                                            ; Arguments:
 29E                                            ;     Bank0 : None
 29E                                            ;    Bank1 : None
 29E                                            ;
 29E                                            ; Calls:   None
 29E                                            ;
 29E                                            ; RETs:   None
 29E                                            ;
 29E                                            ; RETURN Flags:  None
 29E                                            ;
 29E                                            ; Description: Load x oeprand mantisa to register s7 down to s0.
 29E                                            ;    - Hidden bit aleardy has been set in x_m6.
 29E                                            ;    - gsr bits apears in s0.
 29E                                            ;------------------------------------------------------------------------------------
 29E                                   load_mx: 
 29E                                            ; Load mx into registers
 29E  0B71B                                     FETCH s7, 1B[x_m6]
 29F  0B61C                                     FETCH s6, 1C[x_m5]
 2A0  0B51D                                     FETCH s5, 1D[x_m4]
 2A1  0B41E                                     FETCH s4, 1E[x_m3]
 2A2  0B31F                                     FETCH s3, 1F[x_m2]
 2A3  0B220                                     FETCH s2, 20[x_m1]
 2A4  0B121                                     FETCH s1, 21[x_m0]
 2A5  0B022                                     FETCH s0, 22[x_grs]
 2A6  25000                                     RETURN 
 2A7                                            ;------------------------------------------------------------------------------------
 2A7                                            ; Procedure:  load_my()
 2A7                                            ; Registers Used:
 2A7                                            ;        Bank0 : sF, sE, ... , s8
 2A7                                            ;    Bank1 : None
 2A7                                            ;    SPM   : op1_status
 2A7                                            ;
 2A7                                            ; Arguments:
 2A7                                            ;     Bank0 : None
 2A7                                            ;    Bank1 : None
 2A7                                            ;result_is_positive
 2A7                                            ; Calls:   None
 2A7                                            ;
 2A7                                            ; RETs:   None
 2A7                                            ;
 2A7                                            ; RETURN Flags:  None
 2A7                                            ;
 2A7                                            ; Description: Load y oeprand mantisa to register sF down to s8.
 2A7                                            ;    - Hidden bit aleardy has been set in x_m6.
 2A7                                            ;    - gsr bits apears in s0.
 2A7                                            ;------------------------------------------------------------------------------------
 2A7                                   load_my: 
 2A7                                            ; Load mx into registers
 2A7  0BF26                                     FETCH sF, 26[y_m6]
 2A8  0BE27                                     FETCH sE, 27[y_m5]
 2A9  0BD28                                     FETCH sD, 28[y_m4]
 2AA  0BC29                                     FETCH sC, 29[y_m3]
 2AB  0BB2A                                     FETCH sB, 2A[y_m2]
 2AC  0BA2B                                     FETCH sA, 2B[y_m1]
 2AD  0B92C                                     FETCH s9, 2C[y_m0]
 2AE  0B82D                                     FETCH s8, 2D[y_grs]
 2AF  25000                                     RETURN 
 2B0                                            ;------------------------------------------------------------------------------------
 2B0                                            ; Procedure:   swap_operands()
 2B0                                            ;
 2B0                                            ; Registers Used: Bank0 : None
 2B0                                            ;     Bank1 : All
 2B0                                            ;
 2B0                                            ; Arguments:   Bank0 : None
 2B0                                            ;     Bank1 : None
 2B0                                            ;
 2B0                                            ; Calls:    None
 2B0                                            ;
 2B0                                            ; RETs:    None
 2B0                                            ;
 2B0                                            ; RETURN Flags:   None
 2B0                                            ;
 2B0                                            ; Description:  Loads two sample operands into SPM for performing arithmatic
 2B0                                            ;     operations on them in test environment.
 2B0                                            ;------------------------------------------------------------------------------------
 2B0                             swap_operands: 
 2B0  37001                                     REGBANK B
 2B1  0B700                                     FETCH s7, 00[x_7]
 2B2  0B601                                     FETCH s6, 01[x_6]
 2B3  0B502                                     FETCH s5, 02[x_5]
 2B4  0B403                                     FETCH s4, 03[x_4]
 2B5  0B304                                     FETCH s3, 04[x_3]
 2B6  0B205                                     FETCH s2, 05[x_2]
 2B7  0B106                                     FETCH s1, 06[x_1]
 2B8  0B007                                     FETCH s0, 07[x_0]
 2B9  0B822                                     FETCH s8, 22[x_grs]
 2BA  0BF08                                     FETCH sF, 08[y_7]
 2BB  0BE09                                     FETCH sE, 09[y_6]
 2BC  0BD0A                                     FETCH sD, 0A[y_5]
 2BD  0BC0B                                     FETCH sC, 0B[y_4]
 2BE  0BB0C                                     FETCH sB, 0C[y_3]
 2BF  0BA0D                                     FETCH sA, 0D[y_2]
 2C0  0B90E                                     FETCH s9, 0E[y_1]
 2C1  2F708                                     STORE s7, 08[y_7]
 2C2  2F609                                     STORE s6, 09[y_6]
 2C3  2F50A                                     STORE s5, 0A[y_5]
 2C4  2F40B                                     STORE s4, 0B[y_4]
 2C5  2F30C                                     STORE s3, 0C[y_3]
 2C6  2F20D                                     STORE s2, 0D[y_2]
 2C7  2F10E                                     STORE s1, 0E[y_1]
 2C8  0B70F                                     FETCH s7, 0F[y_0]
 2C9  0B62D                                     FETCH s6, 2D[y_grs]
 2CA  2F00F                                     STORE s0, 0F[y_0]
 2CB  2F82D                                     STORE s8, 2D[y_grs]
 2CC  2FF00                                     STORE sF, 00[x_7]
 2CD  2FE01                                     STORE sE, 01[x_6]
 2CE  2FD02                                     STORE sD, 02[x_5]
 2CF  2FC03                                     STORE sC, 03[x_4]
 2D0  2FB04                                     STORE sB, 04[x_3]
 2D1  2FA05                                     STORE sA, 05[x_2]
 2D2  2F906                                     STORE s9, 06[x_1]
 2D3  2F707                                     STORE s7, 07[x_0]
 2D4  2F622                                     STORE s6, 22[x_grs]
 2D5                                            ; Swap the operands' status
 2D5  0B53A                                     FETCH s5, 3A[op1_status]
 2D6  0B63B                                     FETCH s6, 3B[op2_status]
 2D7  2F53B                                     STORE s5, 3B[op2_status]
 2D8  2F63A                                     STORE s6, 3A[op1_status]
 2D9  202FA                                     CALL 2FA[decompose_x]
 2DA  20324                                     CALL 324[decompose_y]
 2DB  37000                                     REGBANK A
 2DC  25000                                     RETURN 
 2DD                                            ;------------------------------------------------------------------------------------
 2DD                                            ; Procedure:  count_nlz()
 2DD                                            ; Registers Used:
 2DD                                            ;        Bank0 : s8, s9
 2DD                                            ;    Bank1 : None
 2DD                                            ;
 2DD                                            ; Arguments:
 2DD                                            ;     Bank0 : s8
 2DD                                            ;    Bank1 : None
 2DD                                            ;
 2DD                                            ; Calls:   None
 2DD                                            ;
 2DD                                            ; RETs:   s9: number of leading zeros
 2DD                                            ;
 2DD                                            ; RETURN Flags:  None
 2DD                                            ;
 2DD                                            ; Description: Counts the number of leading zeros in a byte given in s8.
 2DD                                            ;------------------------------------------------------------------------------------
 2DD                                 count_nlz: 
 2DD  01900                                     LOAD s9, 00
 2DE                            count_mlz_loop: 
 2DE  14807                                     SL1 s8
 2DF  3A2E2                                     JUMP C, 2E2[counting_z_done]
 2E0  11901                                     ADD s9, 01                                      ; Increament z by 1
 2E1  222DE                                     JUMP 2DE[count_mlz_loop]
 2E2                           counting_z_done: 
 2E2  25000                                     RETURN 
 2E3                                            ;------------------------------------------------------------------------------------
 2E3                                            ; Procedure:  round()
 2E3                                            ;
 2E3                                            ; Registers Used: Bank0 : s8
 2E3                                            ;     Bank1 : None
 2E3                                            ;
 2E3                                            ; Arguments:   Bank0 : [s1,s0]
 2E3                                            ;     Bank1 : None
 2E3                                            ;
 2E3                                            ; Calls:    None
 2E3                                            ;
 2E3                                            ; RETs:    None
 2E3                                            ;
 2E3                                            ; RETURN Flags:   None
 2E3                                            ;
 2E3                                            ; Description:  This procedure receives guard-sticky-round bits in s0 register
 2E3                                            ;    and RETs 0 or 1 in s0 based on rounding algorith. s1 hold the
 2E3                                            ;   Least signifficant byte.
 2E3                                            ;
 2E3                                            ;
 2E3                                            ; Check the guard bit
 2E3                                            ;  If Gaurd bit = 0 : Round down (Do nothing - simple truncation)
 2E3                                            ;  If Gaurd bit = 1, Check the Round bit
 2E3                                            ; If Gaurd bit = 1, and Round bit = 1 : Round Up (add 1 to mantissa)
 2E3                                            ; If Gaurd bit = 1, and Round bit = 0 : Check the Sticky bit
 2E3                                            ; If Gaurd bit = 1, and Round bit = 0 , and Sticky bit = 1 : Round Up (add 1 to mantissa)
 2E3                                            ; If Gaurd bit = 1, and Round bit = 0 , and Sticky bit = 0 : Round to nearest even.
 2E3                                            ;    Means round up if bitbefore Guard bit is 1, else round down.
 2E3                                            ;------------------------------------------------------------------------------------
 2E3                                     round: 
 2E3                                            ; -------------------------------------------------
 2E3                                            ; Rounding:
 2E3                                            ; Check the guard bit - s0[7]
 2E3  0D080                                     TEST s0, 80
 2E4  362E6                                     JUMP NZ, 2E6[guard_bit_is_1]
 2E5                                            ; Gaurd bit = 0 : Round down (Do  nothing)
 2E5  222F0                                     JUMP 2F0[round_RET_zero]
 2E6                            guard_bit_is_1: 
 2E6                                            ; Gaurd bit = 1, Check the round bit
 2E6  0D040                                     TEST s0, 40
 2E7  322E9                                     JUMP Z, 2E9[round_bit_is_0]
 2E8                                            ; Gaurd bit = 1, Round bit = 1 : Round Up (add 1 to mantissa)
 2E8  222ED                                     JUMP 2ED[round_RET_one]
 2E9                            round_bit_is_0: 
 2E9                                            ; Gaurd bit = 1, Round bit = 0 : Check the Sticky bit
 2E9  0D020                                     TEST s0, 20
 2EA  362ED                                     JUMP NZ, 2ED[round_RET_one]                     ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 1 : Round Up (add 1 to mantissa)
 2EB                                            ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 0 : Round to nearest even,
 2EB                                            ;       Means round up if bit before Guard bit is 1, else round down.
 2EB  0D101                                     TEST s1, 01
 2EC  322F0                                     JUMP Z, 2F0[round_RET_zero]
 2ED                             round_RET_one: 
 2ED                                            ; To prevent double round up we  will zero the grs bits
 2ED  01000                                     LOAD s0, 00                                     ; s0 holing the grs bits of the result
 2EE  01801                                     LOAD s8, 01
 2EF  222F2                                     JUMP 2F2[apply_rounding]
 2F0                            round_RET_zero: 
 2F0                                            ; To prevent double round up we  will zero the grs bits
 2F0  01000                                     LOAD s0, 00                                     ; s0 holing the grs bits of the result
 2F1  01800                                     LOAD s8, 00
 2F2                            apply_rounding: 
 2F2                                            ; Apply rounding
 2F2  10180                                     ADD s1, s8
 2F3  13200                                     ADDCY s2, 00
 2F4  13300                                     ADDCY s3, 00
 2F5  13400                                     ADDCY s4, 00
 2F6  13500                                     ADDCY s5, 00
 2F7  13600                                     ADDCY s6, 00
 2F8  13700                                     ADDCY s7, 00
 2F9  25000                                     RETURN 
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                                            ; Procedure:   normalize()
 2FA                                            ;
 2FA                                            ; Registers Used: Bank0 :
 2FA                                            ;     Bank1 : None
 2FA                                            ;
 2FA                                            ; Arguments:   Bank0 :
 2FA                                            ;     Bank1 : None
 2FA                                            ;
 2FA                                            ; Calls:    None
 2FA                                            ;
 2FA                                            ; RETs:    None
 2FA                                            ;
 2FA                                            ; RETURN Flags:   None
 2FA                                            ;
 2FA                                            ; Description:  Normalizes a given number
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                                            ; Procedure:   decompose_x()
 2FA                                            ;
 2FA                                            ; Registers Used: Bank0 : s7, s6, ..., s0
 2FA                                            ;     Bank1 : None
 2FA                                            ;
 2FA                                            ; Arguments:   Bank0 : None
 2FA                                            ;     Bank1 : None
 2FA                                            ;     SPM   : x_7, x_6, ..., x_0
 2FA                                            ;
 2FA                                            ; Calls:    None
 2FA                                            ;
 2FA                                            ; RETs:    None
 2FA                                            ;
 2FA                                            ; RETURN Flags:   None
 2FA                                            ;
 2FA                                            ; Description:  Extracts sign, exonent, and mantisa from given 64-bit number
 2FA                                            ;------------------------------------------------------------------------------------
 2FA                               decompose_x: 
 2FA  0B700                                     FETCH s7, 00[x_7]
 2FB  0D780                                     TEST s7, 80
 2FC  362FF                                     JUMP NZ, 2FF[negative_sign_x]
 2FD  01000                                     LOAD s0, 00                                     ; positive = 00
 2FE  22300                                     JUMP 300[test_x_sign_done]
 2FF                           negative_sign_x: 
 2FF  01080                                     LOAD s0, 80                                     ; positive = 80
 300                          test_x_sign_done: 
 300  2F018                                     STORE s0, 18[x_sign]                            ; set the sign
 301  0B601                                     FETCH s6, 01[x_6]
 302  0377F                                     AND s7, 7F                                      ; Zero the sign bit
 303                                            ; Shift right by 4 bits to remove the 4-bits of mantisa on the low
 303                                            ; nibble of s6.
 303  1470E                                     SR0 s7
 304  14608                                     SRA s6
 305  1470E                                     SR0 s7
 306  14608                                     SRA s6
 307  1470E                                     SR0 s7
 308  14608                                     SRA s6
 309  1470E                                     SR0 s7
 30A  14608                                     SRA s6
 30B                                            ; Save extracted exponent in SPM
 30B  2F719                                     STORE s7, 19[x_ex7]
 30C  2F61A                                     STORE s6, 1A[x_ex6]
 30D                                            ;Is x subnormal? yes: inject hidden 0, No: Inject hidden 1
 30D  0B03A                                     FETCH s0, 3A[op1_status]
 30E  0D080                                     TEST s0, 80
 30F  36312                                     JUMP NZ, 312[subnormal_involved_x]
 310                                            ; not a subnormal
 310  01010                                     LOAD s0, 10
 311  22313                                     JUMP 313[subnormal_test_done_x]
 312                      subnormal_involved_x: 
 312  01000                                     LOAD s0, 00
 313                     subnormal_test_done_x: 
 313  0B601                                     FETCH s6, 01[x_6]                               ; Recover bit no 6
 314  0360F                                     AND s6, 0F                                      ; Zero the high nibble
 315  04600                                     OR s6, s0
 316  2F61B                                     STORE s6, 1B[x_m6]                              ; Save extracted mantisa in SPM
 317  0B502                                     FETCH s5, 02[x_5]
 318  0B403                                     FETCH s4, 03[x_4]
 319  0B304                                     FETCH s3, 04[x_3]
 31A  0B205                                     FETCH s2, 05[x_2]
 31B  0B106                                     FETCH s1, 06[x_1]
 31C  0B007                                     FETCH s0, 07[x_0]
 31D  2F51C                                     STORE s5, 1C[x_m5]
 31E  2F41D                                     STORE s4, 1D[x_m4]
 31F  2F31E                                     STORE s3, 1E[x_m3]
 320  2F21F                                     STORE s2, 1F[x_m2]
 321  2F120                                     STORE s1, 20[x_m1]
 322  2F021                                     STORE s0, 21[x_m0]
 323  25000                                     RETURN 
 324                                            ;------------------------------------------------------------------------------------
 324                                            ; Procedure:   decompose_y()
 324                                            ;
 324                                            ; Registers Used: Bank0 : sF, sE, ..., s8
 324                                            ;     Bank1 : None
 324                                            ;
 324                                            ; Arguments:   Bank0 : None
 324                                            ;     Bank1 : None
 324                                            ;     SPM   : y_7, y_6, ..., y_0
 324                                            ;
 324                                            ; Calls:    None
 324                                            ;
 324                                            ; RETs:    None
 324                                            ;
 324                                            ; RETURN Flags:   None
 324                                            ;
 324                                            ; Description:  Extracts sign, exonent, and mantisa from given 64-bit number
 324                                            ;------------------------------------------------------------------------------------
 324                               decompose_y: 
 324  0B708                                     FETCH s7, 08[y_7]
 325  0D780                                     TEST s7, 80
 326  36329                                     JUMP NZ, 329[negative_sign_y]
 327                           positive_sign_y: 
 327  01000                                     LOAD s0, 00                                     ; positive = 00
 328  2232A                                     JUMP 32A[test_y_sign_done]
 329                           negative_sign_y: 
 329  01080                                     LOAD s0, 80                                     ; positive = 80
 32A                          test_y_sign_done: 
 32A  2F023                                     STORE s0, 23[y_sign]                            ; set the sign
 32B  0B609                                     FETCH s6, 09[y_6]
 32C  0377F                                     AND s7, 7F                                      ; Zero the sign bit
 32D                                            ; Shift right by 4 bits to remove the 4-bits of mantisa on the low
 32D                                            ; nibble of s6.
 32D  1470E                                     SR0 s7
 32E  14608                                     SRA s6
 32F  1470E                                     SR0 s7
 330  14608                                     SRA s6
 331  1470E                                     SR0 s7
 332  14608                                     SRA s6
 333  1470E                                     SR0 s7
 334  14608                                     SRA s6
 335                                            ; Save extracted exponent in SPM
 335  2F724                                     STORE s7, 24[y_ex7]
 336  2F625                                     STORE s6, 25[y_ex6]
 337                                            ;Is x subnormal? yes: inject hidden 0, No: Inject hidden 1
 337  0B03B                                     FETCH s0, 3B[op2_status]
 338  0D080                                     TEST s0, 80
 339  3633C                                     JUMP NZ, 33C[subnormal_involved_y]
 33A                                            ; not a subnormal
 33A  01010                                     LOAD s0, 10
 33B  2233D                                     JUMP 33D[subnormal_test_done_y]
 33C                      subnormal_involved_y: 
 33C  01000                                     LOAD s0, 00
 33D                     subnormal_test_done_y: 
 33D  0B609                                     FETCH s6, 09[y_6]                               ; Recover bit no 6
 33E  0360F                                     AND s6, 0F                                      ; Zero the high nibble
 33F  04600                                     OR s6, s0
 340  2F626                                     STORE s6, 26[y_m6]                              ; Save extracted mantisa in SPM
 341  0B50A                                     FETCH s5, 0A[y_5]
 342  0B40B                                     FETCH s4, 0B[y_4]
 343  0B30C                                     FETCH s3, 0C[y_3]
 344  0B20D                                     FETCH s2, 0D[y_2]
 345  0B10E                                     FETCH s1, 0E[y_1]
 346  0B00F                                     FETCH s0, 0F[y_0]
 347  2F527                                     STORE s5, 27[y_m5]
 348  2F428                                     STORE s4, 28[y_m4]
 349  2F329                                     STORE s3, 29[y_m3]
 34A  2F22A                                     STORE s2, 2A[y_m2]
 34B  2F12B                                     STORE s1, 2B[y_m1]
 34C  2F02C                                     STORE s0, 2C[y_m0]
 34D  25000                                     RETURN 
 34E                                            ;------------------------------------------------------------------------------------
 34E                                            ; Procedure:   set_ops_status()
 34E                                            ;
 34E                                            ; Registers Used: Bank0 :
 34E                                            ;     Bank1 : None
 34E                                            ;     SPM   : x_7, x_6, y_7, y_6
 34E                                            ;
 34E                                            ; Arguments:   Bank0 :
 34E                                            ;     Bank1 : None
 34E                                            ;
 34E                                            ; Calls:    None
 34E                                            ;     None
 34E                                            ;
 34E                                            ; RETs:    SPM:
 34E                                            ;      op1_status
 34E                                            ;       op2_status
 34E                                            ;
 34E                                            ; RETURN Flags:   None
 34E                                            ;
 34E                                            ; Description:  Set op1 and op2 status flags: Check for subnormals, zeros,
 34E                                            ;      NaNs and infinities.
 34E                                            ;------------------------------------------------------------------------------------
 34E                            set_ops_status: 
 34E                                            ; Check if the op1 (ex) exponent bits subnormalare all zero
 34E                                            ; Extract ex : [s7, s6]
 34E  0B700                                     FETCH s7, 00[x_7]
 34F  0B601                                     FETCH s6, 01[x_6]
 350  0377F                                     AND s7, 7F                                      ; zero the sign bit
 351  0D6F0                                     TEST s6, F0
 352  0F77F                                     TESTCY s7, 7F
 353  36373                                     JUMP NZ, 373[ex_not_zero]
 354                                   ex_zero: 
 354                                            ; Load x mantisa into registers
 354  0B601                                     FETCH s6, 01[x_6]
 355  0B502                                     FETCH s5, 02[x_5]
 356  0B403                                     FETCH s4, 03[x_4]
 357  0B304                                     FETCH s3, 04[x_3]
 358  0B205                                     FETCH s2, 05[x_2]
 359  0B106                                     FETCH s1, 06[x_1]
 35A  0B007                                     FETCH s0, 07[x_0]
 35B  0D60F                                     TEST s6, 0F
 35C  0F5FF                                     TESTCY s5, FF
 35D  0F4FF                                     TESTCY s4, FF
 35E  0F3FF                                     TESTCY s3, FF
 35F  0F2FF                                     TESTCY s2, FF
 360  0F1FF                                     TESTCY s1, FF
 361  0F0FF                                     TESTCY s0, FF
 362  3636F                                     JUMP NZ, 36F[op1_is_subnormal]
 363  1490E                                     SR0 s9                                          ; Shift to right by 4
 364  14808                                     SRA s8
 365  1490E                                     SR0 s9
 366  14808                                     SRA s8
 367  1490E                                     SR0 s9
 368  14808                                     SRA s8
 369  1490E                                     SR0 s9
 36A  14808                                     SRA s8
 36B                              op_1_is_zero: 
 36B                                            ; set op1 status flag to "Zero"   -- status bits = SZIN
 36B  0B03A                                     FETCH s0, 3A[op1_status]
 36C  05040                                     OR s0, 40                                       ; op1 is zero
 36D  2F03A                                     STORE s0, 3A[op1_status]
 36E  22394                                     JUMP 394[set_op2_status]
 36F                          op1_is_subnormal: 
 36F                                            ; set op1 status flag to "Subnormal"
 36F  0B03A                                     FETCH s0, 3A[op1_status]
 370  05080                                     OR s0, 80                                       ; op1 is subnormal
 371  2F03A                                     STORE s0, 3A[op1_status]
 372  22394                                     JUMP 394[set_op2_status]
 373                               ex_not_zero: 
 373                                            ; Check if the op1 (ex) exponent bits are all one
 373                                            ; Extract ex : [s7, s6]
 373  0B700                                     FETCH s7, 00[x_7]
 374  0B601                                     FETCH s6, 01[x_6]
 375  0377F                                     AND s7, 7F                                      ; zero the sign bit
 376  036F0                                     AND s6, F0                                      ; zero the low nibble
 377  1D6F0                                     COMPARE s6, F0
 378  1F77F                                     COMPARECY s7, 7F
 379  36391                                     JUMP NZ, 391[ex_not_all_one]
 37A                                ex_all_one: 
 37A                                            ; Load x mantisa into registers
 37A  0B601                                     FETCH s6, 01[x_6]
 37B  0B502                                     FETCH s5, 02[x_5]
 37C  0B403                                     FETCH s4, 03[x_4]
 37D  0B304                                     FETCH s3, 04[x_3]
 37E  0B205                                     FETCH s2, 05[x_2]
 37F  0B106                                     FETCH s1, 06[x_1]
 380  0B007                                     FETCH s0, 07[x_0]
 381                                            ; Check if all bits of significand are zero
 381  0D60F                                     TEST s6, 0F
 382  0F5FF                                     TESTCY s5, FF
 383  0F4FF                                     TESTCY s4, FF
 384  0F3FF                                     TESTCY s3, FF
 385  0F2FF                                     TESTCY s2, FF
 386  0F1FF                                     TESTCY s1, FF
 387  0F0FF                                     TESTCY s0, FF
 388  3238D                                     JUMP Z, 38D[op1_is_inf]
 389                                op1_is_NaN: 
 389                                            ; set op1 status flag to "NaN" -- status bits = SZIN --
 389  0B03A                                     FETCH s0, 3A[op1_status]
 38A  05010                                     OR s0, 10                                       ; op1 is NaN
 38B  2F03A                                     STORE s0, 3A[op1_status]
 38C  22394                                     JUMP 394[set_op2_status]
 38D                                op1_is_inf: 
 38D                                            ; set op1 status flag to "Infinite"
 38D  0B03A                                     FETCH s0, 3A[op1_status]
 38E  05020                                     OR s0, 20                                       ; op1 is infinite
 38F  2F03A                                     STORE s0, 3A[op1_status]
 390  22394                                     JUMP 394[set_op2_status]
 391                            ex_not_all_one: 
 391                                            ; Here we conclude that ex is not all zeros and not all ones.
 391                                            ;  therefore op1 must be a normal operand.
 391                                            ; set op1 status flag to "Infinite"
 391  0B03A                                     FETCH s0, 3A[op1_status]
 392  05001                                     OR s0, 01                                       ; op1 is normal
 393  2F03A                                     STORE s0, 3A[op1_status]
 394                            set_op2_status: 
 394                                            ; Check if the op2 (ey) exponent bits are all zero
 394                                            ; Extract ex : [s7, s6]
 394  0B708                                     FETCH s7, 08[y_7]
 395  0B609                                     FETCH s6, 09[y_6]
 396  0377F                                     AND s7, 7F                                      ; zero the sign bit
 397  0D6F0                                     TEST s6, F0
 398  0F77F                                     TESTCY s7, 7F
 399  363B1                                     JUMP NZ, 3B1[ey_not_zero]
 39A                                   ey_zero: 
 39A                                            ; Load y mantisa into registers
 39A  0BF09                                     FETCH sF, 09[y_6]
 39B  0BE0A                                     FETCH sE, 0A[y_5]
 39C  0BD0B                                     FETCH sD, 0B[y_4]
 39D  0BC0C                                     FETCH sC, 0C[y_3]
 39E  0BB0D                                     FETCH sB, 0D[y_2]
 39F  0BA0E                                     FETCH sA, 0E[y_1]
 3A0  0B90F                                     FETCH s9, 0F[y_0]
 3A1                                            ; Check if all bits of significand are zero
 3A1  0DF0F                                     TEST sF, 0F
 3A2  0FEFF                                     TESTCY sE, FF
 3A3  0FDFF                                     TESTCY sD, FF
 3A4  0FCFF                                     TESTCY sC, FF
 3A5  0FBFF                                     TESTCY sB, FF
 3A6  0FAFF                                     TESTCY sA, FF
 3A7  0F9FF                                     TESTCY s9, FF
 3A8  363AD                                     JUMP NZ, 3AD[op2_is_subnormal]
 3A9                              op_2_is_zero: 
 3A9                                            ; set op1 status flag to "Zero"   -- status bits = SZIN --
 3A9  0B03B                                     FETCH s0, 3B[op2_status]
 3AA  05040                                     OR s0, 40                                       ; op2 is zero
 3AB  2F03B                                     STORE s0, 3B[op2_status]
 3AC  25000                                     RETURN 
 3AD                          op2_is_subnormal: 
 3AD                                            ; set op1 status flag to "Subnormal"
 3AD  0B03B                                     FETCH s0, 3B[op2_status]
 3AE  05080                                     OR s0, 80                                       ; op1 is subnormal
 3AF  2F03B                                     STORE s0, 3B[op2_status]
 3B0  25000                                     RETURN 
 3B1                               ey_not_zero: 
 3B1                                            ; Check if the op2 (ex) exponent bits are all one
 3B1                                            ; Extract ex : [s7, s6]
 3B1  0B708                                     FETCH s7, 08[y_7]
 3B2  0B609                                     FETCH s6, 09[y_6]
 3B3  0377F                                     AND s7, 7F                                      ; zero the sign bit
 3B4  036F0                                     AND s6, F0                                      ; zero the low nibble
 3B5  1D6F0                                     COMPARE s6, F0
 3B6  1F77F                                     COMPARECY s7, 7F
 3B7  363CF                                     JUMP NZ, 3CF[ey_not_all_one]
 3B8                                ey_all_one: 
 3B8                                            ; Load y mantisa into registers
 3B8  0BF09                                     FETCH sF, 09[y_6]
 3B9  0BE0A                                     FETCH sE, 0A[y_5]
 3BA  0BD0B                                     FETCH sD, 0B[y_4]
 3BB  0BC0C                                     FETCH sC, 0C[y_3]
 3BC  0BB0D                                     FETCH sB, 0D[y_2]
 3BD  0BA0E                                     FETCH sA, 0E[y_1]
 3BE  0B90F                                     FETCH s9, 0F[y_0]
 3BF                                            ; Check if all bits of significand are zero
 3BF  0DF0F                                     TEST sF, 0F
 3C0  0FEFF                                     TESTCY sE, FF
 3C1  0FDFF                                     TESTCY sD, FF
 3C2  0FCFF                                     TESTCY sC, FF
 3C3  0FBFF                                     TESTCY sB, FF
 3C4  0FAFF                                     TESTCY sA, FF
 3C5  0F9FF                                     TESTCY s9, FF
 3C6  323CB                                     JUMP Z, 3CB[op2_is_inf]
 3C7                                op2_is_NaN: 
 3C7                                            ; set op1 status flag to "NaN" -- status bits = SZIN --
 3C7  0B03B                                     FETCH s0, 3B[op2_status]
 3C8  05010                                     OR s0, 10                                       ; op1 is NaN
 3C9  2F03B                                     STORE s0, 3B[op2_status]
 3CA  25000                                     RETURN 
 3CB                                op2_is_inf: 
 3CB                                            ; set op1 status flag to "Infinite"
 3CB  0B03B                                     FETCH s0, 3B[op2_status]
 3CC  05020                                     OR s0, 20                                       ; op1 is infinite
 3CD  2F03B                                     STORE s0, 3B[op2_status]
 3CE  25000                                     RETURN 
 3CF                            ey_not_all_one: 
 3CF                                            ; Here we conclude that ey is not all zeros and not all ones.
 3CF                                            ;  therefore op1 must be a normal operand.
 3CF  0B03B                                     FETCH s0, 3B[op2_status]
 3D0  05001                                     OR s0, 01                                       ; op2 is normal
 3D1  2F03B                                     STORE s0, 3B[op2_status]
 3D2  25000                                     RETURN 
 3D3                                            ;------------------------------------------------------------------------------------
 3D3                                            ; Procedure:   twos_mx()
 3D3                                            ;
 3D3                                            ; Registers Used: Bank0 :
 3D3                                            ;     Bank1 : None
 3D3                                            ;     SPM   : x_m7, x_m6, ... x_m0
 3D3                                            ;
 3D3                                            ; Arguments:   Bank0 :
 3D3                                            ;     Bank1 : None
 3D3                                            ;
 3D3                                            ; Calls:    None
 3D3                                            ;     None
 3D3                                            ;
 3D3                                            ; RETs:    SPM:
 3D3                                            ;
 3D3                                            ; RETURN Flags:   None
 3D3                                            ;
 3D3                                            ; Description:  Calcultes the twos complement of mx and replace it
 3D3                                            ;      with the result
 3D3                                            ;------------------------------------------------------------------------------------
 3D3                                   twos_mx: 
 3D3  2029E                                     CALL 29E[load_mx]                               ; Load hidden bit+mantisa+guard bits(grs) [s7, s0]
 3D4  070E0                                     XOR s0, E0                                      ; toggle all bits
 3D5  071FF                                     XOR s1, FF
 3D6  072FF                                     XOR s2, FF
 3D7  073FF                                     XOR s3, FF
 3D8  074FF                                     XOR s4, FF
 3D9  075FF                                     XOR s5, FF
 3DA  076FF                                     XOR s6, FF
 3DB  0777F                                     XOR s7, 7F
 3DC  11020                                     ADD s0, 20                                      ; Add 1 to the sticky bit
 3DD  13100                                     ADDCY s1, 00
 3DE  13200                                     ADDCY s2, 00
 3DF  13300                                     ADDCY s3, 00
 3E0  13400                                     ADDCY s4, 00
 3E1  13500                                     ADDCY s5, 00
 3E2  13600                                     ADDCY s6, 00
 3E3  13700                                     ADDCY s7, 00
 3E4  2F71B                                     STORE s7, 1B[x_m6]                              ; Save back the shifted mantisa into SPM
 3E5  2F61C                                     STORE s6, 1C[x_m5]
 3E6  2F51D                                     STORE s5, 1D[x_m4]
 3E7  2F41E                                     STORE s4, 1E[x_m3]
 3E8  2F31F                                     STORE s3, 1F[x_m2]
 3E9  2F220                                     STORE s2, 20[x_m1]
 3EA  2F121                                     STORE s1, 21[x_m0]
 3EB  2F022                                     STORE s0, 22[x_grs]
 3EC  25000                                     RETURN 
 3ED                                            ;------------------------------------------------------------------------------------
 3ED                                            ; Procedure:   twos_my()
 3ED                                            ;
 3ED                                            ; Registers Used: Bank0 :
 3ED                                            ;     Bank1 : None
 3ED                                            ;     SPM   : x_m7, x_m6, ... x_m0
 3ED                                            ;
 3ED                                            ; Arguments:   Bank0 :
 3ED                                            ;     Bank1 : None
 3ED                                            ;
 3ED                                            ; Calls:    None
 3ED                                            ;     None
 3ED                                            ;
 3ED                                            ; RETs:    SPM:
 3ED                                            ;
 3ED                                            ; RETURN Flags:   None
 3ED                                            ;
 3ED                                            ; Description:  Calcultes the twos complement of my and replace it
 3ED                                            ;      with the result
 3ED                                            ;------------------------------------------------------------------------------------
 3ED                                   twos_my: 
 3ED  202A7                                     CALL 2A7[load_my]                               ; Load hidden bit+mantisa+guard bits(grs) [sF, s8]
 3EE  078E0                                     XOR s8, E0                                      ; toggle all bits
 3EF  079FF                                     XOR s9, FF
 3F0  07AFF                                     XOR sA, FF
 3F1  07BFF                                     XOR sB, FF
 3F2  07CFF                                     XOR sC, FF
 3F3  07DFF                                     XOR sD, FF
 3F4  07EFF                                     XOR sE, FF
 3F5  07F7F                                     XOR sF, 7F
 3F6  11820                                     ADD s8, 20                                      ; Add 1 to the sticky bit
 3F7  13900                                     ADDCY s9, 00
 3F8  13A00                                     ADDCY sA, 00
 3F9  13B00                                     ADDCY sB, 00
 3FA  13C00                                     ADDCY sC, 00
 3FB  13D00                                     ADDCY sD, 00
 3FC  13E00                                     ADDCY sE, 00
 3FD  13F00                                     ADDCY sF, 00
 3FE  2FF26                                     STORE sF, 26[y_m6]                              ; Save back the shifted mantisa into SPM
 3FF  2FE27                                     STORE sE, 27[y_m5]
 400  2FD28                                     STORE sD, 28[y_m4]
 401  2FC29                                     STORE sC, 29[y_m3]
 402  2FB2A                                     STORE sB, 2A[y_m2]
 403  2FA2B                                     STORE sA, 2B[y_m1]
 404  2F92C                                     STORE s9, 2C[y_m0]
 405  2F82D                                     STORE s8, 2D[y_grs]
 406  25000                                     RETURN 
 407                                            ;------------------------------------------------------------------------------------
 407                                            ; Procedure:   normalize()
 407                                            ;
 407                                            ; Registers Used: Bank0 : s7, s6, ..., s0: Hidden bit + mantisa + guard bits (grs)
 407                                            ;     Bank1 : None
 407                                            ;
 407                                            ; Arguments:   Bank0 : s7, s6, ..., s0: Hidden bit + mantisa + guard bits (grs)
 407                                            ;     Bank1 : None
 407                                            ;
 407                                            ; Calls:    None
 407                                            ;     None
 407                                            ;
 407                                            ; RETs:    SPM:
 407                                            ;
 407                                            ; RETURN Flags:   None
 407                                            ;
 407                                            ; Description:  Normalized the result saved in [s7, s6, ..., s0].
 407                                            ;------------------------------------------------------------------------------------
 407                                 normalize: 
 407  0D720                                     TEST s7, 20
 408  3241E                                     JUMP Z, 41E[no_overflow_found]
 409                                            ; Overflow detected
 409                                            ; if sticky bit of s0 is 1 keep it 1
 409  0D020                                     TEST s0, 20
 40A  3240D                                     JUMP Z, 40D[dont_keep_sticky_bit]
 40B  01F20                                     LOAD sF, 20
 40C  2240E                                     JUMP 40E[done_keeping_sticky_bit]
 40D                      dont_keep_sticky_bit: 
 40D  01F00                                     LOAD sF, 00
 40E                   done_keeping_sticky_bit: 
 40E  1470E                                     SR0 s7                                          ; shift left by 1
 40F  14608                                     SRA s6
 410  14508                                     SRA s5
 411  14408                                     SRA s4
 412  14308                                     SRA s3
 413  14208                                     SRA s2
 414  14108                                     SRA s1
 415  14008                                     SRA s0
 416  0B830                                     FETCH s8, 30[r_ex6]                             ; Yes: Increment exponent by 1
 417  0B92F                                     FETCH s9, 2F[r_ex7]
 418  11801                                     ADD s8, 01
 419  13900                                     ADDCY s9, 00
 41A  2F830                                     STORE s8, 30[r_ex6]
 41B  2F92F                                     STORE s9, 2F[r_ex7]
 41C  040F0                                     OR s0, sF
 41D  2248D                                     JUMP 48D[done_cancellation]
 41E                         no_overflow_found: 
 41E                                            ; Check if we need normalization or not
 41E  0D710                                     TEST s7, 10
 41F  32431                                     JUMP Z, 431[cancellation]                       ; Perform cancellation
 420                                            ; JUMP NZ, done_cancellation ; Perform cancellation
 420                      check_subnormal_case: 
 420                                            ; Check if both operands are subnormals
 420  0BF3A                                     FETCH sF, 3A[op1_status]
 421  0BE3B                                     FETCH sE, 3B[op2_status]
 422  02FE0                                     AND sF, sE
 423  0DF80                                     TEST sF, 80
 424  3248D                                     JUMP Z, 48D[done_cancellation]
 425                                            ; Both ops subnormal but bit4 of s7 is 1 => underflow detected
 425  0B83C                                     FETCH s8, 3C[underflow]
 426  0D801                                     TEST s8, 01
 427  3648D                                     JUMP NZ, 48D[done_cancellation]                 ; underflow already applied
 428                                            ; Both subnormals but we have 1 in bit 1 of s7 =< apply underflow
 428  0B830                                     FETCH s8, 30[r_ex6]                             ; Increment exponent by 1
 429  0B92F                                     FETCH s9, 2F[r_ex7]
 42A  11801                                     ADD s8, 01
 42B  13900                                     ADDCY s9, 00
 42C  2F830                                     STORE s8, 30[r_ex6]
 42D  2F92F                                     STORE s9, 2F[r_ex7]
 42E  01801                                     LOAD s8, 01                                     ; Set underflow applied bit
 42F  2F83C                                     STORE s8, 3C[underflow]
 430  2248D                                     JUMP 48D[done_cancellation]
 431                              cancellation: 
 431                                            ; Cancellation:
 431                                            ; Count the number of leading zeros = nlz
 431                                            ; Shift "mr" left by nlz, and set er = er - nlz
 431                                            ; Check if er is zero then the result is as it is
 431  0BB2F                                     FETCH sB, 2F[r_ex7]
 432  0BA30                                     FETCH sA, 30[r_ex6]
 433  0DA0F                                     TEST sA, 0F
 434  0FBFF                                     TESTCY sB, FF
 435  3248D                                     JUMP Z, 48D[done_cancellation]                  ; result is subnormal
 436                                            ; else perform cancellation
 436  01A01                                     LOAD sA, 01                                     ; nlz nounter
 437                                            ; zero the unused bit
 437  0377F                                     AND s7, 7F
 438  00870                                     LOAD s8, s7                                     ; make a copy of s7
 439  14807                                     SL1 s8
 43A  14807                                     SL1 s8
 43B  14807                                     SL1 s8
 43C  14807                                     SL1 s8
 43D                                            ; Count nlz in s8
 43D  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 43E  0D9FF                                     TEST s9, FF                                     ; is s9 = 0 ?
 43F  3246B                                     JUMP Z, 46B[nlz_counting_done]
 440  1D904                                     COMPARE s9, 04
 441  32444                                     JUMP Z, 444[got_nlz_4]
 442  10A90                                     ADD sA, s9                                      ; Less than 4 zeros, Add the counted nlz to sA
 443                                            ;  and finish the nlz counting,
 443  2246B                                     JUMP 46B[nlz_counting_done]
 444                                 got_nlz_4: 
 444  11A04                                     ADD sA, 04                                      ; Add 4 nlz to sA
 445  00860                                     LOAD s8, s6
 446  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 447  1D908                                     COMPARE s9, 08
 448  3244B                                     JUMP Z, 44B[got_nlz_8]
 449  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 44A                                            ;  and finish the nlz counting,
 44A  2246B                                     JUMP 46B[nlz_counting_done]
 44B                                 got_nlz_8: 
 44B  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 44C  00850                                     LOAD s8, s5
 44D  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 44E  1D908                                     COMPARE s9, 08
 44F  32452                                     JUMP Z, 452[got_nlz_8_s5]
 450  10A90                                     ADD sA, s9                                      ; Less than 4 zeros, Add the counted nlz to sA
 451                                            ;  and finish the nlz counting,
 451  2246B                                     JUMP 46B[nlz_counting_done]
 452                              got_nlz_8_s5: 
 452  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 453  00840                                     LOAD s8, s4
 454  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 455  1D908                                     COMPARE s9, 08
 456  32459                                     JUMP Z, 459[got_nlz_8_s4]
 457  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 458                                            ;  and finish the nlz counting,
 458  2246B                                     JUMP 46B[nlz_counting_done]
 459                              got_nlz_8_s4: 
 459  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 45A  00830                                     LOAD s8, s3
 45B  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 45C  1D908                                     COMPARE s9, 08
 45D  32460                                     JUMP Z, 460[got_nlz_8_s3]
 45E  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 45F                                            ;  and finish the nlz counting,
 45F  2246B                                     JUMP 46B[nlz_counting_done]
 460                              got_nlz_8_s3: 
 460  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 461  00820                                     LOAD s8, s2
 462  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 463  1D908                                     COMPARE s9, 08
 464  32467                                     JUMP Z, 467[got_nlz_8_s2]
 465  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 466                                            ;  and finish the nlz counting,
 466  2246B                                     JUMP 46B[nlz_counting_done]
 467                              got_nlz_8_s2: 
 467  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 468  00810                                     LOAD s8, s1
 469  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 46A  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 46B                                            ;  and finish the nlz counting,
 46B                         nlz_counting_done: 
 46B  0DAFF                                     TEST sA, FF                                     ; is sA zero ?
 46C  32478                                     JUMP Z, 478[done_intermediate_shift_riht_loop]
 46D                                            ; Shift the intermediate result to left by nlz(sA) bits.
 46D  009A0                                     LOAD s9, sA                                     ; Copy the sA
 46E                                            ; At this point result mantisa is in [s7, s6, ..., s1]
 46E              intermediate_shift_riht_loop: 
 46E  14006                                     SL0 s0                                          ; 1-bit left shift
 46F  14100                                     SLA s1
 470  14200                                     SLA s2
 471  14300                                     SLA s3
 472  14400                                     SLA s4
 473  14500                                     SLA s5
 474  14600                                     SLA s6
 475  14700                                     SLA s7
 476  19901                                     SUB s9, 01
 477  3646E                                     JUMP NZ, 46E[intermediate_shift_riht_loop]
 478         done_intermediate_shift_riht_loop: 
 478                                            ; Subtract the er by the number of bits shifted left (sA).
 478  0B92F                                     FETCH s9, 2F[r_ex7]                             ; read exponent
 479  0B830                                     FETCH s8, 30[r_ex6]
 47A  188A0                                     SUB s8, sA
 47B  1B900                                     SUBCY s9, 00
 47C  2F92F                                     STORE s9, 2F[r_ex7]                             ; write back result exponent
 47D  2F830                                     STORE s8, 30[r_ex6]
 47E  2248D                                     JUMP 48D[done_cancellation]
 47F              normalize_shift_right_by_one: 
 47F  1470E                                     SR0 s7
 480  14608                                     SRA s6
 481  14508                                     SRA s5
 482  14408                                     SRA s4
 483  14308                                     SRA s3
 484  14208                                     SRA s2
 485  14108                                     SRA s1
 486  14008                                     SRA s0
 487  0B92F                                     FETCH s9, 2F[r_ex7]                             ; read exponent
 488  0B830                                     FETCH s8, 30[r_ex6]
 489  11801                                     ADD s8, 01
 48A  13900                                     ADDCY s9, 00
 48B  2F92F                                     STORE s9, 2F[r_ex7]                             ; write back result exponent
 48C  2F830                                     STORE s8, 30[r_ex6]
 48D                         done_cancellation: 
 48D  25000                                     RETURN 
 48E                                            ;-----------------------------------------------------------------------------------
 48E                                            ; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
 48E                                            ;
 48E                                            ; beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
 48E                                            ;
 48E                                            ;------------------------------------------------------------------------------------
 48E                                            ; Procedure:   arith_mul_x_y()
 48E                                            ;
 48E                                            ; Registers Used: Bank0 : All
 48E                                            ;     Bank1 : None
 48E                                            ;
 48E                                            ; Arguments:   Bank0 :
 48E                                            ;     Bank1 : None
 48E                                            ;     SPM   : x = [x_7, x_6, ..., x_0]
 48E                                            ;            y = [y_7, y_6, ..., y_0]
 48E                                            ;
 48E                                            ; Calls:    set_ops_status
 48E                                            ;     decompose_x
 48E                                            ;     decompose_y
 48E                                            ;     mul_special_cases
 48E                                            ;     mul_normalize_mx
 48E                                            ;     mul_mx_my
 48E                                            ;     add_ex_ey
 48E                                            ;     return_zero_mul
 48E                                            ;
 48E                                            ; RETs:    None
 48E                                            ;
 48E                                            ; RETURN Flags:   None
 48E                                            ;
 48E                                            ; Description:  Adds two 64-bit double-precision floating point numbers.
 48E                                            ;   This procedure always add. For subtraction set the sign of second  operand
 48E                                            ; to negative due to the fact that x + (-y) = x - y.
 48E                                            ;------------------------------------------------------------------------------------
 48E                             arith_mul_x_y: 
 48E  2034E                                     CALL 34E[set_ops_status]
 48F  202FA                                     CALL 2FA[decompose_x]
 490  20324                                     CALL 324[decompose_y]
 491  205CB                                     CALL 5CB[mul_special_cases]
 492  1DFFF                                     COMPARE sF, FF
 493  324FF                                     JUMP Z, 4FF[done_multiplying]
 494  20679                                     CALL 679[mul_normalize_mx]
 495  20691                                     CALL 691[mul_normalize_my]
 496                                            ; op1 and op2 both are normal
 496  20500                                     CALL 500[mul_mx_my]                             ; result is in [Umr_6, Umr_0]
 497  205B2                                     CALL 5B2[add_Ex_Ey]                             ; exponent of result in [s1, s0]
 498                                            ; if er < 0 and er > -53 then result is subnormal, shift significand by er and set the er to zero
 498                                            ; if er < 0 and er <= -53 then the result is zero (underflow).
 498                                            ; if er = 0 then the result is subnormal but no shift is needed.
 498                                            ; if er > 0 then the result is normal, no further action is needed.
 498                                            ; -53 = FFDD = - 0023
 498                                            ; Read the mr [Umr_6 downto L_mr_6] (the first 53-bit starting from left)
 498  0B940                                     FETCH s9, 40[Umr_6]
 499  0B841                                     FETCH s8, 41[Umr_5]
 49A  0B742                                     FETCH s7, 42[Umr_4]
 49B  0B643                                     FETCH s6, 43[Umr_3]
 49C  0B544                                     FETCH s5, 44[Umr_2]
 49D  0B445                                     FETCH s4, 45[Umr_1]
 49E  0B346                                     FETCH s3, 46[Umr_0]
 49F  0B247                                     FETCH s2, 47[Lmr_6]
 4A0  00F10                                     LOAD sF, s1                                     ; Copy s1 into sF. sF will be used later to determine a shift left case
 4A1  0D180                                     TEST s1, 80
 4A2  324B7                                     JUMP Z, 4B7[mul_compose_result]                 ; Normal case, so skip all subnormal tests
 4A3                                            ; Here we are sure that the er is negative
 4A3  071FF                                     XOR s1, FF                                      ; Find the twos's complement of er
 4A4  070FF                                     XOR s0, FF
 4A5  11001                                     ADD s0, 01
 4A6  13100                                     ADDCY s1, 00
 4A7  1D035                                     COMPARE s0, 35
 4A8  1F100                                     COMPARECY s1, 00
 4A9  324FE                                     JUMP Z, 4FE[mul_result_is_zero]                 ; er = -53, underflow
 4AA  3A4AC                                     JUMP C, 4AC[er_greater_than_53]                 ; er > -53, subnormal
 4AB  224FE                                     JUMP 4FE[mul_result_is_zero]                    ; er < -53. underflow
 4AC                        er_greater_than_53: 
 4AC                 keep_shifting_mr_to_right: 
 4AC  1490E                                     SR0 s9
 4AD  14808                                     SRA s8
 4AE  14708                                     SRA s7
 4AF  14608                                     SRA s6
 4B0  14508                                     SRA s5
 4B1  14408                                     SRA s4
 4B2  14308                                     SRA s3
 4B3  14208                                     SRA s2
 4B4  19001                                     SUB s0, 01
 4B5  1B100                                     SUBCY s1, 00
 4B6  364AC                                     JUMP NZ, 4AC[keep_shifting_mr_to_right]
 4B7                                            ; Here [s1, s0] must be zero
 4B7                        mul_compose_result: 
 4B7                                            ; Compose the result
 4B7                                            ;FETCH s8, Umr_6
 4B7                                            ;FETCH s7, Umr_5
 4B7                                            ;FETCH s6, Umr_4
 4B7                                            ;FETCH s5, Umr_3
 4B7                                            ;FETCH s4, Umr_2
 4B7                                            ;FETCH s3, Umr_1
 4B7                                            ;FETCH s2, Umr_0
 4B7  0D902                                     TEST s9, 02                                     ; if bit 106 is 1 then shift significand to left by 1
 4B8  324C3                                     JUMP Z, 4C3[dont_inc_exponent]                  ; and increment the exponent
 4B9                                            ; shift significand right by 1
 4B9  1490E                                     SR0 s9
 4BA  14808                                     SRA s8
 4BB  14708                                     SRA s7
 4BC  14608                                     SRA s6
 4BD  14508                                     SRA s5
 4BE  14408                                     SRA s4
 4BF  14308                                     SRA s3
 4C0  14208                                     SRA s2
 4C1                                            ; add 1 to exponent
 4C1  11001                                     ADD s0, 01
 4C2  13100                                     ADDCY s1, 00
 4C3                                            ; Now the significance is in [s8 ... s2] registers with the following pattern:
 4C3                                            ; s8 to s3:  xxxx_xxxx
 4C3                                            ; s2:    xxxx_0000
 4C3                         dont_inc_exponent: 
 4C3  0DF80                                     TEST sF, 80
 4C4  364CD                                     JUMP NZ, 4CD[not_normal_case]
 4C5  14206                                     SL0 s2
 4C6  14300                                     SLA s3
 4C7  14400                                     SLA s4
 4C8  14500                                     SLA s5
 4C9  14600                                     SLA s6
 4CA  14700                                     SLA s7
 4CB  14800                                     SLA s8
 4CC  14900                                     SLA s9
 4CD                           not_normal_case: 
 4CD                                            ; Now the significance (52-bits) is in [s9 ... s2] registers with the following pattern:
 4CD                                            ; X means bit is used
 4CD                                            ; s9:    0000_00
 4CD                                            ; s8 to s3:  xxxx_xxxx
 4CD                                            ; s2:    xxx0_0000
 4CD                                            ; So we shift the registers to left by 3
 4CD  14206                                     SL0 s2
 4CE  14300                                     SLA s3
 4CF  14400                                     SLA s4
 4D0  14500                                     SLA s5
 4D1  14600                                     SLA s6
 4D2  14700                                     SLA s7
 4D3  14800                                     SLA s8
 4D4  14900                                     SLA s9
 4D5  14206                                     SL0 s2
 4D6  14300                                     SLA s3
 4D7  14400                                     SLA s4
 4D8  14500                                     SLA s5
 4D9  14600                                     SLA s6
 4DA  14700                                     SLA s7
 4DB  14800                                     SLA s8
 4DC  14900                                     SLA s9
 4DD  14206                                     SL0 s2
 4DE  14300                                     SLA s3
 4DF  14400                                     SLA s4
 4E0  14500                                     SLA s5
 4E1  14600                                     SLA s6
 4E2  14700                                     SLA s7
 4E3  14800                                     SLA s8
 4E4  14900                                     SLA s9
 4E5                                            ; Significance now is in [s9(lower nibble), ..., s3]
 4E5                                            ; Round
 4E5  206A9                                     CALL 6A9[mul_round]
 4E6                                            ; Combine exponent [s1, s0] and significand [s9, ..., s3]
 4E6                                            ; Shift exponent to left by 4
 4E6  14006                                     SL0 s0
 4E7  14100                                     SLA s1
 4E8  14006                                     SL0 s0
 4E9  14100                                     SLA s1
 4EA  14006                                     SL0 s0
 4EB  14100                                     SLA s1
 4EC  14006                                     SL0 s0
 4ED  14100                                     SLA s1
 4EE                                            ; Zero the unused high nibble
 4EE  0390F                                     AND s9, 0F
 4EF                                            ; Combine the exponent with significand
 4EF  04900                                     OR s9, s0
 4F0                                            ; Calculate the sign
 4F0  0BF18                                     FETCH sF, 18[x_sign]
 4F1  0BE23                                     FETCH sE, 23[y_sign]
 4F2  06FE0                                     XOR sF, sE                                      ; Calculate the sign
 4F3  03F80                                     AND sF, 80
 4F4  041F0                                     OR s1, sF                                       ; Apply the sign
 4F5                                            ; Save the result in SMP
 4F5  2F317                                     STORE s3, 17[r_0]
 4F6  2F416                                     STORE s4, 16[r_1]
 4F7  2F515                                     STORE s5, 15[r_2]
 4F8  2F614                                     STORE s6, 14[r_3]
 4F9  2F713                                     STORE s7, 13[r_4]
 4FA  2F812                                     STORE s8, 12[r_5]
 4FB  2F911                                     STORE s9, 11[r_6]
 4FC  2F110                                     STORE s1, 10[r_7]
 4FD  224FF                                     JUMP 4FF[done_multiplying]
 4FE                        mul_result_is_zero: 
 4FE  205EE                                     CALL 5EE[return_zero_mul]
 4FF                          done_multiplying: 
 4FF  25000                                     RETURN 
 500                                            ;------------------------------------------------------------------------------------
 500                                            ; Procedure:   mul_mx_my()
 500                                            ;
 500                                            ; Registers Used: Bank0 : All
 500                                            ;     Bank1 : None
 500                                            ;
 500                                            ; Arguments:   Bank0 : None
 500                                            ;     Bank1 : None
 500                                            ;     SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
 500                                            ;       y_m6, y_m5, ... y_m0  (7-bytes)
 500                                            ;
 500                                            ;
 500                                            ; Calls:
 500                                            ;
 500                                            ; RETs:    Bank1:
 500                                            ;
 500                                            ; RETURN Flags:   None
 500                                            ;
 500                                            ; Description:  Multiplies two 53-bit double-precision floating point numbers.
 500                                            ;------------------------------------------------------------------------------------
 500                                 mul_mx_my: 
 500                                            ; Setup shifted mx SPM
 500  01D00                                     LOAD sD, 00
 501  01C00                                     LOAD sC, 00
 502  01B00                                     LOAD sB, 00
 503  01A00                                     LOAD sA, 00
 504  01900                                     LOAD s9, 00
 505  01800                                     LOAD s8, 00
 506  01700                                     LOAD s7, 00
 507  0B61B                                     FETCH s6, 1B[x_m6]
 508  0B51C                                     FETCH s5, 1C[x_m5]
 509  0B41D                                     FETCH s4, 1D[x_m4]
 50A  0B31E                                     FETCH s3, 1E[x_m3]
 50B  0B21F                                     FETCH s2, 1F[x_m2]
 50C  0B120                                     FETCH s1, 20[x_m1]
 50D  0B021                                     FETCH s0, 21[x_m0]
 50E  2FD50                                     STORE sD, 50[Umx_shifted_6]
 50F  2FC51                                     STORE sC, 51[Umx_shifted_5]
 510  2FB52                                     STORE sB, 52[Umx_shifted_4]
 511  2FA53                                     STORE sA, 53[Umx_shifted_3]
 512  2F954                                     STORE s9, 54[Umx_shifted_2]
 513  2F855                                     STORE s8, 55[Umx_shifted_1]
 514  2F756                                     STORE s7, 56[Umx_shifted_0]
 515  2F657                                     STORE s6, 57[Lmx_shifted_6]
 516  2F558                                     STORE s5, 58[Lmx_shifted_5]
 517  2F459                                     STORE s4, 59[Lmx_shifted_4]
 518  2F35A                                     STORE s3, 5A[Lmx_shifted_3]
 519  2F25B                                     STORE s2, 5B[Lmx_shifted_2]
 51A  2F15C                                     STORE s1, 5C[Lmx_shifted_1]
 51B  2F05D                                     STORE s0, 5D[Lmx_shifted_0]
 51C  01F00                                     LOAD sF, 00                                     ; Initially shift to left by 0
 51D  01E00                                     LOAD sE, 00                                     ; Initially shift to left by 0
 51E                                            ; TEST s0, 01    ; Test if bit 0 is one
 51E                                            ; JUMP  NZ, shifting_mx_left_done
 51E                            next_shift_add: 
 51E                                            ; load my
 51E  0B626                                     FETCH s6, 26[y_m6]
 51F  0B527                                     FETCH s5, 27[y_m5]
 520  0B428                                     FETCH s4, 28[y_m4]
 521  0B329                                     FETCH s3, 29[y_m3]
 522  0B22A                                     FETCH s2, 2A[y_m2]
 523  0B12B                                     FETCH s1, 2B[y_m1]
 524  0B02C                                     FETCH s0, 2C[y_m0]
 525                          next_right_shift: 
 525  1DF35                                     COMPARE sF, 35                                  ; Have reached 54?
 526  325B1                                     JUMP Z, 5B1[finish_mul]                         ; Yes: Finish the multiplication
 527  0D001                                     TEST s0, 01                                     ; Check the LSB
 528  36533                                     JUMP NZ, 533[shift_and_add]                     ; if it is 1: shift and add
 529                                            ; it is 0: shift my to right by 1
 529  1460E                                     SR0 s6
 52A  14508                                     SRA s5
 52B  14408                                     SRA s4
 52C  14308                                     SRA s3
 52D  14208                                     SRA s2
 52E  14108                                     SRA s1
 52F  14008                                     SRA s0
 530  11E01                                     ADD sE, 01
 531  11F01                                     ADD sF, 01
 532  22525                                     JUMP 525[next_right_shift]
 533                             shift_and_add: 
 533                                            ; Save shifted my into SPM
 533  2F626                                     STORE s6, 26[y_m6]
 534  2F527                                     STORE s5, 27[y_m5]
 535  2F428                                     STORE s4, 28[y_m4]
 536  2F329                                     STORE s3, 29[y_m3]
 537  2F22A                                     STORE s2, 2A[y_m2]
 538  2F12B                                     STORE s1, 2B[y_m1]
 539  2F02C                                     STORE s0, 2C[y_m0]
 53A                                            ; load mx
 53A  0BD50                                     FETCH sD, 50[Umx_shifted_6]
 53B  0BC51                                     FETCH sC, 51[Umx_shifted_5]
 53C  0BB52                                     FETCH sB, 52[Umx_shifted_4]
 53D  0BA53                                     FETCH sA, 53[Umx_shifted_3]
 53E  0B954                                     FETCH s9, 54[Umx_shifted_2]
 53F  0B855                                     FETCH s8, 55[Umx_shifted_1]
 540  0B756                                     FETCH s7, 56[Umx_shifted_0]
 541  0B657                                     FETCH s6, 57[Lmx_shifted_6]
 542  0B558                                     FETCH s5, 58[Lmx_shifted_5]
 543  0B459                                     FETCH s4, 59[Lmx_shifted_4]
 544  0B35A                                     FETCH s3, 5A[Lmx_shifted_3]
 545  0B25B                                     FETCH s2, 5B[Lmx_shifted_2]
 546  0B15C                                     FETCH s1, 5C[Lmx_shifted_1]
 547  0B05D                                     FETCH s0, 5D[Lmx_shifted_0]
 548  1DE00                                     COMPARE sE, 00
 549  32568                                     JUMP Z, 568[shifting_mx_left_done2]
 54A                                            ; Shift mx left by sE
 54A                     keep_shifting_mx_left: 
 54A  14006                                     SL0 s0
 54B  14100                                     SLA s1
 54C  14200                                     SLA s2
 54D  14300                                     SLA s3
 54E  14400                                     SLA s4
 54F  14500                                     SLA s5
 550  14600                                     SLA s6
 551  14700                                     SLA s7
 552  14800                                     SLA s8
 553  14900                                     SLA s9
 554  14A00                                     SLA sA
 555  14B00                                     SLA sB
 556  14C00                                     SLA sC
 557  14D00                                     SLA sD
 558  19E01                                     SUB sE, 01
 559  3654A                                     JUMP NZ, 54A[keep_shifting_mx_left]
 55A                     shifting_mx_left_done: 
 55A  2FD50                                     STORE sD, 50[Umx_shifted_6]
 55B  2FC51                                     STORE sC, 51[Umx_shifted_5]
 55C  2FB52                                     STORE sB, 52[Umx_shifted_4]
 55D  2FA53                                     STORE sA, 53[Umx_shifted_3]
 55E  2F954                                     STORE s9, 54[Umx_shifted_2]
 55F  2F855                                     STORE s8, 55[Umx_shifted_1]
 560  2F756                                     STORE s7, 56[Umx_shifted_0]
 561  2F657                                     STORE s6, 57[Lmx_shifted_6]
 562  2F558                                     STORE s5, 58[Lmx_shifted_5]
 563  2F459                                     STORE s4, 59[Lmx_shifted_4]
 564  2F35A                                     STORE s3, 5A[Lmx_shifted_3]
 565  2F25B                                     STORE s2, 5B[Lmx_shifted_2]
 566  2F15C                                     STORE s1, 5C[Lmx_shifted_1]
 567  2F05D                                     STORE s0, 5D[Lmx_shifted_0]
 568                    shifting_mx_left_done2: 
 568                                            ; now add shifted mx to the previous result (mr)
 568                                            ; Load lower half of mr into registers [sD, s7]
 568  0BD47                                     FETCH sD, 47[Lmr_6]
 569  0BC48                                     FETCH sC, 48[Lmr_5]
 56A  0BB49                                     FETCH sB, 49[Lmr_4]
 56B  0BA4A                                     FETCH sA, 4A[Lmr_3]
 56C  0B94B                                     FETCH s9, 4B[Lmr_2]
 56D  0B84C                                     FETCH s8, 4C[Lmr_1]
 56E  0B74D                                     FETCH s7, 4D[Lmr_0]
 56F                                            ; Load lower half of shifted mx into registers [s6, s0] :already there
 56F                                            ; Add
 56F  10070                                     ADD s0, s7
 570  12180                                     ADDCY s1, s8
 571  12290                                     ADDCY s2, s9
 572  123A0                                     ADDCY s3, sA
 573  124B0                                     ADDCY s4, sB
 574  125C0                                     ADDCY s5, sC
 575  126D0                                     ADDCY s6, sD
 576                                            ; save result
 576  2F647                                     STORE s6, 47[Lmr_6]
 577  2F548                                     STORE s5, 48[Lmr_5]
 578  2F449                                     STORE s4, 49[Lmr_4]
 579  2F34A                                     STORE s3, 4A[Lmr_3]
 57A  2F24B                                     STORE s2, 4B[Lmr_2]
 57B  2F14C                                     STORE s1, 4C[Lmr_1]
 57C  2F04D                                     STORE s0, 4D[Lmr_0]
 57D                                            ; JUMP NC, no_carry_for_lower_add
 57D                                            ; save the carry
 57D                                            ; LOAD  s7, 01
 57D                                            ; STORE s7, mr_save_carry
 57D                                            ;no_carry_for_lower_add:
 57D                                            ; Load upper half of mr into registers [sD, s7]
 57D  0BD40                                     FETCH sD, 40[Umr_6]
 57E  0BC41                                     FETCH sC, 41[Umr_5]
 57F  0BB42                                     FETCH sB, 42[Umr_4]
 580  0BA43                                     FETCH sA, 43[Umr_3]
 581  0B944                                     FETCH s9, 44[Umr_2]
 582  0B845                                     FETCH s8, 45[Umr_1]
 583  0B746                                     FETCH s7, 46[Umr_0]
 584                                            ; Load upper half of shifted mx into registers [s6, s0]
 584  0B650                                     FETCH s6, 50[Umx_shifted_6]
 585  0B551                                     FETCH s5, 51[Umx_shifted_5]
 586  0B452                                     FETCH s4, 52[Umx_shifted_4]
 587  0B353                                     FETCH s3, 53[Umx_shifted_3]
 588  0B254                                     FETCH s2, 54[Umx_shifted_2]
 589  0B155                                     FETCH s1, 55[Umx_shifted_1]
 58A  0B056                                     FETCH s0, 56[Umx_shifted_0]
 58B                                            ; Add
 58B  12070                                     ADDCY s0, s7
 58C  12180                                     ADDCY s1, s8
 58D  12290                                     ADDCY s2, s9
 58E  123A0                                     ADDCY s3, sA
 58F  124B0                                     ADDCY s4, sB
 590  125C0                                     ADDCY s5, sC
 591  126D0                                     ADDCY s6, sD
 592                                            ; save result
 592  2F640                                     STORE s6, 40[Umr_6]
 593  2F541                                     STORE s5, 41[Umr_5]
 594  2F442                                     STORE s4, 42[Umr_4]
 595  2F343                                     STORE s3, 43[Umr_3]
 596  2F244                                     STORE s2, 44[Umr_2]
 597  2F145                                     STORE s1, 45[Umr_1]
 598  2F046                                     STORE s0, 46[Umr_0]
 599                                            ;shift my to right by 1 so we can check its LSB in next round
 599                                            ; load my
 599  0B626                                     FETCH s6, 26[y_m6]
 59A  0B527                                     FETCH s5, 27[y_m5]
 59B  0B428                                     FETCH s4, 28[y_m4]
 59C  0B329                                     FETCH s3, 29[y_m3]
 59D  0B22A                                     FETCH s2, 2A[y_m2]
 59E  0B12B                                     FETCH s1, 2B[y_m1]
 59F  0B02C                                     FETCH s0, 2C[y_m0]
 5A0  1460E                                     SR0 s6
 5A1  14508                                     SRA s5
 5A2  14408                                     SRA s4
 5A3  14308                                     SRA s3
 5A4  14208                                     SRA s2
 5A5  14108                                     SRA s1
 5A6  14008                                     SRA s0
 5A7  2F626                                     STORE s6, 26[y_m6]
 5A8  2F527                                     STORE s5, 27[y_m5]
 5A9  2F428                                     STORE s4, 28[y_m4]
 5AA  2F329                                     STORE s3, 29[y_m3]
 5AB  2F22A                                     STORE s2, 2A[y_m2]
 5AC  2F12B                                     STORE s1, 2B[y_m1]
 5AD  2F02C                                     STORE s0, 2C[y_m0]
 5AE  11F01                                     ADD sF, 01
 5AF  01E01                                     LOAD sE, 01                                     ; tracks the numebr of shifts per round, set it to zero for next round
 5B0  2251E                                     JUMP 51E[next_shift_add]
 5B1                                finish_mul: 
 5B1  25000                                     RETURN 
 5B2                                            ;------------------------------------------------------------------------------------
 5B2                                            ; Procedure:   add_Ex_Ey()
 5B2                                            ;
 5B2                                            ; Registers Used: Bank0 : All
 5B2                                            ;     Bank1 : None
 5B2                                            ;
 5B2                                            ; Arguments:   Bank0 : None
 5B2                                            ;     Bank1 : None
 5B2                                            ;     SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
 5B2                                            ;       y_m6, y_m5, ... y_m0  (7-bytes)
 5B2                                            ;
 5B2                                            ;
 5B2                                            ; Calls:
 5B2                                            ;
 5B2                                            ; RETs:    Bank1: [s1. s0]
 5B2                                            ;
 5B2                                            ; RETURN Flags:   None
 5B2                                            ;
 5B2                                            ; Description:  Calculates the ex + ey which is Ex + Ey - bias(1023) and returns
 5B2                                            ;      the result in [s1, s0].
 5B2                                            ;------------------------------------------------------------------------------------
 5B2                                 add_Ex_Ey: 
 5B2                                            ; Read ex
 5B2  0B119                                     FETCH s1, 19[x_ex7]
 5B3  0B01A                                     FETCH s0, 1A[x_ex6]
 5B4                                            ; if op1 is subnormal then subtract by 1022 else subtract by  1023
 5B4  0BF3A                                     FETCH sF, 3A[op1_status]
 5B5  0DF80                                     TEST sF, 80
 5B6  365BA                                     JUMP NZ, 5BA[subnormal_exponent_detected]
 5B7                                            ; Subtract by 1023
 5B7  190FF                                     SUB s0, FF
 5B8  1B103                                     SUBCY s1, 03
 5B9  225BC                                     JUMP 5BC[done_exponent_subtracting]
 5BA               subnormal_exponent_detected: 
 5BA                                            ; Subtract by 1022
 5BA  190FE                                     SUB s0, FE
 5BB  1B103                                     SUBCY s1, 03
 5BC                 done_exponent_subtracting: 
 5BC                                            ; Read ey
 5BC  0B324                                     FETCH s3, 24[y_ex7]
 5BD  0B225                                     FETCH s2, 25[y_ex6]
 5BE                                            ; if [s1, s0] == zero then subtract 1022 elsesubtract 1023
 5BE  0BF3B                                     FETCH sF, 3B[op2_status]
 5BF  0DF80                                     TEST sF, 80
 5C0  365C4                                     JUMP NZ, 5C4[subnormal_exponent_detected_y]
 5C1                                            ; Subtract by 1023
 5C1  192FF                                     SUB s2, FF
 5C2  1B303                                     SUBCY s3, 03
 5C3  225C6                                     JUMP 5C6[done_exponent_subtracting_y]
 5C4             subnormal_exponent_detected_y: 
 5C4                                            ; Subtract by 1022
 5C4  192FE                                     SUB s2, FE
 5C5  1B303                                     SUBCY s3, 03
 5C6               done_exponent_subtracting_y: 
 5C6  10020                                     ADD s0, s2
 5C7  12130                                     ADDCY s1, s3
 5C8  110FF                                     ADD s0, FF                                      ; subtract by 1023'd =  03FF
 5C9  13103                                     ADDCY s1, 03
 5CA  25000                                     RETURN 
 5CB                                            ;------------------------------------------------------------------------------------
 5CB                                            ; Procedure:   mul_special_cases()
 5CB                                            ;
 5CB                                            ; Registers Used: Bank0 : s1, s2
 5CB                                            ;     Bank1 : None
 5CB                                            ;
 5CB                                            ; Arguments:   Bank0 : None
 5CB                                            ;     Bank1 : None
 5CB                                            ;
 5CB                                            ;
 5CB                                            ; Calls:
 5CB                                            ;
 5CB                                            ; RETs:    Bank1: [s1. s0]
 5CB                                            ;
 5CB                                            ; RETURN Flags:   None
 5CB                                            ;
 5CB                                            ; Description:  Takes care of special operands in multiplication.
 5CB                                            ;     Return FF in sF if one of the operands is special.
 5CB                                            ;     If sF is FF then the result is already in [r_7, r_8] in SPM.
 5CB                                            ;------------------------------------------------------------------------------------
 5CB                         mul_special_cases: 
 5CB  0B13A                                     FETCH s1, 3A[op1_status]                        ; read the ops status
 5CC  0B23B                                     FETCH s2, 3B[op2_status]                        ; read the ops status
 5CD                                            ; We check op1 for
 5CD                                            ; 1) NaN
 5CD                                            ;  Yes: return X_NaN
 5CD                                            ;  No:  Go to step 2.
 5CD                                            ; 2) Infinity
 5CD                                            ;  Yes: Check op2, if +0 and NaN then return_NaN_Inf
 5CD                                            ;  No:  return +infinity
 5CD                                            ; 3) Zero
 5CD                                            ;  Yes: check if op2 is +inf or NaN then return_NaN_Inf
 5CD                                            ;     else return 0
 5CD                                            ;  No:  check op2
 5CD                                            ;-----------------------------------------------
 5CD                                            ; Check if op1 is NaN
 5CD  0D110                                     TEST s1, 10
 5CE  325D2                                     JUMP Z, 5D2[mul_final_op1_not_NaN]              ; No
 5CF                         mul_final_op1_NaN: ; Yes
 5CF                                            ; Check if op2 is NaN
 5CF  0D210                                     TEST s2, 10
 5D0  36631                                     JUMP NZ, 631[return_xy_NAN]                     ; Yes
 5D1  22177                                     JUMP 177[return_x_NAN]
 5D2                     mul_final_op1_not_NaN: 
 5D2                                            ; +inf + + inf = +inf
 5D2                                            ; +inf + - inf = +NaN
 5D2                                            ; -inf + + inf = +NaN
 5D2                                            ; -inf + - inf = -inf
 5D2                                            ; infinity sign is the AND of both operands' sign bits.
 5D2                                            ; Result NaN bit is XOR of both operands' sign bits.
 5D2                                            ;-----------------------------------
 5D2                                            ; Check if op1 is Inf
 5D2  0D120                                     TEST s1, 20
 5D3  325D9                                     JUMP Z, 5D9[mul_final_op1_not_Inf]              ; No
 5D4                         mul_final_op1_Inf: ; Yes
 5D4                                            ; Check if op2 is zero
 5D4  0D240                                     TEST s2, 40
 5D5  3661F                                     JUMP NZ, 61F[return_pos_inf]
 5D6                                            ; Check if op2 is NaN
 5D6  0D210                                     TEST s2, 10
 5D7  361BC                                     JUMP NZ, 1BC[return_y_NAN]                      ; Yes
 5D8  2260E                                     JUMP 60E[return_x_Inf]
 5D9                     mul_final_op1_not_Inf: 
 5D9                                            ; Check if op1 is zero
 5D9  0D140                                     TEST s1, 40
 5DA  325E0                                     JUMP Z, 5E0[mul_check_final_op2]                ; No
 5DB                     mul_final_op1_is_zero: 
 5DB                                            ; Check if op2 is Inifinity
 5DB  0D220                                     TEST s2, 20
 5DC  365E3                                     JUMP NZ, 5E3[return_y_NAN_positive]             ; Yes
 5DD                                            ; Check if op2 is NaN
 5DD  0D210                                     TEST s2, 10
 5DE  365E3                                     JUMP NZ, 5E3[return_y_NAN_positive]             ;Yes
 5DF  225EE                                     JUMP 5EE[return_zero_mul]
 5E0                                            ; Op1 is not NaN, Inf, and zero, so we conclude op1 is (sub)normal.
 5E0                                            ; We check op2 for
 5E0                                            ; 1) NaN
 5E0                                            ;  Yes: return_NaN_Inf
 5E0                                            ;  No:  Go to step 2.
 5E0                                            ; 2) Infinity
 5E0                                            ;  Yes: return_NaN_Inf
 5E0                                            ;  No:  return x
 5E0                                            ; 3) Zero
 5E0                                            ;  Yes: return zero
 5E0                                            ;  No:  swap_step
 5E0                       mul_check_final_op2: ; Here we are sure op1 is (sub)normal
 5E0                                            ; Check if op2 is NaN
 5E0  0D210                                     TEST s2, 10
 5E1  365E3                                     JUMP NZ, 5E3[return_y_NAN_positive]             ;Yes
 5E2  225E8                                     JUMP 5E8[mul_final_op2_not_NaN]
 5E3                     return_y_NAN_positive: 
 5E3                                            ; make y positive
 5E3  01E7F                                     LOAD sE, 7F
 5E4  0BD08                                     FETCH sD, 08[y_7]
 5E5  02DE0                                     AND sD, sE
 5E6  2FD08                                     STORE sD, 08[y_7]
 5E7  221BC                                     JUMP 1BC[return_y_NAN]
 5E8                     mul_final_op2_not_NaN: ; No
 5E8                                            ; Check if op2 is Infinity
 5E8  0D220                                     TEST s2, 20
 5E9  365FD                                     JUMP NZ, 5FD[return_y_Inf]                      ; Yes
 5EA                                            ; Check if op2 is zero
 5EA  0D240                                     TEST s2, 40
 5EB  365EE                                     JUMP NZ, 5EE[return_zero_mul]                   ; Yes
 5EC                                            ; Both operators are (sub)normal. Perform the multiplication.
 5EC  01F00                                     LOAD sF, 00
 5ED  25000                                     RETURN 
 5EE                                            ;------------------------------------------------------------------------------------
 5EE                                            ; Procedure:   return_zero_mul()
 5EE                                            ;
 5EE                                            ; Registers Used: Bank0 :
 5EE                                            ;     Bank1 : None
 5EE                                            ;
 5EE                                            ; Arguments:   Bank0 :
 5EE                                            ;     Bank1 : None
 5EE                                            ;
 5EE                                            ; Calls:    None
 5EE                                            ;     None
 5EE                                            ;
 5EE                                            ; RETs:
 5EE                                            ;
 5EE                                            ; RETURN Flags:   None
 5EE                                            ;
 5EE                                            ; Description:  Returns zero
 5EE                                            ;------------------------------------------------------------------------------------
 5EE                           return_zero_mul: 
 5EE  01FFF                                     LOAD sF, FF
 5EF                                            ; +0 +0 => +0
 5EF                                            ; -0 +0 => -0
 5EF                                            ; +0 -0 => -0
 5EF                                            ; -0 -0 => +0
 5EF  0B118                                     FETCH s1, 18[x_sign]
 5F0  0B223                                     FETCH s2, 23[y_sign]
 5F1  06120                                     XOR s1, s2                                      ; Calculate the sign of zero
 5F2  03180                                     AND s1, 80                                      ; zero all other bits except sign
 5F3  01000                                     LOAD s0, 00
 5F4  2F011                                     STORE s0, 11[r_6]
 5F5  2F012                                     STORE s0, 12[r_5]
 5F6  2F013                                     STORE s0, 13[r_4]
 5F7  2F014                                     STORE s0, 14[r_3]
 5F8  2F015                                     STORE s0, 15[r_2]
 5F9  2F016                                     STORE s0, 16[r_1]
 5FA  2F017                                     STORE s0, 17[r_0]
 5FB  2F110                                     STORE s1, 10[r_7]
 5FC  25000                                     RETURN 
 5FD                              return_y_Inf: 
 5FD  01FFF                                     LOAD sF, FF                                     ; Signal the caller that the operation is complete.
 5FE  0B318                                     FETCH s3, 18[x_sign]
 5FF  0B423                                     FETCH s4, 23[y_sign]
 600  06340                                     XOR s3, s4
 601  0127F                                     LOAD s2, 7F
 602  011F0                                     LOAD s1, F0
 603  04230                                     OR s2, s3
 604  01000                                     LOAD s0, 00
 605  2F210                                     STORE s2, 10[r_7]
 606  2F111                                     STORE s1, 11[r_6]
 607  2F012                                     STORE s0, 12[r_5]
 608  2F013                                     STORE s0, 13[r_4]
 609  2F014                                     STORE s0, 14[r_3]
 60A  2F015                                     STORE s0, 15[r_2]
 60B  2F016                                     STORE s0, 16[r_1]
 60C  2F017                                     STORE s0, 17[r_0]
 60D  25000                                     RETURN 
 60E                              return_x_Inf: 
 60E  01FFF                                     LOAD sF, FF                                     ; Signal the caller that the operation is complete.
 60F  0B318                                     FETCH s3, 18[x_sign]
 610  0B423                                     FETCH s4, 23[y_sign]
 611  06340                                     XOR s3, s4
 612  0127F                                     LOAD s2, 7F
 613  011F0                                     LOAD s1, F0
 614  04230                                     OR s2, s3
 615  01000                                     LOAD s0, 00
 616  2F210                                     STORE s2, 10[r_7]
 617  2F111                                     STORE s1, 11[r_6]
 618  2F012                                     STORE s0, 12[r_5]
 619  2F013                                     STORE s0, 13[r_4]
 61A  2F014                                     STORE s0, 14[r_3]
 61B  2F015                                     STORE s0, 15[r_2]
 61C  2F016                                     STORE s0, 16[r_1]
 61D  2F017                                     STORE s0, 17[r_0]
 61E  25000                                     RETURN 
 61F                            return_pos_inf: 
 61F  01FFF                                     LOAD sF, FF                                     ; Signal the caller that the operation is complete.
 620                                            ; Calculate the sign
 620  0BB18                                     FETCH sB, 18[x_sign]
 621  0BA23                                     FETCH sA, 23[y_sign]
 622  06BA0                                     XOR sB, sA                                      ; Calculate the sign
 623  03B80                                     AND sB, 80
 624  0127F                                     LOAD s2, 7F
 625  042B0                                     OR s2, sB                                       ; Apply the sign
 626  011F0                                     LOAD s1, F0
 627  01000                                     LOAD s0, 00
 628  2F210                                     STORE s2, 10[r_7]
 629  2F111                                     STORE s1, 11[r_6]
 62A  2F012                                     STORE s0, 12[r_5]
 62B  2F013                                     STORE s0, 13[r_4]
 62C  2F014                                     STORE s0, 14[r_3]
 62D  2F015                                     STORE s0, 15[r_2]
 62E  2F016                                     STORE s0, 16[r_1]
 62F  2F017                                     STORE s0, 17[r_0]
 630  25000                                     RETURN 
 631                             return_xy_NAN: 
 631                                            ; compare MSB significance of x (the NaN bit) vs MSB significance of y significance
 631  0BF1B                                     FETCH sF, 1B[x_m6]
 632  0BE26                                     FETCH sE, 26[y_m6]
 633  0DF08                                     TEST sF, 08
 634  36636                                     JUMP NZ, 636[test_y_significand]
 635  22177                                     JUMP 177[return_x_NAN]
 636                        test_y_significand: 
 636  0DE08                                     TEST sE, 08
 637  321BC                                     JUMP Z, 1BC[return_y_NAN]                       ; x NaN bit is 1, y NaN bit is 0
 638  22177                                     JUMP 177[return_x_NAN]
 639                                            ;------------------------------------------------------------------------------------
 639                                            ; Procedure:   mul_cancellation()
 639                                            ;
 639                                            ; Registers Used: Bank0 : [s6, s0]
 639                                            ;     Bank1 : None
 639                                            ;
 639                                            ; Arguments:   Bank0 :
 639                                            ;     Bank1 : None
 639                                            ;
 639                                            ; Calls:    None
 639                                            ;     None
 639                                            ;
 639                                            ; RETs:    sA : the number of bits shifted to left
 639                                            ;
 639                                            ; RETURN Flags:   None
 639                                            ;
 639                                            ; Description:  Receives a subnormal significand in [s6, s0] and normalizes it
 639                                            ;------------------------------------------------------------------------------------
 639                          mul_cancellation: 
 639                                            ; Count the number of leading zeros = nlz
 639                                            ; Shift left by nlz, and rturn the number of shifted bits.
 639                                            ; Check if er is zero then the result is as it is
 639  01A01                                     LOAD sA, 01                                     ; nlz nounter
 63A  00860                                     LOAD s8, s6                                     ; make a copy of s6
 63B  14807                                     SL1 s8
 63C  14807                                     SL1 s8
 63D  14807                                     SL1 s8
 63E  14807                                     SL1 s8
 63F                                            ; Count nlz in s8
 63F  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 640  0D9FF                                     TEST s9, FF                                     ; is s9 = 0 ?
 641  3266D                                     JUMP Z, 66D[mul_nlz_counting_done]
 642  1D904                                     COMPARE s9, 04
 643  32646                                     JUMP Z, 646[mul_got_nlz_4]
 644  10A90                                     ADD sA, s9                                      ; Less than 4 zeros, Add the counted nlz to sA
 645                                            ;  and finish the nlz counting,
 645  2266D                                     JUMP 66D[mul_nlz_counting_done]
 646                             mul_got_nlz_4: 
 646  11A04                                     ADD sA, 04                                      ; Add 4 nlz to sA
 647  00850                                     LOAD s8, s5
 648  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 649  1D908                                     COMPARE s9, 08
 64A  3264D                                     JUMP Z, 64D[mul_got_nlz_8]
 64B  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 64C                                            ;  and finish the nlz counting,
 64C  2266D                                     JUMP 66D[mul_nlz_counting_done]
 64D                             mul_got_nlz_8: 
 64D  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 64E  00840                                     LOAD s8, s4
 64F  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 650  1D908                                     COMPARE s9, 08
 651  32654                                     JUMP Z, 654[mul_got_nlz_8_s3]
 652  10A90                                     ADD sA, s9                                      ; Less than 4 zeros, Add the counted nlz to sA
 653                                            ;  and finish the nlz counting,
 653  2266D                                     JUMP 66D[mul_nlz_counting_done]
 654                          mul_got_nlz_8_s3: 
 654  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 655  00830                                     LOAD s8, s3
 656  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 657  1D908                                     COMPARE s9, 08
 658  3265B                                     JUMP Z, 65B[mul_got_nlz_8_s2]
 659  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 65A                                            ;  and finish the nlz counting,
 65A  2266D                                     JUMP 66D[mul_nlz_counting_done]
 65B                          mul_got_nlz_8_s2: 
 65B  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 65C  00820                                     LOAD s8, s2
 65D  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 65E  1D908                                     COMPARE s9, 08
 65F  32662                                     JUMP Z, 662[mul_got_nlz_8_s1]
 660  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 661                                            ;  and finish the nlz counting,
 661  2266D                                     JUMP 66D[mul_nlz_counting_done]
 662                          mul_got_nlz_8_s1: 
 662  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 663  00810                                     LOAD s8, s1
 664  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 665  1D908                                     COMPARE s9, 08
 666  32669                                     JUMP Z, 669[mul_got_nlz_8_s0]
 667  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 668                                            ;  and finish the nlz counting,
 668  2266D                                     JUMP 66D[mul_nlz_counting_done]
 669                          mul_got_nlz_8_s0: 
 669  11A08                                     ADD sA, 08                                      ; Add 8 nlz to sA
 66A  00800                                     LOAD s8, s0
 66B  202DD                                     CALL 2DD[count_nlz]                             ; RETs number of zeros in s9
 66C  10A90                                     ADD sA, s9                                      ; Less than 8 zeros, Add the counted nlz to sA
 66D                                            ;  and finish the nlz counting,
 66D                     mul_nlz_counting_done: 
 66D                                            ; Shift the significand to left by nlz(sA) bits.
 66D  009A0                                     LOAD s9, sA                                     ; Copy the sA
 66E                                            ; At this point result mantisa is in [s7, s6, ..., s1]
 66E          mul_intermediate_shift_riht_loop: 
 66E  14006                                     SL0 s0                                          ; 1-bit left shift
 66F  14100                                     SLA s1
 670  14200                                     SLA s2
 671  14300                                     SLA s3
 672  14400                                     SLA s4
 673  14500                                     SLA s5
 674  14600                                     SLA s6
 675  14700                                     SLA s7
 676  19901                                     SUB s9, 01
 677  3666E                                     JUMP NZ, 66E[mul_intermediate_shift_riht_loop]
 678  25000                                     RETURN 
 679                          mul_normalize_mx: 
 679                                            ; Load mx into registers
 679  0B61B                                     FETCH s6, 1B[x_m6]
 67A                                            ; Check if the significant is already normalized or not
 67A  0D610                                     TEST s6, 10
 67B  36690                                     JUMP NZ, 690[already_normalized]
 67C                                            ; Significand is not normalized so normalize it.
 67C                                            ; Continue loading mx into registers
 67C  0B51C                                     FETCH s5, 1C[x_m5]
 67D  0B41D                                     FETCH s4, 1D[x_m4]
 67E  0B31E                                     FETCH s3, 1E[x_m3]
 67F  0B21F                                     FETCH s2, 1F[x_m2]
 680  0B120                                     FETCH s1, 20[x_m1]
 681  0B021                                     FETCH s0, 21[x_m0]
 682  20639                                     CALL 639[mul_cancellation]                      ; return sA = number of bits shifted to left
 683  2F61B                                     STORE s6, 1B[x_m6]
 684  2F51C                                     STORE s5, 1C[x_m5]
 685  2F41D                                     STORE s4, 1D[x_m4]
 686  2F31E                                     STORE s3, 1E[x_m3]
 687  2F21F                                     STORE s2, 1F[x_m2]
 688  2F120                                     STORE s1, 20[x_m1]
 689  2F021                                     STORE s0, 21[x_m0]
 68A                                            ; Subtract exponent by sA
 68A  0BE1A                                     FETCH sE, 1A[x_ex6]
 68B  0BF19                                     FETCH sF, 19[x_ex7]
 68C  18EA0                                     SUB sE, sA
 68D  1BF00                                     SUBCY sF, 00
 68E  2FE1A                                     STORE sE, 1A[x_ex6]
 68F  2FF19                                     STORE sF, 19[x_ex7]
 690                        already_normalized: 
 690  25000                                     RETURN 
 691                          mul_normalize_my: 
 691                                            ; Load mx into registers
 691  0B626                                     FETCH s6, 26[y_m6]
 692                                            ; Check if the significant is already normalized or not
 692  0D610                                     TEST s6, 10
 693  366A8                                     JUMP NZ, 6A8[already_normalized_y]
 694                                            ; Significand is not normalized so normalize it.
 694                                            ; Continue loading mx into registers
 694  0B527                                     FETCH s5, 27[y_m5]
 695  0B428                                     FETCH s4, 28[y_m4]
 696  0B329                                     FETCH s3, 29[y_m3]
 697  0B22A                                     FETCH s2, 2A[y_m2]
 698  0B12B                                     FETCH s1, 2B[y_m1]
 699  0B02C                                     FETCH s0, 2C[y_m0]
 69A  20639                                     CALL 639[mul_cancellation]                      ; return sA = number of bits shifted to left
 69B  2F626                                     STORE s6, 26[y_m6]
 69C  2F527                                     STORE s5, 27[y_m5]
 69D  2F428                                     STORE s4, 28[y_m4]
 69E  2F329                                     STORE s3, 29[y_m3]
 69F  2F22A                                     STORE s2, 2A[y_m2]
 6A0  2F12B                                     STORE s1, 2B[y_m1]
 6A1  2F02C                                     STORE s0, 2C[y_m0]
 6A2                                            ; Subtract exponent by sA
 6A2  0BE25                                     FETCH sE, 25[y_ex6]
 6A3  0BF24                                     FETCH sF, 24[y_ex7]
 6A4  18EA0                                     SUB sE, sA
 6A5  1BF00                                     SUBCY sF, 00
 6A6  2FE25                                     STORE sE, 25[y_ex6]
 6A7  2FF24                                     STORE sF, 24[y_ex7]
 6A8                      already_normalized_y: 
 6A8  25000                                     RETURN 
 6A9                                            ;-------------------------------------------------------------
 6A9                                            ; s3 is lowest byte and s2 has guard bits
 6A9                                 mul_round: 
 6A9                                            ; -------------------------------------------------
 6A9                                            ; Calculate the sticky bit
 6A9  0D210                                     TEST s2, 10
 6AA  326AC                                     JUMP Z, 6AC[dont_set_sticky_bit]
 6AB  05220                                     OR s2, 20
 6AC                       dont_set_sticky_bit: 
 6AC                                            ; Rounding:
 6AC                                            ; Check the guard bit - s0[7]
 6AC  0D280                                     TEST s2, 80
 6AD  366AF                                     JUMP NZ, 6AF[mul_guard_bit_is_1]
 6AE                                            ; Gaurd bit = 0 : Round down (Do  nothing)
 6AE  226B7                                     JUMP 6B7[mul_round_RET_zero]
 6AF                        mul_guard_bit_is_1: 
 6AF                                            ; Gaurd bit = 1, Check the round bit
 6AF  0D240                                     TEST s2, 40
 6B0  326B2                                     JUMP Z, 6B2[mul_round_bit_is_0]
 6B1                                            ; Gaurd bit = 1, Round bit = 1 : Round Up (add 1 to mantissa)
 6B1  226B6                                     JUMP 6B6[mul_round_RET_one]
 6B2                        mul_round_bit_is_0: 
 6B2                                            ; Gaurd bit = 1, Round bit = 0 : Check the Sticky bit
 6B2  0D220                                     TEST s2, 20
 6B3  366B6                                     JUMP NZ, 6B6[mul_round_RET_one]                 ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 1 : Round Up (add 1 to mantissa)
 6B4                                            ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 0 : Round to nearest even,
 6B4                                            ;       Means round up if bit before Guard bit is 1, else round down.
 6B4  0D301                                     TEST s3, 01
 6B5  326B7                                     JUMP Z, 6B7[mul_round_RET_zero]
 6B6                         mul_round_RET_one: 
 6B6  11301                                     ADD s3, 01
 6B7                        mul_round_RET_zero: 
 6B7  25000                                     RETURN 
 6B8                                            ;-----------------------------------------------------------------------------------
 6B8                                            ; Software Implementation of Floating-Point Arithmetic, Double-Precision (64 bit).
 6B8                                            ;
 6B8                                            ; beta(radix) = 2, k(width) = 64, p(precision) = 53, e_max = 1023
 6B8                                            ;
 6B8                                            ;------------------------------------------------------------------------------------
 6B8                                            ; Procedure:   arith_div_x_y()
 6B8                                            ;
 6B8                                            ; Registers Used: Bank0 : All
 6B8                                            ;     Bank1 : None
 6B8                                            ;
 6B8                                            ; Arguments:   Bank0 :
 6B8                                            ;     Bank1 : None
 6B8                                            ;     SPM   : x = [x_7, x_6, ..., x_0]
 6B8                                            ;            y = [y_7, y_6, ..., y_0]
 6B8                                            ;
 6B8                                            ; Calls:    set_ops_status
 6B8                                            ;     decompose_x
 6B8                                            ;     decompose_y
 6B8                                            ;
 6B8                                            ;
 6B8                                            ; RETs:    None
 6B8                                            ;
 6B8                                            ; RETURN Flags:   None
 6B8                                            ;
 6B8                                            ; Description:  Divides two 64-bit double-precision floating point numbers.
 6B8                                            ;------------------------------------------------------------------------------------
 6B8                             arith_div_x_y: 
 6B8  2034E                                     CALL 34E[set_ops_status]
 6B9  202FA                                     CALL 2FA[decompose_x]
 6BA  20324                                     CALL 324[decompose_y]
 6BB  20758                                     CALL 758[div_special_cases]
 6BC  1DFFF                                     COMPARE sF, FF
 6BD  32757                                     JUMP Z, 757[done_dividing]
 6BE  20679                                     CALL 679[mul_normalize_mx]
 6BF  20691                                     CALL 691[mul_normalize_my]
 6C0                                            ; op1 and op2 both are normal
 6C0  2077D                                     CALL 77D[div_mx_my]                             ; result is in [Umr_6, Lmr_6]
 6C1  207D7                                     CALL 7D7[sub_Ex_Ey]                             ; exponent of result in [s1, s0]
 6C2  3E6C5                                     JUMP NC, 6C5[no_sub_ex_ey_overflow]
 6C3  01C01                                     LOAD sC, 01                                     ; Set flag
 6C4  226C6                                     JUMP 6C6[sub_ex_ey_overflow_done]
 6C5                     no_sub_ex_ey_overflow: 
 6C5  01C00                                     LOAD sC, 00
 6C6                   sub_ex_ey_overflow_done: 
 6C6                                            ; Save the er
 6C6  2F030                                     STORE s0, 30[r_ex6]
 6C7  2F12F                                     STORE s1, 2F[r_ex7]
 6C8                                            ; Check the result exponent
 6C8                                            ;---------------------------------------------------------------
 6C8                                            ; if er < 0 and er > -53 then result is subnormal, shift significand by er and set the er to zero
 6C8                                            ; if er < 0 and er <= -53 then the result is zero (underflow).
 6C8                                            ; if er = 0 then the result is subnormal but no shift is needed.
 6C8                                            ; if er > 0 then the result is normal.
 6C8                                            ; if er > 7FE then the result is infinity.
 6C8                                            ; -53 = FFDD = - 0023
 6C8                                            ; Read the mr [Umr_6 downto Lmr_6] (64-bits)
 6C8                        div_result_not_inf: 
 6C8  0B740                                     FETCH s7, 40[Umr_6]
 6C9  0B641                                     FETCH s6, 41[Umr_5]
 6CA  0B542                                     FETCH s5, 42[Umr_4]
 6CB  0B443                                     FETCH s4, 43[Umr_3]
 6CC  0B344                                     FETCH s3, 44[Umr_2]
 6CD  0B245                                     FETCH s2, 45[Umr_1]
 6CE  0B146                                     FETCH s1, 46[Umr_0]
 6CF  0B047                                     FETCH s0, 47[Lmr_6]
 6D0                                            ; Set the sticky bit
 6D0  01E06                                     LOAD sE, 06                                     ; Counter
 6D1  00F00                                     LOAD sF, s0                                     ; Copy s0
 6D2                   div_set_sticky_bit_loop: 
 6D2  14F0E                                     SR0 sF
 6D3  3E6D5                                     JUMP NC, 6D5[dont_turn_sticky_bit_on]
 6D4  05020                                     OR s0, 20                                       ; Turn sticky bit on
 6D5                   dont_turn_sticky_bit_on: 
 6D5  19E01                                     SUB sE, 01
 6D6  366D2                                     JUMP NZ, 6D2[div_set_sticky_bit_loop]
 6D7  0BB2F                                     FETCH sB, 2F[r_ex7]
 6D8  0BA30                                     FETCH sA, 30[r_ex6]
 6D9  0DB80                                     TEST sB, 80
 6DA  326F2                                     JUMP Z, 6F2[div_check_overflow]                 ; Normal case, so skip all subnormal tests, and check compose result if there is no overflow
 6DB                                            ; Here we are sure that the er is negative
 6DB  07BFF                                     XOR sB, FF                                      ; Find the twos's complement of er
 6DC  07AFF                                     XOR sA, FF
 6DD  11A01                                     ADD sA, 01
 6DE  13B00                                     ADDCY sB, 00
 6DF  1DA34                                     COMPARE sA, 34
 6E0  1FB00                                     COMPARECY sB, 00
 6E1  32756                                     JUMP Z, 756[div_result_is_zero]                 ; er = -53, underflow
 6E2  3A6E4                                     JUMP C, 6E4[div_er_greater_than_53]             ; er > -53, subnormal
 6E3  22756                                     JUMP 756[div_result_is_zero]                    ; er < -53. underflow
 6E4                    div_er_greater_than_53: 
 6E4             div_keep_shifting_mr_to_right: 
 6E4  1470E                                     SR0 s7
 6E5  14608                                     SRA s6
 6E6  14508                                     SRA s5
 6E7  14408                                     SRA s4
 6E8  14308                                     SRA s3
 6E9  14208                                     SRA s2
 6EA  14108                                     SRA s1
 6EB  14008                                     SRA s0
 6EC  19A01                                     SUB sA, 01
 6ED  1BB00                                     SUBCY sB, 00
 6EE  366E4                                     JUMP NZ, 6E4[div_keep_shifting_mr_to_right]
 6EF                                            ; Here [sB, sA] must be zero
 6EF                                            ; Save the er
 6EF  2FA30                                     STORE sA, 30[r_ex6]
 6F0  2FB2F                                     STORE sB, 2F[r_ex7]
 6F1  22708                                     JUMP 708[div_dont_shift_mr_left_subnormal]
 6F2                        div_check_overflow: 
 6F2                                            ; exponent is in [sB, sA], check if result exp. > 7FF?
 6F2  1DAFF                                     COMPARE sA, FF
 6F3  1FB07                                     COMPARECY sB, 07
 6F4  326F7                                     JUMP Z, 6F7[div_compose_result]
 6F5  3A6F7                                     JUMP C, 6F7[div_compose_result]
 6F6                                            ; Overflow
 6F6  2280C                                     JUMP 80C[return_inf]
 6F7                        div_compose_result: 
 6F7                                            ; Significance now is in [s7, s0] with these structure:
 6F7                                            ;  s6       _ s5,...,s1 _
 6F7                                            ;  hsss_ssss_  ss...ss  _ ssss_sggg
 6F7                                            ; h means hidden bit, s means significance, g means three guard bits
 6F7                                            ; Check Bit 53, if it is 0 we have to shift left by 1 otherwise don't do anything
 6F7  0D780                                     TEST s7, 80
 6F8  36710                                     JUMP NZ, 710[div_dont_shift_mr_left]
 6F9  14006                                     SL0 s0
 6FA  14100                                     SLA s1
 6FB  14200                                     SLA s2
 6FC  14300                                     SLA s3
 6FD  14400                                     SLA s4
 6FE  14500                                     SLA s5
 6FF  14600                                     SLA s6
 700  14700                                     SLA s7
 701                                            ; Load the er
 701  0BE30                                     FETCH sE, 30[r_ex6]
 702  0BF2F                                     FETCH sF, 2F[r_ex7]
 703  19E01                                     SUB sE, 01
 704  1BF00                                     SUBCY sF, 00
 705                                            ; Save the er
 705  2FE30                                     STORE sE, 30[r_ex6]
 706  2FF2F                                     STORE sF, 2F[r_ex7]
 707  22710                                     JUMP 710[div_dont_shift_mr_left]
 708          div_dont_shift_mr_left_subnormal: 
 708  1470E                                     SR0 s7
 709  14608                                     SRA s6
 70A  14508                                     SRA s5
 70B  14408                                     SRA s4
 70C  14308                                     SRA s3
 70D  14208                                     SRA s2
 70E  14108                                     SRA s1
 70F  14008                                     SRA s0
 710                    div_dont_shift_mr_left: 
 710                                            ; now the significance is [s7 downto s1] with following pattern:
 710                                            ; s7  s6,...,s2 s1
 710                                            ; xsss ssss
 710                                            ; shift to right by 3
 710  1470E                                     SR0 s7
 711  14608                                     SRA s6
 712  14508                                     SRA s5
 713  14408                                     SRA s4
 714  14308                                     SRA s3
 715  14208                                     SRA s2
 716  14108                                     SRA s1
 717  14008                                     SRA s0
 718  1470E                                     SR0 s7
 719  14608                                     SRA s6
 71A  14508                                     SRA s5
 71B  14408                                     SRA s4
 71C  14308                                     SRA s3
 71D  14208                                     SRA s2
 71E  14108                                     SRA s1
 71F  14008                                     SRA s0
 720  1470E                                     SR0 s7
 721  14608                                     SRA s6
 722  14508                                     SRA s5
 723  14408                                     SRA s4
 724  14308                                     SRA s3
 725  14208                                     SRA s2
 726  14108                                     SRA s1
 727  14008                                     SRA s0
 728  0DC01                                     TEST sC, 01
 729  32735                                     JUMP Z, 735[div_no_exp_overflow_detected]
 72A  1DA00                                     COMPARE sA, 00
 72B  1FB00                                     COMPARECY sB, 00
 72C  36735                                     JUMP NZ, 735[div_no_exp_overflow_detected]
 72D  1470E                                     SR0 s7
 72E  14608                                     SRA s6
 72F  14508                                     SRA s5
 730  14408                                     SRA s4
 731  14308                                     SRA s3
 732  14208                                     SRA s2
 733  14108                                     SRA s1
 734  14008                                     SRA s0
 735              div_no_exp_overflow_detected: 
 735                                            ; Now significance is in [s7, s1]
 735  0370F                                     AND s7, 0F
 736                                            ; Round the significance s1 lowest byte, s0 has guard bits.
 736  20802                                     CALL 802[div_round]
 737                                            ; Propogate the carry produced by possible rounding
 737  13200                                     ADDCY s2, 00
 738  13300                                     ADDCY s3, 00
 739  13400                                     ADDCY s4, 00
 73A  13500                                     ADDCY s5, 00
 73B  13600                                     ADDCY s6, 00
 73C  13700                                     ADDCY s7, 00
 73D                                            ; Load the er
 73D  0BE30                                     FETCH sE, 30[r_ex6]
 73E  0BF2F                                     FETCH sF, 2F[r_ex7]
 73F                                            ; Compose the result
 73F                                            ; Combine exponent [sF, sE] and significand [s6, ..., s0]
 73F                                            ; Shift exponent to left by 4
 73F  14E06                                     SL0 sE
 740  14F00                                     SLA sF
 741  14E06                                     SL0 sE
 742  14F00                                     SLA sF
 743  14E06                                     SL0 sE
 744  14F00                                     SLA sF
 745  14E06                                     SL0 sE
 746  14F00                                     SLA sF
 747                                            ; Combine the exponent with significand
 747  04E70                                     OR sE, s7
 748                                            ; Calculate the sign
 748  0BB18                                     FETCH sB, 18[x_sign]
 749  0BA23                                     FETCH sA, 23[y_sign]
 74A  06BA0                                     XOR sB, sA                                      ; Calculate the sign
 74B  03B80                                     AND sB, 80
 74C  04FB0                                     OR sF, sB                                       ; Apply the sign
 74D                                            ; Save the result in SMP
 74D  2F117                                     STORE s1, 17[r_0]
 74E  2F216                                     STORE s2, 16[r_1]
 74F  2F315                                     STORE s3, 15[r_2]
 750  2F414                                     STORE s4, 14[r_3]
 751  2F513                                     STORE s5, 13[r_4]
 752  2F612                                     STORE s6, 12[r_5]
 753  2FE11                                     STORE sE, 11[r_6]
 754  2FF10                                     STORE sF, 10[r_7]
 755  22757                                     JUMP 757[done_dividing]
 756                        div_result_is_zero: 
 756  205EE                                     CALL 5EE[return_zero_mul]
 757                             done_dividing: 
 757  25000                                     RETURN 
 758                                            ;------------------------------------------------------------------------------------
 758                                            ; Procedure:   div_special_cases()
 758                                            ;
 758                                            ; Registers Used: Bank0 : s1, s2
 758                                            ;     Bank1 : None
 758                                            ;
 758                                            ; Arguments:   Bank0 : None
 758                                            ;     Bank1 : None
 758                                            ;
 758                                            ;
 758                                            ; Calls:
 758                                            ;
 758                                            ; RETs:    Bank1: [s1. s0]
 758                                            ;
 758                                            ; RETURN Flags:   None
 758                                            ;
 758                                            ; Description:  Takes care of special operands in division.
 758                                            ;     Return FF in sF if one of the operands is special.
 758                                            ;     If sF is FF then the result is already in [r_7, r_8] in SPM.
 758                                            ;------------------------------------------------------------------------------------
 758                         div_special_cases: 
 758  0B13A                                     FETCH s1, 3A[op1_status]                        ; read the ops status
 759  0B23B                                     FETCH s2, 3B[op2_status]                        ; read the ops status
 75A                                            ; We check op1 for
 75A                                            ; 1) NaN
 75A                                            ;  Yes: return X_NaN
 75A                                            ;  No:  Go to step 2.
 75A                                            ; 2) Infinity
 75A                                            ;  Yes: Check op2, if +0 and NaN then return_NaN_Inf
 75A                                            ;  No:  return +infinity
 75A                                            ; 3) Zero
 75A                                            ;  Yes: check if op2 is +inf or NaN then return_NaN_Inf
 75A                                            ;     else return 0
 75A                                            ;  No:  check op2
 75A                                            ;-----------------------------------------------
 75A                                            ; Check if op1 is NaN
 75A  0D110                                     TEST s1, 10
 75B  3275F                                     JUMP Z, 75F[div_final_op1_not_NaN]              ; No
 75C                         div_final_op1_NaN: ; Yes
 75C                                            ; Check if op2 is NaN
 75C  0D210                                     TEST s2, 10
 75D  36631                                     JUMP NZ, 631[return_xy_NAN]                     ; Yes
 75E  22177                                     JUMP 177[return_x_NAN]
 75F                     div_final_op1_not_NaN: 
 75F                                            ; Check if op1 is Inf
 75F  0D120                                     TEST s1, 20
 760  32768                                     JUMP Z, 768[div_final_op1_not_Inf]              ; No
 761                         div_final_op1_Inf: ; Yes
 761                                            ; Check if op2 is zero
 761  0D240                                     TEST s2, 40
 762  3661F                                     JUMP NZ, 61F[return_pos_inf]                    ; Yes
 763                                            ; Check if op2 is Inf
 763  0D220                                     TEST s2, 20
 764  3681E                                     JUMP NZ, 81E[div_return_NAN]                    ; Yes
 765                                            ; Check if op2 is NaN
 765  0D210                                     TEST s2, 10
 766  361BC                                     JUMP NZ, 1BC[return_y_NAN]                      ; Yes
 767  2260E                                     JUMP 60E[return_x_Inf]
 768                     div_final_op1_not_Inf: 
 768                                            ; Check if op1 is zero
 768  0D140                                     TEST s1, 40
 769  3276F                                     JUMP Z, 76F[div_check_final_op2]                ; No
 76A                     div_final_op1_is_zero: 
 76A                                            ; Check if op2 is zero
 76A  0D240                                     TEST s2, 40
 76B  367F0                                     JUMP NZ, 7F0[return_div_NAN]                    ; Yes
 76C                                            ; Check if op2 is NaN
 76C  0D210                                     TEST s2, 10
 76D  365E3                                     JUMP NZ, 5E3[return_y_NAN_positive]             ;Yes
 76E  225EE                                     JUMP 5EE[return_zero_mul]
 76F                       div_check_final_op2: ; Here we are sure op1 is (sub)normal
 76F                                            ; Check if op2 is NaN
 76F  0D210                                     TEST s2, 10
 770  36772                                     JUMP NZ, 772[div_return_y_NAN_positive]         ;Yes
 771  22777                                     JUMP 777[div_final_op2_not_NaN]
 772                 div_return_y_NAN_positive: 
 772                                            ; make y positive
 772  01E7F                                     LOAD sE, 7F
 773  0BD08                                     FETCH sD, 08[y_7]
 774  02DE0                                     AND sD, sE
 775  2FD08                                     STORE sD, 08[y_7]
 776  221BC                                     JUMP 1BC[return_y_NAN]
 777                     div_final_op2_not_NaN: ; No
 777                                            ; Check if op2 is Infinity
 777  0D220                                     TEST s2, 20
 778  365EE                                     JUMP NZ, 5EE[return_zero_mul]                   ; Yes
 779                                            ; Check if op2 is zero
 779  0D240                                     TEST s2, 40
 77A  3660E                                     JUMP NZ, 60E[return_x_Inf]                      ; Yes
 77B                                            ; Both operators are (sub)normal. Perform the multiplication.
 77B  01F00                                     LOAD sF, 00
 77C  25000                                     RETURN 
 77D                                            ;------------------------------------------------------------------------------------
 77D                                            ; Procedure:   div_mx_my()
 77D                                            ;
 77D                                            ; Registers Used: Bank0 : All
 77D                                            ;     Bank1 : None
 77D                                            ;
 77D                                            ; Arguments:   Bank0 : None
 77D                                            ;     Bank1 : None
 77D                                            ;     SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
 77D                                            ;       y_m6, y_m5, ... y_m0  (7-bytes)
 77D                                            ;
 77D                                            ;
 77D                                            ; Calls:
 77D                                            ;
 77D                                            ; RETs:    Bank0: [s6 doento s0] is reminder
 77D                                            ;     Bank1: [s6 downto s0] is Quotient
 77D                                            ;
 77D                                            ; RETURN Flags:   None
 77D                                            ;
 77D                                            ; Description:  Divides two 53-bit double-precision floating point numbers.
 77D                                            ;------------------------------------------------------------------------------------
 77D                                 div_mx_my: 
 77D                                            ; Set quotient [s7, s0] to 0
 77D  37001                                     REGBANK B
 77E  01000                                     LOAD s0, 00
 77F  01100                                     LOAD s1, 00
 780  01200                                     LOAD s2, 00
 781  01300                                     LOAD s3, 00
 782  01400                                     LOAD s4, 00
 783  01500                                     LOAD s5, 00
 784  01600                                     LOAD s6, 00
 785  01700                                     LOAD s7, 00
 786  37000                                     REGBANK A
 787                                            ; Load mx: dividend
 787  01700                                     LOAD s7, 00
 788  0B61B                                     FETCH s6, 1B[x_m6]
 789  0B51C                                     FETCH s5, 1C[x_m5]
 78A  0B41D                                     FETCH s4, 1D[x_m4]
 78B  0B31E                                     FETCH s3, 1E[x_m3]
 78C  0B21F                                     FETCH s2, 1F[x_m2]
 78D  0B120                                     FETCH s1, 20[x_m1]
 78E  0B021                                     FETCH s0, 21[x_m0]
 78F                                            ; Load my: divisor
 78F  01F00                                     LOAD sF, 00
 790  0BE26                                     FETCH sE, 26[y_m6]
 791  0BD27                                     FETCH sD, 27[y_m5]
 792  0BC28                                     FETCH sC, 28[y_m4]
 793  0BB29                                     FETCH sB, 29[y_m3]
 794  0BA2A                                     FETCH sA, 2A[y_m2]
 795  0B92B                                     FETCH s9, 2B[y_m1]
 796  0B82C                                     FETCH s8, 2C[y_m0]
 797  37001                                     REGBANK B
 798  01F40                                     LOAD sF, 40                                     ; This is the counter, we need to loop 64 times
 799  37000                                     REGBANK A
 79A                          compare_dividend: 
 79A                                            ; Is dividend >= divisor ?
 79A  1C080                                     COMPARE s0, s8
 79B  1E190                                     COMPARECY s1, s9
 79C  1E2A0                                     COMPARECY s2, sA
 79D  1E3B0                                     COMPARECY s3, sB
 79E  1E4C0                                     COMPARECY s4, sC
 79F  1E5D0                                     COMPARECY s5, sD
 7A0  1E6E0                                     COMPARECY s6, sE
 7A1  1E7F0                                     COMPARECY s7, sF
 7A2  3A7B6                                     JUMP C, 7B6[dividend_is_less]
 7A3                                            ; dividend is greateror than divisor
 7A3                                            ; mx - my
 7A3  18080                                     SUB s0, s8
 7A4  1A190                                     SUBCY s1, s9
 7A5  1A2A0                                     SUBCY s2, sA
 7A6  1A3B0                                     SUBCY s3, sB
 7A7  1A4C0                                     SUBCY s4, sC
 7A8  1A5D0                                     SUBCY s5, sD
 7A9  1A6E0                                     SUBCY s6, sE
 7AA  1A7F0                                     SUBCY s7, sF
 7AB                                            ; Append 1 to quotient
 7AB  37001                                     REGBANK B
 7AC  14007                                     SL1 s0
 7AD  14100                                     SLA s1
 7AE  14200                                     SLA s2
 7AF  14300                                     SLA s3
 7B0  14400                                     SLA s4
 7B1  14500                                     SLA s5
 7B2  14600                                     SLA s6
 7B3  14700                                     SLA s7
 7B4  37000                                     REGBANK A
 7B5  227C0                                     JUMP 7C0[shift_dividend_left]
 7B6                          dividend_is_less: 
 7B6                                            ; Append 0 to quotient
 7B6  37001                                     REGBANK B
 7B7  14006                                     SL0 s0
 7B8  14100                                     SLA s1
 7B9  14200                                     SLA s2
 7BA  14300                                     SLA s3
 7BB  14400                                     SLA s4
 7BC  14500                                     SLA s5
 7BD  14600                                     SLA s6
 7BE  14700                                     SLA s7
 7BF  37000                                     REGBANK A
 7C0                       shift_dividend_left: 
 7C0                                            ; Shift mx (dividend) to left by 1
 7C0  14006                                     SL0 s0
 7C1  14100                                     SLA s1
 7C2  14200                                     SLA s2
 7C3  14300                                     SLA s3
 7C4  14400                                     SLA s4
 7C5  14500                                     SLA s5
 7C6  14600                                     SLA s6
 7C7  14700                                     SLA s7
 7C8  37001                                     REGBANK B
 7C9  19F01                                     SUB sF, 01                                      ; Decrement the counter
 7CA  37000                                     REGBANK A
 7CB  3679A                                     JUMP NZ, 79A[compare_dividend]
 7CC                              div_finished: 
 7CC  37001                                     REGBANK B
 7CD  2F740                                     STORE s7, 40[Umr_6]
 7CE  2F641                                     STORE s6, 41[Umr_5]
 7CF  2F542                                     STORE s5, 42[Umr_4]
 7D0  2F443                                     STORE s4, 43[Umr_3]
 7D1  2F344                                     STORE s3, 44[Umr_2]
 7D2  2F245                                     STORE s2, 45[Umr_1]
 7D3  2F146                                     STORE s1, 46[Umr_0]
 7D4  2F047                                     STORE s0, 47[Lmr_6]
 7D5  37000                                     REGBANK A
 7D6  25000                                     RETURN 
 7D7                                            ;------------------------------------------------------------------------------------
 7D7                                            ; Procedure:   sub_Ex_Ey()
 7D7                                            ;
 7D7                                            ; Registers Used: Bank0 : All
 7D7                                            ;     Bank1 : None
 7D7                                            ;
 7D7                                            ; Arguments:   Bank0 : None
 7D7                                            ;     Bank1 : None
 7D7                                            ;     SPM   : x_m6, x_m5, ... x_m0 (7-bytes)
 7D7                                            ;       y_m6, y_m5, ... y_m0  (7-bytes)
 7D7                                            ;
 7D7                                            ;
 7D7                                            ; Calls:
 7D7                                            ;
 7D7                                            ; RETs:    Bank1: [s1. s0]
 7D7                                            ;
 7D7                                            ; RETURN Flags:   None
 7D7                                            ;
 7D7                                            ; Description:  Calculates the ex + ey which is Ex + Ey - bias(1023) and returns
 7D7                                            ;      the result in [s1, s0].
 7D7                                            ;------------------------------------------------------------------------------------
 7D7                                 sub_Ex_Ey: 
 7D7                                            ; Read ex
 7D7  0B119                                     FETCH s1, 19[x_ex7]
 7D8  0B01A                                     FETCH s0, 1A[x_ex6]
 7D9                                            ; if op1 is subnormal then subtract by 1022 else subtract by  1023
 7D9  0BF3A                                     FETCH sF, 3A[op1_status]
 7DA  0DF80                                     TEST sF, 80
 7DB  367DF                                     JUMP NZ, 7DF[sub_subnormal_exponent_detected]
 7DC                                            ; Subtract by 1023
 7DC  190FF                                     SUB s0, FF
 7DD  1B103                                     SUBCY s1, 03
 7DE  227E1                                     JUMP 7E1[sub_done_exponent_subtracting]
 7DF           sub_subnormal_exponent_detected: 
 7DF                                            ; Subtract by 1022
 7DF  190FE                                     SUB s0, FE
 7E0  1B103                                     SUBCY s1, 03
 7E1             sub_done_exponent_subtracting: 
 7E1                                            ; Read ey
 7E1  0B324                                     FETCH s3, 24[y_ex7]
 7E2  0B225                                     FETCH s2, 25[y_ex6]
 7E3                                            ; if [s1, s0] == zero then subtract 1022 else subtract 1023
 7E3  0BF3B                                     FETCH sF, 3B[op2_status]
 7E4  0DF80                                     TEST sF, 80
 7E5  367E9                                     JUMP NZ, 7E9[sub_subnormal_exponent_detected_y]
 7E6                                            ; Subtract by 1023
 7E6  192FF                                     SUB s2, FF
 7E7  1B303                                     SUBCY s3, 03
 7E8  227EB                                     JUMP 7EB[sub_done_exponent_subtracting_y]
 7E9         sub_subnormal_exponent_detected_y: 
 7E9                                            ; Subtract by 1022
 7E9  192FE                                     SUB s2, FE
 7EA  1B303                                     SUBCY s3, 03
 7EB           sub_done_exponent_subtracting_y: 
 7EB  18020                                     SUB s0, s2
 7EC  1A130                                     SUBCY s1, s3
 7ED  110FF                                     ADD s0, FF                                      ; subtract by 1023'd =  03FF
 7EE  13103                                     ADDCY s1, 03
 7EF  25000                                     RETURN 
 7F0                            return_div_NAN: 
 7F0  01FFF                                     LOAD sF, FF
 7F1  0177F                                     LOAD s7, 7F
 7F2  016F8                                     LOAD s6, F8
 7F3  01500                                     LOAD s5, 00
 7F4  01400                                     LOAD s4, 00
 7F5  01300                                     LOAD s3, 00
 7F6  01200                                     LOAD s2, 00
 7F7  01100                                     LOAD s1, 00
 7F8  01000                                     LOAD s0, 00
 7F9  2F710                                     STORE s7, 10[r_7]
 7FA  2F611                                     STORE s6, 11[r_6]
 7FB  2F512                                     STORE s5, 12[r_5]
 7FC  2F413                                     STORE s4, 13[r_4]
 7FD  2F314                                     STORE s3, 14[r_3]
 7FE  2F215                                     STORE s2, 15[r_2]
 7FF  2F116                                     STORE s1, 16[r_1]
 800  2F017                                     STORE s0, 17[r_0]
 801  25000                                     RETURN 
 802                                            ;-------------------------------------------------------------
 802                                            ; s1 has the lowest byte, and s0 has the guard bits
 802                                 div_round: 
 802                                            ; -------------------------------------------------
 802                                            ; Calculate the sticky bit
 802                                            ; Check the guard bit - s0[7]
 802  0D080                                     TEST s0, 80
 803  36805                                     JUMP NZ, 805[div_guard_bit_is_1]
 804                                            ; Gaurd bit = 0 : Round down (Do  nothing)
 804  2280B                                     JUMP 80B[div_round_RET_zero]
 805                        div_guard_bit_is_1: 
 805                                            ; Gaurd bit = 1, Check the round bit
 805  0D040                                     TEST s0, 40
 806  32808                                     JUMP Z, 808[div_round_bit_is_0]
 807                                            ; Gaurd bit = 1, Round bit = 1 : Round Up (add 1 to mantissa)
 807  2280A                                     JUMP 80A[div_round_RET_one]
 808                        div_round_bit_is_0: 
 808                                            ; Gaurd bit = 1, Round bit = 0 : Check the Sticky bit
 808  0D020                                     TEST s0, 20
 809  3680A                                     JUMP NZ, 80A[div_round_RET_one]                 ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 1 : Round Up (add 1 to mantissa)
 80A                                            ; Gaurd bit = 1, Round bit = 0 , Sticky bit = 0 : Round to nearest even,
 80A                                            ;       Means round up if bit before Guard bit is 1, else round down.
 80A                                            ;TEST  s1, 01
 80A                                            ;JUMP  Z, div_round_RET_zero
 80A                         div_round_RET_one: 
 80A  11101                                     ADD s1, 01
 80B                        div_round_RET_zero: 
 80B  25000                                     RETURN 
 80C                                return_inf: 
 80C  01FFF                                     LOAD sF, FF                                     ; Signal the caller that the operation is complete.
 80D                                            ; Calculate the sign
 80D  0BB18                                     FETCH sB, 18[x_sign]
 80E  0BA23                                     FETCH sA, 23[y_sign]
 80F  06BA0                                     XOR sB, sA                                      ; Calculate the sign
 810  03B80                                     AND sB, 80
 811  0127F                                     LOAD s2, 7F
 812  042B0                                     OR s2, sB                                       ; Apply the sign
 813  011F0                                     LOAD s1, F0
 814  01000                                     LOAD s0, 00
 815  2F210                                     STORE s2, 10[r_7]
 816  2F111                                     STORE s1, 11[r_6]
 817  2F012                                     STORE s0, 12[r_5]
 818  2F013                                     STORE s0, 13[r_4]
 819  2F014                                     STORE s0, 14[r_3]
 81A  2F015                                     STORE s0, 15[r_2]
 81B  2F016                                     STORE s0, 16[r_1]
 81C  2F017                                     STORE s0, 17[r_0]
 81D  25000                                     RETURN 
 81E                            div_return_NAN: 
 81E  01FFF                                     LOAD sF, FF                                     ; Signal the caller that the operation is complete.
 81F                                            ; Calculate the sign
 81F  0BB18                                     FETCH sB, 18[x_sign]
 820  0BA23                                     FETCH sA, 23[y_sign]
 821  06BA0                                     XOR sB, sA                                      ; Calculate the sign
 822  03B80                                     AND sB, 80
 823  0127F                                     LOAD s2, 7F
 824                                            ;OR  s2, sB   ; Apply the sign
 824  011F8                                     LOAD s1, F8
 825  01000                                     LOAD s0, 00
 826  2F210                                     STORE s2, 10[r_7]
 827  2F111                                     STORE s1, 11[r_6]
 828  2F012                                     STORE s0, 12[r_5]
 829  2F013                                     STORE s0, 13[r_4]
 82A  2F014                                     STORE s0, 14[r_3]
 82B  2F015                                     STORE s0, 15[r_2]
 82C  2F016                                     STORE s0, 16[r_1]
 82D  2F017                                     STORE s0, 17[r_0]
 82E  25000                                     RETURN 


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\esi\workspace\pico_blaze_conversion\pBlaze_prog.psm



List of defined constants

 CONSTANT name              Value        Source PSM File

 timestamp_hours            02'd         
 timestamp_minutes          07'd         
 timestamp_seconds          34'd         
 datestamp_year             19'd         
 datestamp_month            3'd          
 datestamp_day              03'd         
 NUL                        00           
 BEL                        07           
 BS                         08           
 HT                         09           
 LF                         0A           
 VT                         0B           
 CR                         0D           
 ESC                        1B           
 DEL                        7F           
 DCS                        90           
 ST                         9C           
 UART_Tx_data_present       00000001'b   pBlaze_prog.psm
 UART_Tx_half_full          00000010'b   pBlaze_prog.psm
 UART_Tx_full               00000100'b   pBlaze_prog.psm
 UART_Rx_data_present       00001000'b   pBlaze_prog.psm
 UART_Rx_half_full          00010000'b   pBlaze_prog.psm
 UART_Rx_full               00100000'b   pBlaze_prog.psm
 UART_RX6_status_input_port 00           pBlaze_prog.psm
 UART_RX6_data_input_port   01           pBlaze_prog.psm
 Extra_mem_input_port       02           pBlaze_prog.psm
 UART_TX6_output_port       00           pBlaze_prog.psm
 Extra_mem_lo_output_port   01           pBlaze_prog.psm
 Extra_mem_hi_output_port   02           pBlaze_prog.psm
 Extra_mem_output_port      03           pBlaze_prog.psm
 irqs_output_port           04           pBlaze_prog.psm
 reset_UART_port            01           pBlaze_prog.psm
 UART_tx_reset              00000001'b   pBlaze_prog.psm
 UART_rx_reset              00000010'b   pBlaze_prog.psm
 UART_reset                 00000011'b   pBlaze_prog.psm
 UART_operate               00000000'b   pBlaze_prog.psm
 x_7                        0'd          pBlaze_prog.psm
 x_6                        1'd          pBlaze_prog.psm
 x_5                        2'd          pBlaze_prog.psm
 x_4                        3'd          pBlaze_prog.psm
 x_3                        4'd          pBlaze_prog.psm
 x_2                        5'd          pBlaze_prog.psm
 x_1                        6'd          pBlaze_prog.psm
 x_0                        7'd          pBlaze_prog.psm
 y_7                        8'd          pBlaze_prog.psm
 y_6                        9'd          pBlaze_prog.psm
 y_5                        10'd         pBlaze_prog.psm
 y_4                        11'd         pBlaze_prog.psm
 y_3                        12'd         pBlaze_prog.psm
 y_2                        13'd         pBlaze_prog.psm
 y_1                        14'd         pBlaze_prog.psm
 y_0                        15'd         pBlaze_prog.psm
 r_7                        16'd         pBlaze_prog.psm
 r_6                        17'd         pBlaze_prog.psm
 r_5                        18'd         pBlaze_prog.psm
 r_4                        19'd         pBlaze_prog.psm
 r_3                        20'd         pBlaze_prog.psm
 r_2                        21'd         pBlaze_prog.psm
 r_1                        22'd         pBlaze_prog.psm
 r_0                        23'd         pBlaze_prog.psm
 x_sign                     24'd         pBlaze_prog.psm
 x_ex7                      25'd         pBlaze_prog.psm
 x_ex6                      26'd         pBlaze_prog.psm
 x_m6                       27'd         pBlaze_prog.psm
 x_m5                       28'd         pBlaze_prog.psm
 x_m4                       29'd         pBlaze_prog.psm
 x_m3                       30'd         pBlaze_prog.psm
 x_m2                       31'd         pBlaze_prog.psm
 x_m1                       32'd         pBlaze_prog.psm
 x_m0                       33'd         pBlaze_prog.psm
 x_grs                      34'd         pBlaze_prog.psm
 y_sign                     35'd         pBlaze_prog.psm
 y_ex7                      36'd         pBlaze_prog.psm
 y_ex6                      37'd         pBlaze_prog.psm
 y_m6                       38'd         pBlaze_prog.psm
 y_m5                       39'd         pBlaze_prog.psm
 y_m4                       40'd         pBlaze_prog.psm
 y_m3                       41'd         pBlaze_prog.psm
 y_m2                       42'd         pBlaze_prog.psm
 y_m1                       43'd         pBlaze_prog.psm
 y_m0                       44'd         pBlaze_prog.psm
 y_grs                      45'd         pBlaze_prog.psm
 r_sign                     46'd         pBlaze_prog.psm
 r_ex7                      47'd         pBlaze_prog.psm
 r_ex6                      48'd         pBlaze_prog.psm
 r_m6                       49'd         pBlaze_prog.psm
 r_m5                       50'd         pBlaze_prog.psm
 r_m4                       51'd         pBlaze_prog.psm
 r_m3                       52'd         pBlaze_prog.psm
 r_m2                       53'd         pBlaze_prog.psm
 r_m1                       55'd         pBlaze_prog.psm
 r_m0                       56'd         pBlaze_prog.psm
 r_grs                      57'd         pBlaze_prog.psm
 op1_status                 58'd         pBlaze_prog.psm
 op2_status                 59'd         pBlaze_prog.psm
 underflow                  60'd         pBlaze_prog.psm
 IEEE_754_DP_signals        61'd         pBlaze_prog.psm
 Umr_6                      64'd         pBlaze_prog.psm
 Umr_5                      65'd         pBlaze_prog.psm
 Umr_4                      66'd         pBlaze_prog.psm
 Umr_3                      67'd         pBlaze_prog.psm
 Umr_2                      68'd         pBlaze_prog.psm
 Umr_1                      69'd         pBlaze_prog.psm
 Umr_0                      70'd         pBlaze_prog.psm
 Lmr_6                      71'd         pBlaze_prog.psm
 Lmr_5                      72'd         pBlaze_prog.psm
 Lmr_4                      73'd         pBlaze_prog.psm
 Lmr_3                      74'd         pBlaze_prog.psm
 Lmr_2                      75'd         pBlaze_prog.psm
 Lmr_1                      76'd         pBlaze_prog.psm
 Lmr_0                      77'd         pBlaze_prog.psm
 mr_save_carry              78'd         pBlaze_prog.psm
 Umx_shifted_6              80'd         pBlaze_prog.psm
 Umx_shifted_5              81'd         pBlaze_prog.psm
 Umx_shifted_4              82'd         pBlaze_prog.psm
 Umx_shifted_3              83'd         pBlaze_prog.psm
 Umx_shifted_2              84'd         pBlaze_prog.psm
 Umx_shifted_1              85'd         pBlaze_prog.psm
 Umx_shifted_0              86'd         pBlaze_prog.psm
 Lmx_shifted_6              87'd         pBlaze_prog.psm
 Lmx_shifted_5              88'd         pBlaze_prog.psm
 Lmx_shifted_4              89'd         pBlaze_prog.psm
 Lmx_shifted_3              90'd         pBlaze_prog.psm
 Lmx_shifted_2              91'd         pBlaze_prog.psm
 Lmx_shifted_1              92'd         pBlaze_prog.psm
 Lmx_shifted_0              93'd         pBlaze_prog.psm



No TABLEs defined



List of text strings

 STRING name       String                                Source PSM File

 KCPSM6_version$   "v2.70"                               
 datestamp$        "03 Mar 2019"                         
 timestamp$        "02:07:34"                            
 welcome$          "Welcome to KCPSM6 !!! (Debug Mode)"  pBlaze_prog.psm



List of line labels

   Label                               Addr  Source PSM File

   start                               004   pBlaze_prog.psm
   finished_calculation                03A   pBlaze_prog.psm
   debug_mode                          03B   pBlaze_prog.psm
   print_two_operands                  042   pBlaze_prog.psm
   wait_for_start                      04C   pBlaze_prog.psm
   welcome_msg                         053   pBlaze_prog.psm
   UART_TX                             078   pBlaze_prog.psm
   UART_TX_delay                       07E   pBlaze_prog.psm
   UART_RX                             082   pBlaze_prog.psm
   rx_timeout                          083   pBlaze_prog.psm
   read_Rx                             089   pBlaze_prog.psm
   reset_UART_macros                   08B   pBlaze_prog.psm
 * delay_1ms                           08E   pBlaze_prog.psm
   delay_1ms_loop                      090   pBlaze_prog.psm
   send_CRLF                           094   pBlaze_prog.psm
   send_message                        099   pBlaze_prog.psm
   clear_screen                        0A0   pBlaze_prog.psm
 * reg_print_hex                       0AF   pBlaze_prog.psm
   less_or_eq_to_nine3                 0B7   pBlaze_prog.psm
   greater_than_nine3                  0B9   pBlaze_prog.psm
   done_adding3                        0BA   pBlaze_prog.psm
   less_or_eq_to_nine4                 0BF   pBlaze_prog.psm
   greater_than_nine4                  0C1   pBlaze_prog.psm
   done_adding4                        0C2   pBlaze_prog.psm
   SPM_print_hex                       0C5   pBlaze_prog.psm
   print_hex_loop                      0C6   pBlaze_prog.psm
   less_or_eq_to_nine                  0CF   pBlaze_prog.psm
   greater_than_nine                   0D1   pBlaze_prog.psm
   done_adding                         0D2   pBlaze_prog.psm
   less_or_eq_to_nine2                 0D7   pBlaze_prog.psm
   greater_than_nine2                  0D9   pBlaze_prog.psm
   done_adding2                        0DA   pBlaze_prog.psm
 * done_printing_one_hex               0DC   pBlaze_prog.psm
 * add_dp                              0E2   pBlaze_prog.psm
   load_8Bytes_from_ext_BRAM           0E3   pBlaze_prog.psm
   read_8bytes_ext_BRAM_loop           0E5   pBlaze_prog.psm
   Read_ext_mem                        0ED   pBlaze_prog.psm
   Write_ext_mem                       0F5   pBlaze_prog.psm
   invoke_done_interrupt               0FD   pBlaze_prog.psm
   delay_int_loop                      103   pBlaze_prog.psm
   write_result_to_external_memory     108   pBlaze_prog.psm
 * arith_add_x_y                       129   pBlaze_prog.psm
 * final_op1_NaN                       130   pBlaze_prog.psm
   return_NAN                          133   pBlaze_prog.psm
   final_op1_not_NaN                   13A   pBlaze_prog.psm
 * final_op1_Inf                       13C   pBlaze_prog.psm
   final_op1_not_Inf                   141   pBlaze_prog.psm
 * final_op1_is_zero                   143   pBlaze_prog.psm
   check_final_op2                     148   pBlaze_prog.psm
 * final_op2_not_NaN                   14A   pBlaze_prog.psm
 * final_op2_not_Inf                   153   pBlaze_prog.psm
   return_zero                         156   pBlaze_prog.psm
   return_x                            165   pBlaze_prog.psm
   return_x_NAN                        177   pBlaze_prog.psm
 * return_x_NAN_Inf                    18A   pBlaze_prog.psm
   NaN_bit_off                         196   pBlaze_prog.psm
   done_applying_NaN_bit               197   pBlaze_prog.psm
   return_y                            1AA   pBlaze_prog.psm
   return_y_NAN                        1BC   pBlaze_prog.psm
   return_y_NAN_Inf                    1CF   pBlaze_prog.psm
 * set_sign_bit_to_0                   1DA   pBlaze_prog.psm
   set_sign_bit_to_1                   1DC   pBlaze_prog.psm
   set_sign_bit_done                   1DD   pBlaze_prog.psm
 * set_NaN_bit_to_0                    1E0   pBlaze_prog.psm
   set_NaN_bit_to_1                    1E2   pBlaze_prog.psm
   set_NaN_bit_done                    1E3   pBlaze_prog.psm
   COMP_swap_ex                        1F2   pBlaze_prog.psm
 * ex_greater_equal_than_ey            1F9   pBlaze_prog.psm
 * ex_equal_ey                         1FA   pBlaze_prog.psm
   ex_less_than_ey                     206   pBlaze_prog.psm
   swap_done                           207   pBlaze_prog.psm
   op1_is_normal_nx_is_1               214   pBlaze_prog.psm
   op2_is_normal_ny_is_1               219   pBlaze_prog.psm
   not_a_big_shift                     221   pBlaze_prog.psm
   my_mantisa_shift_right_loop         22D   pBlaze_prog.psm
   dont_set_sticky_bit_y               239   pBlaze_prog.psm
   my_mantisa_shift_right_loop_done    23C   pBlaze_prog.psm
   my_mantisa_shift_right_done         247   pBlaze_prog.psm
   sx_is_neg_sy_is_pos                 252   pBlaze_prog.psm
   sx_is_positive                      257   pBlaze_prog.psm
   sx_sy_is_positive                   25F   pBlaze_prog.psm
   perform_addition                    263   pBlaze_prog.psm
   dont_apply_twos                     280   pBlaze_prog.psm
   sign_calc_done                      282   pBlaze_prog.psm
   load_mx                             29E   pBlaze_prog.psm
   load_my                             2A7   pBlaze_prog.psm
   swap_operands                       2B0   pBlaze_prog.psm
   count_nlz                           2DD   pBlaze_prog.psm
   count_mlz_loop                      2DE   pBlaze_prog.psm
   counting_z_done                     2E2   pBlaze_prog.psm
   round                               2E3   pBlaze_prog.psm
   guard_bit_is_1                      2E6   pBlaze_prog.psm
   round_bit_is_0                      2E9   pBlaze_prog.psm
   round_RET_one                       2ED   pBlaze_prog.psm
   round_RET_zero                      2F0   pBlaze_prog.psm
   apply_rounding                      2F2   pBlaze_prog.psm
   decompose_x                         2FA   pBlaze_prog.psm
   negative_sign_x                     2FF   pBlaze_prog.psm
   test_x_sign_done                    300   pBlaze_prog.psm
   subnormal_involved_x                312   pBlaze_prog.psm
   subnormal_test_done_x               313   pBlaze_prog.psm
   decompose_y                         324   pBlaze_prog.psm
 * positive_sign_y                     327   pBlaze_prog.psm
   negative_sign_y                     329   pBlaze_prog.psm
   test_y_sign_done                    32A   pBlaze_prog.psm
   subnormal_involved_y                33C   pBlaze_prog.psm
   subnormal_test_done_y               33D   pBlaze_prog.psm
   set_ops_status                      34E   pBlaze_prog.psm
 * ex_zero                             354   pBlaze_prog.psm
 * op_1_is_zero                        36B   pBlaze_prog.psm
   op1_is_subnormal                    36F   pBlaze_prog.psm
   ex_not_zero                         373   pBlaze_prog.psm
 * ex_all_one                          37A   pBlaze_prog.psm
 * op1_is_NaN                          389   pBlaze_prog.psm
   op1_is_inf                          38D   pBlaze_prog.psm
   ex_not_all_one                      391   pBlaze_prog.psm
   set_op2_status                      394   pBlaze_prog.psm
 * ey_zero                             39A   pBlaze_prog.psm
 * op_2_is_zero                        3A9   pBlaze_prog.psm
   op2_is_subnormal                    3AD   pBlaze_prog.psm
   ey_not_zero                         3B1   pBlaze_prog.psm
 * ey_all_one                          3B8   pBlaze_prog.psm
 * op2_is_NaN                          3C7   pBlaze_prog.psm
   op2_is_inf                          3CB   pBlaze_prog.psm
   ey_not_all_one                      3CF   pBlaze_prog.psm
   twos_mx                             3D3   pBlaze_prog.psm
   twos_my                             3ED   pBlaze_prog.psm
   normalize                           407   pBlaze_prog.psm
   dont_keep_sticky_bit                40D   pBlaze_prog.psm
   done_keeping_sticky_bit             40E   pBlaze_prog.psm
   no_overflow_found                   41E   pBlaze_prog.psm
 * check_subnormal_case                420   pBlaze_prog.psm
   cancellation                        431   pBlaze_prog.psm
   got_nlz_4                           444   pBlaze_prog.psm
   got_nlz_8                           44B   pBlaze_prog.psm
   got_nlz_8_s5                        452   pBlaze_prog.psm
   got_nlz_8_s4                        459   pBlaze_prog.psm
   got_nlz_8_s3                        460   pBlaze_prog.psm
   got_nlz_8_s2                        467   pBlaze_prog.psm
   nlz_counting_done                   46B   pBlaze_prog.psm
   intermediate_shift_riht_loop        46E   pBlaze_prog.psm
   done_intermediate_shift_riht_loop   478   pBlaze_prog.psm
 * normalize_shift_right_by_one        47F   pBlaze_prog.psm
   done_cancellation                   48D   pBlaze_prog.psm
   arith_mul_x_y                       48E   pBlaze_prog.psm
   er_greater_than_53                  4AC   pBlaze_prog.psm
   keep_shifting_mr_to_right           4AC   pBlaze_prog.psm
   mul_compose_result                  4B7   pBlaze_prog.psm
   dont_inc_exponent                   4C3   pBlaze_prog.psm
   not_normal_case                     4CD   pBlaze_prog.psm
   mul_result_is_zero                  4FE   pBlaze_prog.psm
   done_multiplying                    4FF   pBlaze_prog.psm
   mul_mx_my                           500   pBlaze_prog.psm
   next_shift_add                      51E   pBlaze_prog.psm
   next_right_shift                    525   pBlaze_prog.psm
   shift_and_add                       533   pBlaze_prog.psm
   keep_shifting_mx_left               54A   pBlaze_prog.psm
 * shifting_mx_left_done               55A   pBlaze_prog.psm
   shifting_mx_left_done2              568   pBlaze_prog.psm
   finish_mul                          5B1   pBlaze_prog.psm
   add_Ex_Ey                           5B2   pBlaze_prog.psm
   subnormal_exponent_detected         5BA   pBlaze_prog.psm
   done_exponent_subtracting           5BC   pBlaze_prog.psm
   subnormal_exponent_detected_y       5C4   pBlaze_prog.psm
   done_exponent_subtracting_y         5C6   pBlaze_prog.psm
   mul_special_cases                   5CB   pBlaze_prog.psm
 * mul_final_op1_NaN                   5CF   pBlaze_prog.psm
   mul_final_op1_not_NaN               5D2   pBlaze_prog.psm
 * mul_final_op1_Inf                   5D4   pBlaze_prog.psm
   mul_final_op1_not_Inf               5D9   pBlaze_prog.psm
 * mul_final_op1_is_zero               5DB   pBlaze_prog.psm
   mul_check_final_op2                 5E0   pBlaze_prog.psm
   return_y_NAN_positive               5E3   pBlaze_prog.psm
   mul_final_op2_not_NaN               5E8   pBlaze_prog.psm
   return_zero_mul                     5EE   pBlaze_prog.psm
   return_y_Inf                        5FD   pBlaze_prog.psm
   return_x_Inf                        60E   pBlaze_prog.psm
   return_pos_inf                      61F   pBlaze_prog.psm
   return_xy_NAN                       631   pBlaze_prog.psm
   test_y_significand                  636   pBlaze_prog.psm
   mul_cancellation                    639   pBlaze_prog.psm
   mul_got_nlz_4                       646   pBlaze_prog.psm
   mul_got_nlz_8                       64D   pBlaze_prog.psm
   mul_got_nlz_8_s3                    654   pBlaze_prog.psm
   mul_got_nlz_8_s2                    65B   pBlaze_prog.psm
   mul_got_nlz_8_s1                    662   pBlaze_prog.psm
   mul_got_nlz_8_s0                    669   pBlaze_prog.psm
   mul_nlz_counting_done               66D   pBlaze_prog.psm
   mul_intermediate_shift_riht_loop    66E   pBlaze_prog.psm
   mul_normalize_mx                    679   pBlaze_prog.psm
   already_normalized                  690   pBlaze_prog.psm
   mul_normalize_my                    691   pBlaze_prog.psm
   already_normalized_y                6A8   pBlaze_prog.psm
   mul_round                           6A9   pBlaze_prog.psm
   dont_set_sticky_bit                 6AC   pBlaze_prog.psm
   mul_guard_bit_is_1                  6AF   pBlaze_prog.psm
   mul_round_bit_is_0                  6B2   pBlaze_prog.psm
   mul_round_RET_one                   6B6   pBlaze_prog.psm
   mul_round_RET_zero                  6B7   pBlaze_prog.psm
   arith_div_x_y                       6B8   pBlaze_prog.psm
   no_sub_ex_ey_overflow               6C5   pBlaze_prog.psm
   sub_ex_ey_overflow_done             6C6   pBlaze_prog.psm
 * div_result_not_inf                  6C8   pBlaze_prog.psm
   div_set_sticky_bit_loop             6D2   pBlaze_prog.psm
   dont_turn_sticky_bit_on             6D5   pBlaze_prog.psm
   div_er_greater_than_53              6E4   pBlaze_prog.psm
   div_keep_shifting_mr_to_right       6E4   pBlaze_prog.psm
   div_check_overflow                  6F2   pBlaze_prog.psm
   div_compose_result                  6F7   pBlaze_prog.psm
   div_dont_shift_mr_left_subnormal    708   pBlaze_prog.psm
   div_dont_shift_mr_left              710   pBlaze_prog.psm
   div_no_exp_overflow_detected        735   pBlaze_prog.psm
   div_result_is_zero                  756   pBlaze_prog.psm
   done_dividing                       757   pBlaze_prog.psm
   div_special_cases                   758   pBlaze_prog.psm
 * div_final_op1_NaN                   75C   pBlaze_prog.psm
   div_final_op1_not_NaN               75F   pBlaze_prog.psm
 * div_final_op1_Inf                   761   pBlaze_prog.psm
   div_final_op1_not_Inf               768   pBlaze_prog.psm
 * div_final_op1_is_zero               76A   pBlaze_prog.psm
   div_check_final_op2                 76F   pBlaze_prog.psm
   div_return_y_NAN_positive           772   pBlaze_prog.psm
   div_final_op2_not_NaN               777   pBlaze_prog.psm
   div_mx_my                           77D   pBlaze_prog.psm
   compare_dividend                    79A   pBlaze_prog.psm
   dividend_is_less                    7B6   pBlaze_prog.psm
   shift_dividend_left                 7C0   pBlaze_prog.psm
 * div_finished                        7CC   pBlaze_prog.psm
   sub_Ex_Ey                           7D7   pBlaze_prog.psm
   sub_subnormal_exponent_detected     7DF   pBlaze_prog.psm
   sub_done_exponent_subtracting       7E1   pBlaze_prog.psm
   sub_subnormal_exponent_detected_y   7E9   pBlaze_prog.psm
   sub_done_exponent_subtracting_y     7EB   pBlaze_prog.psm
   return_div_NAN                      7F0   pBlaze_prog.psm
   div_round                           802   pBlaze_prog.psm
   div_guard_bit_is_1                  805   pBlaze_prog.psm
   div_round_bit_is_0                  808   pBlaze_prog.psm
   div_round_RET_one                   80A   pBlaze_prog.psm
   div_round_RET_zero                  80B   pBlaze_prog.psm
   return_inf                          80C   pBlaze_prog.psm
   div_return_NAN                      81E   pBlaze_prog.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            170
 STAR              -

 AND              38
 OR               37
 XOR              38

 ADD              62
 ADDCY            66
 SUB              29
 SUBCY            27

 TEST             96
 TESTCY           27
 COMPARE          34
 COMPARECY        21

 SL0              19
 SL1              10
 SLX               -
 SLA             105
 RL                -
 SR0              35
 SR1               -
 SRX               -
 SRA             108
 RR                -

 REGBANK          16

 INPUT             4
 OUTPUT           11
 OUTPUTK           2

 STORE           346
 FETCH           346

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            237
 JUMP@             -
 CALL            103
 CALL@             1
 RETURN           60
 LOAD&RETURN      37

 HWBUILD           -



End of KCPSM6 log file.
